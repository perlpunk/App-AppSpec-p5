#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/AppSpec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_APPSPEC';
  # ABSTRACT: App Module ad utilities for appspec tool
  use strict;
  use warnings;
  use 5.010;
  use utf8;
  package App::AppSpec;
  use Term::ANSIColor;
  use YAML::PP;
  use File::Basename qw/ dirname /;
  
  our $VERSION = '0.000'; # VERSION
  
  use base 'App::Spec::Run::Cmd';
  
  sub _read_spec {
      my ($self, $run) = @_;
      my $parameters = $run->parameters;
  
      my $spec_file = $parameters->{spec_file};
      my $spec = App::Spec->read($spec_file);
      return $spec;
  }
  
  sub cmd_completion {
      my ($self, $run) = @_;
      my $options = $run->options;
      my $parameters = $run->parameters;
      my $name = $options->{name};
  
      my $shell = $options->{zsh} ? "zsh" : $options->{bash} ? "bash" : '';
      die "Specify which shell" unless $shell;
  
      my $spec = $self->_read_spec($run);
      if (defined $name) {
          $spec->name($name);
      }
      my $completion = $spec->generate_completion(
          shell => $shell,
      );
      say $completion;
  }
  
  sub generate_pod {
      my ($self, $run) = @_;
      my $parameters = $run->parameters;
  
      my $spec = $self->_read_spec($run);
  
      require App::Spec::Pod;
      my $generator = App::Spec::Pod->new(
          spec => $spec,
      );
      my $pod = $generator->generate;
  
      say $pod;
  }
  
  sub cmd_validate {
      my ($self, $run) = @_;
      my $options = $run->options;
      my $parameters = $run->parameters;
  
      my @errors;
      require App::AppSpec::Schema::Validator;
      my $validator = App::AppSpec::Schema::Validator->new;
      my $spec_file = $parameters->{spec_file};
      if (ref $spec_file eq 'SCALAR') {
          my $spec = YAML::PP::Load($$spec_file);
          @errors = $validator->validate_spec($spec);
      }
      else {
          @errors = $validator->validate_spec_file($spec_file);
      }
      binmode STDOUT, ":encoding(utf-8)";
      if (@errors) {
          print $validator->format_errors(\@errors);
          say $run->colored(out => red => "Not valid!");
      }
      else {
          say $run->colored(out => [qw/ bold green /] => "Validated âœ“");
      }
  }
  
  sub cmd_new {
      my ($self, $run) = @_;
      my $options = $run->options;
      my $params = $run->parameters;
      my $dist_path = $params->{path};
      require File::Path;
  
      my $name = $options->{name};
      my $class = $options->{class};
      my $overwrite = $options->{overwrite};
      unless ($name =~ m/^\w[\w+-]*/) {
          die "Option name '$name': invalid app name";
      }
      unless ($class =~ m/^[a-zA-Z]\w*(::\w+)+$/) {
          die "Option class '$class': invalid classname";
      }
      my $dist = $class;
      $dist =~ s/::/-/g;
      $dist = $dist_path // $dist;
      if (-d $dist and not $overwrite) {
          die "Directory $dist already exists";
      }
      elsif (-d $dist) {
          say "Removing old $dist directory first";
          File::Path::remove_tree($dist);
      }
      my $spec = <<"EOM";
  name: $name
  appspec: { version: '0.001' }
  class: $class
  title: 'app title'
  description: 'app description'
  options:
  - name: some-flag
    type: flag
    summary: option summary
  - spec: other-option=s --another option
  EOM
      my $subname = $options->{"with-subcommands"} ? "mycommand" : "execute";
      my $module = <<"EOM";
  package $class;
  use strict;
  use warnings;
  use feature qw/ say /;
  use base 'App::Spec::Run::Cmd';
  
  sub $subname \{
      my (\$self, \$run) = \@_;
      my \$options = \$run->options;
      my \$parameters = \$run->parameters;
  
      say "Hello world";
  \}
  
  1;
  EOM
      my $script = <<"EOM";
  #!/usr/bin/env perl
  use strict;
  use warnings;
  
  use App::Spec;
  use App::AppSpec;
  use $class;
  use File::Share qw/ dist_file /;
  
  my \$specfile = dist_file("$dist", "$name-spec.yaml");
  my \$spec = App::Spec->read(\$specfile);
  my \$run = \$spec->runner;
  \$run->run;
  EOM
      if ($options->{"with-subcommands"}) {
              $spec .= <<"EOM";
  subcommands:
      mycommand:
        summary: "Summary for mycommand"
        op: "mycommand"
        description: "Description for mycommand"
        parameters:
        - name: "myparam"
          summary: "Summary for myparam"
          required: 1
  EOM
      }
      my $module_path = $class;
      $module_path =~ s#::#/#g;
      $module_path = "$dist/lib/$module_path.pm";
      File::Path::make_path($dist);
      File::Path::make_path("$dist/share");
      File::Path::make_path("$dist/bin");
      File::Path::make_path(dirname $module_path);
      my $specfile = "$dist/share/$name-spec.yaml";
      say "Writing spec to $specfile";
      open my $fh, ">", $specfile or die $!;
      print $fh $spec;
      close $fh;
  
      open $fh, ">", $module_path or die $!;
      print $fh $module;
      close $fh;
  
      open $fh, ">", "$dist/bin/$name" or die $!;
      print $fh $script;
      close $fh;
  }
  
  =pod
  
  =head1 NAME
  
  App::AppSpec - Utilities for App::Spec authors
  
  =head1 SYNOPSIS
  
  See L<appspec> documentation for the command line utility.
  
  =head1 DESCRIPTION
  
  This is the app class for the L<appspec> command line tool.
  It contains utilities for L<App::Spec> files, like generating
  completion or pod from it.
  
  =head1 METHODS
  
  =over 4
  
  =item cmd_completion, cmd_new, cmd_validate, generate_pod
  
  =back
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
APP_APPSPEC

$fatpacked{"App/AppSpec/Schema/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_APPSPEC_SCHEMA_VALIDATOR';
  use strict;
  use warnings;
  package App::AppSpec::Schema::Validator;
  
  our $VERSION = '0.000'; # VERSION
  
  use App::Spec;
  use App::Spec::Schema qw/ $SCHEMA /;
  use YAML::PP;
  use Moo;
  
  sub validate_spec_file {
      my ($self, $file) = @_;
      my $yp = YAML::PP->new( boolean => 'JSON::PP', schema => [qw/ JSON /] );
      my $spec = $yp->load_file($file);
      return $self->validate_spec($spec);
  }
  
  sub validate_spec {
      my ($self, $spec) = @_;
      eval { require JSON::Validator }
          or die "JSON::Validator is needed for validating a spec file";
      my $json_validator = JSON::Validator->new;
      $json_validator->schema($SCHEMA);
      my @errors = $json_validator->validate($spec);
      return @errors;
  }
  
  sub format_errors {
      my ($self, $errors) = @_;
      my $output = '';
      for my $error (@$errors) {
          $output .= "Path: " . $error->path . "\n";
          $output .= "    Message: " . $error->message . "\n";
      }
      return $output;
  }
  
  1;
APP_APPSPEC_SCHEMA_VALIDATOR

$fatpacked{"App/AppSpec/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_APPSPEC_SPEC';
  use strict;
  use warnings;
  package App::AppSpec::Spec;
  
  our $VERSION = '0.000'; # VERSION
  
  use base 'Exporter';
  our @EXPORT_OK = qw/ $SPEC /;
  
  our $SPEC;
  
  # START INLINE
  $SPEC = {
    'appspec' => {
      'version' => '0.001'
    },
    'class' => 'App::AppSpec',
    'description' => 'This script is a collection of tools for authors of L<App::Spec> command line
  scripts.
  
    # generate completion
    % appspec completion --bash path/to/spec.yaml
    # generate pod
    % appspec pod path/to/spec.yaml
    # validate your spec file
    % appspec validate path/to/spec.yaml
    # generate a new App::Spec app skeleton
    % appspec new --class App::foo --name foo --with-subcommands
  ',
    'markup' => 'pod',
    'name' => 'appspec',
    'options' => [],
    'subcommands' => {
      'completion' => {
        'description' => 'This command takes a spec file and outputs the corresponding
  shell script for tab completion.
  ',
        'op' => 'cmd_completion',
        'options' => [
          'name=s --name of the program (optional, override the value from the spec)',
          'zsh --for zsh',
          'bash --for bash'
        ],
        'parameters' => [
          '+spec_file= +file --Path to the spec file (use \'-\' for standard input)'
        ],
        'summary' => 'Generate completion for a specified spec file'
      },
      'new' => {
        'description' => 'This command creates a skeleton for a new app.
  It will create a directory for your app and write a skeleton
  spec file.
  
  Example:
  
    appspec new --name myprogram --class App::MyProgram App-MyProgram
  ',
        'op' => 'cmd_new',
        'options' => [
          '+name|n=s --The (file) name of the app',
          '+class|c=s --The main class name for your app implementation',
          'overwrite|o --Overwrite existing dist directory',
          'with-subcommands|s --Create an app with subcommands'
        ],
        'parameters' => [
          'path=s --Path to the distribution directory (default is \'Dist-Name\' in current directory)'
        ],
        'summary' => 'Create new app'
      },
      'pod' => {
        'description' => 'This command takes a spec file and outputs the generated pod
  documentation.
  ',
        'op' => 'generate_pod',
        'parameters' => [
          '+spec_file= +file --Path to the spec file (use \'-\' for standard input)'
        ],
        'summary' => 'Generate pod'
      },
      'validate' => {
        'description' => 'This command takes a spec file and validates it against the current
  L<App::Spec> schema.
  ',
        'op' => 'cmd_validate',
        'options' => [
          'color|C --output colorized'
        ],
        'parameters' => [
          '+spec_file= +file --Path to the spec file (use \'-\' for standard input)'
        ],
        'summary' => 'Validate spec file'
      }
    },
    'title' => 'Utilities for spec files for App::Spec cli apps'
  };
  # END INLINE
  
  1;
APP_APPSPEC_SPEC

$fatpacked{"App/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC';
  # ABSTRACT: Specification for commandline app
  use strict;
  use warnings;
  package App::Spec;
  use 5.010;
  
  our $VERSION = '0.013'; # VERSION
  
  use App::Spec::Subcommand;
  use App::Spec::Option;
  use App::Spec::Parameter;
  
  use Moo;
  
  with('App::Spec::Role::Command');
  
  has title => ( is => 'rw' );
  has abstract => ( is => 'rw' );
  
  
  
  
  sub runner {
      my ($self, %args) = @_;
      my $class = $self->class;
      my $cmd = $class->new;
      my $run = App::Spec::Run->new({
          spec => $self,
          cmd => $cmd,
          %args,
      });
      return $run;
  }
  
  sub usage {
      my ($self, %args) = @_;
      my $cmds = $args{commands};
      my %highlights = %{ $args{highlights} || {} };
      my $colored = $args{colored} || sub { $_[1] };
      my $appname = $self->name;
  
      my $abstract = $self->abstract // '';
      my $title = $self->title;
      my ($options, $parameters, $subcmds) = $self->_gather_options_parameters($cmds);
      my $header = $colored->(['bold'], "$appname - $title");
      my $usage = <<"EOM";
  $header
  $abstract
  
  EOM
  
      my $body = '';
      my $usage_header = $colored->([qw/ bold /], "Usage:");
      $usage .= "$usage_header $appname";
      $usage .= " @$cmds" if @$cmds;
      if (keys %$subcmds) {
          my $maxlength = 0;
          my @table;
          my $usage_string = "<subcommands>";
          my $header = "Subcommands:";
          if ($highlights{subcommands}) {
              $colored->([qw/ bold red /], $usage_string);
              $colored->([qw/ bold red /], $header);
          }
          else {
              $colored->([qw/ bold /], $header);
          }
          $usage .= " $usage_string";
          $body .= "$header\n";
  
          my %keys;
          @keys{ keys %$subcmds } = ();
          my @keys;
          if (@$cmds) {
              @keys = sort keys %keys;
          }
          else {
              for my $key (qw/ help _meta /) {
                  if (exists $keys{ $key }) {
                      push @keys, $key;
                      delete $keys{ $key };
                  }
              }
              unshift @keys, sort keys %keys;
          }
          for my $name (@keys) {
              my $cmd_spec = $subcmds->{ $name };
              my $summary = $cmd_spec->summary;
              push @table, [$name, $summary];
              if (length $name > $maxlength) {
                  $maxlength = length $name;
              }
          }
          $body .= $self->_output_table(\@table, [$maxlength]);
      }
  
      if (@$parameters) {
          my $maxlength = 0;
          my @table;
          my @highlights;
          for my $param (@$parameters) {
              my $name = $param->name;
              my $highlight = $highlights{parameters}->{ $name };
              push @highlights, $highlight ? 1 : 0;
              my $summary = $param->summary;
              my $param_usage_header = $param->to_usage_header;
              if ($highlight) {
                  $colored->([qw/ bold red /], $param_usage_header);
              }
              $usage .= " " . $param_usage_header;
              my ($req, $multi) = (' ', '  ');
              if ($param->required) {
                  $req = "*";
              }
              if ($param->mapping) {
                  $multi = '{}';
              }
              elsif ($param->multiple) {
                  $multi = '[]';
              }
  
              my $flags = $self->_param_flags_string($param);
  
              push @table, [$name, $req, $multi, $summary . $flags];
              if (length $name > $maxlength) {
                  $maxlength = length $name;
              }
          }
          my $parameters_string = $colored->([qw/ bold /], "Parameters:");
          $body .= "$parameters_string\n";
          my @lines = $self->_output_table(\@table, [$maxlength]);
          my $lines = $self->_colorize_lines(\@lines, \@highlights, $colored);
          $body .= $lines;
      }
  
      if (@$options) {
          my @highlights;
          $usage .= " [options]";
          my $maxlength = 0;
          my @table;
          for my $opt (sort { $a->name cmp $b->name } @$options) {
              my $name = $opt->name;
              my $highlight = $highlights{options}->{ $name };
              push @highlights, $highlight ? 1 : 0;
              my $aliases = $opt->aliases;
              my $summary = $opt->summary;
              my @names = map {
                  length $_ > 1 ? "--$_" : "-$_"
              } ($name, @$aliases);
              my $string = "@names";
              if (length $string > $maxlength) {
                  $maxlength = length $string;
              }
              my ($req, $multi) = (' ', '  ');
              if ($opt->required) {
                  $req = "*";
              }
              if ($opt->mapping) {
                  $multi = '{}';
              }
              elsif ($opt->multiple) {
                  $multi = '[]';
              }
  
              my $flags = $self->_param_flags_string($opt);
  
              push @table, [$string, $req, $multi, $summary . $flags];
          }
          my $options_string = $colored->([qw/ bold /], "Options:");
          $body .= "\n$options_string\n";
          my @lines = $self->_output_table(\@table, [$maxlength]);
          my $lines = $self->_colorize_lines(\@lines, \@highlights, $colored);
          $body .= $lines;
      }
  
      return "$usage\n\n$body";
  }
  
  sub _param_flags_string {
      my ($self, $param) = @_;
      my @flags;
      if ($param->type eq 'flag') {
          push @flags, "flag";
      }
      if ($param->multiple) {
          push @flags, "multiple";
      }
      if ($param->mapping) {
          push @flags, "mapping";
      }
      my $flags = @flags ? " (" . join("; ", @flags) . ")" : '';
      return $flags;
  }
  
  sub _colorize_lines {
      my ($self, $lines, $highlights, $colored) = @_;
      my $output = '';
      for my $i (0 .. $#$lines) {
          my $line = $lines->[ $i ];
          if ($highlights->[ $i ]) {
              $colored->([qw/ bold red /], $line);
          }
          $output .= $line;
      }
      return $output;
  }
  
  sub _output_table {
      my ($self, $table, $lengths) = @_;
      my @lines;
      my @lengths = map {
          defined $lengths->[$_] ? "%-$lengths->[$_]s" : "%s"
      } 0 .. @{ $table->[0] } - 1;
      for my $row (@$table) {
          no warnings 'uninitialized';
          push @lines, sprintf join('  ', @lengths) . "\n", @$row;
      }
      return wantarray ? @lines : join '', @lines;
  }
  
  
  sub _gather_options_parameters {
      my ($self, $cmds) = @_;
      my @options;
      my @parameters;
      my $global_options = $self->options;
      my $commands = $self->subcommands;
      push @options, @$global_options;
  
      for my $cmd (@$cmds) {
          my $cmd_spec = $commands->{ $cmd };
          my $options = $cmd_spec->options || [];
          my $parameters = $cmd_spec->parameters || [];
          push @options, @$options;
          push @parameters, @$parameters;
  
          $commands = $cmd_spec->subcommands || {};
  
      }
      return \@options, \@parameters, $commands;
  }
  
  sub generate_completion {
      my ($self, %args) = @_;
      my $shell = delete $args{shell};
  
      if ($shell eq "zsh") {
          require App::Spec::Completion::Zsh;
          my $completer = App::Spec::Completion::Zsh->new(
              spec => $self,
          );
          return $completer->generate_completion(%args);
      }
      elsif ($shell eq "bash") {
          require App::Spec::Completion::Bash;
          my $completer = App::Spec::Completion::Bash->new(
              spec => $self,
          );
          return $completer->generate_completion(%args);
      }
  }
  
  
  sub make_getopt {
      my ($self, $options, $result, $specs) = @_;
      my @getopt;
      for my $opt (@$options) {
          my $name = $opt->name;
          my $spec = $name;
          if (my $aliases = $opt->aliases) {
              $spec .= "|$_" for @$aliases;
          }
          unless ($opt->type eq 'flag') {
              $spec .= "=s";
          }
          $specs->{ $name } = $opt;
          if ($opt->multiple) {
              if ($opt->type eq 'flag') {
                  $spec .= '+';
              }
              elsif ($opt->mapping) {
                  $result->{ $name } = {};
                  $spec .= '%';
              }
              else {
                  $result->{ $name } = [];
                  $spec .= '@';
              }
          }
          push @getopt, $spec, \$result->{ $name },
      }
      return @getopt;
  }
  
  =pod
  
  =head1 NAME
  
  App::Spec - Specification for commandline apps
  
  =head1 SYNOPSIS
  
  WARNING: This is still experimental. The spec is subject to change.
  
  This module represents a specification of a command line tool.
  Currently it can read the spec from a YAML file or directly from a data
  structure in perl.
  
  It uses the role L<App::Spec::Role::Command>.
  
  The L<App::Spec::Run> module is the framework which will run the actual
  app.
  
  Have a look at the L<App::Spec::Tutorial> for how to write an app.
  
  In the examples directory you will find the app C<myapp> which is supposed
  to demonstrate everything that App::Spec supports right now.
  
  Your script:
  
      use App::Spec;
      my $spec = App::Spec->read("/path/to/myapp-spec.yaml");
  
      my $run = $spec->runner;
      $run->run;
  
      # this is equivalent to
      #my $run = App::Spec::Run->new(
      #    spec => $spec,
      #    cmd => Your::App->new,
      #);
      #$run->run;
  
  Your App class:
  
      package Your::App;
      use base 'App::Spec::Run::Cmd';
  
      sub command1 {
          my ($self, $run) = @_;
          my $options = $run->options;
          my $param = $run->parameters;
          # Do something
          $run->out("Hello world!");
          $run->err("oops");
          # you can also use print directly
      }
  
  
  =head1 METHODS
  
  =over 4
  
  =item read
  
      my $spec = App::Spec->read("/path/to/myapp-spec.yaml");
  
  =item load_data
  
  Takes a file, hashref or glob and returns generated appspec hashref
  
      my $hash = $class->load_data($file);
  
  =item build
  
  Builds objects out of the hashref
  
      my $appspec = App::Spec->build(%hash);
  
  =item runner
  
  Returns an instance of the your app class
  
      my $run = $spec->runner;
      $run->run;
  
      # this is equivalent to
      my $run = App::Spec::Example::MyApp->new({
          spec => $spec,
      });
      $run->run;
  
  =item usage
  
  Returns usage output for the specified subcommands:
  
      my $usage = $spec->usage(
          commands => ["subcommand1","subcommand2"],
      );
  
  =item generate_completion
  
  Generates shell completion script for the spec.
  
      my $completion = $spec->generate_completion(
          shell => "zsh",
      );
  
  =item make_getopt
  
  Returns options for Getopt::Long
  
      my @getopt = $spec->make_getopt($global_options, \%options, $option_specs);
  
  =item abstract, appspec, class, description, has_subcommands, markup, name, options, parameters, subcommands, title
  
  Accessors for the things defined in the spec (file)
  
  =back
  
  =head1 SEE ALSO
  
  L<App::AppSpec> - Utilities for App::Spec authors
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
  
APP_SPEC

$fatpacked{"App/Spec/Argument.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_ARGUMENT';
  # ABSTRACT: App::Spec objects representing command line options or parameters
  use strict;
  use warnings;
  package App::Spec::Argument;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  
  has name => ( is => 'ro' );
  has type => ( is => 'ro' );
  has multiple => ( is => 'ro' );
  has mapping => ( is => 'ro' );
  has required => ( is => 'ro' );
  has unique => ( is => 'ro' );
  has summary => ( is => 'ro' );
  has description => ( is => 'ro' );
  has default => ( is => 'ro' );
  has completion => ( is => 'ro' );
  has enum => ( is => 'ro' );
  has values => ( is => 'ro' );
  
  sub common {
      my ($class, %args) = @_;
      my %dsl;
      if (defined $args{spec}) {
          %dsl = $class->from_dsl(delete $args{spec});
      }
      my $description = $args{description};
      my $summary = $args{summary};
      $summary //= '';
      $description //= '';
      my $type = $args{type} // 'string';
      my %hash = (
          name => $args{name},
          summary => $summary,
          description => $description,
          type => $type,
          multiple => $args{multiple} ? 1 : 0,
          mapping => $args{mapping} ? 1 : 0,
          required => $args{required} ? 1 : 0,
          unique => $args{unique} ? 1 : 0,
          default => $args{default},
          completion => $args{completion},
          enum => $args{enum},
          values => $args{values},
          %dsl,
      );
      not defined $hash{ $_ } and delete $hash{ $_ } for keys %hash;
      return %hash;
  }
  
  my $name_re = qr{[\w-]+};
  
  sub from_dsl {
      my ($class, $dsl) = @_;
      my %hash;
  
      my $name;
      my $type = "flag";
      my $multiple;
      $dsl =~ s/^\s+//;
  
      if ($dsl =~ s/^\+//) {
          my $required = 1;
          $hash{required} = $required;
      }
  
      if ($dsl =~ s/^ ($name_re) //x) {
          $name = $1;
          $hash{name} = $name;
      }
      else {
          die "invalid spec: '$dsl'";
      }
  
      my @aliases;
      while ($dsl =~ s/^ \| (\w) //x) {
          push @aliases, $1;
      }
      if (@aliases) {
          $hash{aliases} = \@aliases;
      }
  
      my $getopt_type = '';
      if ($dsl =~ s/^=//) {
          # not a flag, default string
          $type = "string";
          if ($dsl =~ s/^([isf])//) {
              $getopt_type = $1;
              if ($getopt_type eq "i") {
                  $type = "integer";
              }
              elsif ($getopt_type eq "f") {
                  $type = "float";
              }
              elsif ($getopt_type eq "s") {
              }
              else {
                  die "Option $name: type $getopt_type not supported";
              }
          }
      }
  
      if ($type eq 'flag' and $dsl =~ s/^\+//) {
          # incremental flag
          $multiple = 1;
          $hash{multiple} = 1;
      }
      elsif ($type eq 'string' and $dsl =~ s/^\@//) {
          $hash{multiple} = 1;
      }
      elsif ($type eq 'string' and $dsl =~ s/^\%//) {
          $hash{multiple} = 1;
          $hash{mapping} = 1;
      }
  
      $dsl =~ s/^\s+//;
  
      while ($dsl =~ s/^\s*([=+])(\S+)//) {
          if ($1 eq '+') {
              $type = $2;
              if ($getopt_type and $type ne $getopt_type) {
                  die "Explicit type '$type' conflicts with getopt type '$getopt_type'";
              }
          }
          else {
              $hash{default} = $2;
          }
      }
  
      if ($dsl =~ s/^\s*--\s*(.*)//) {
          # TODO only summary should be supported
          $hash{summary} = $1;
      }
  
      if (length $dsl) {
          die "Invalid spec: trailing '$dsl'";
      }
  
      $hash{type} = $type;
      return %hash;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Argument - App::Spec objects representing command line options or parameters
  
  =head1 SYNOPSIS
  
  =head1 EXAMPLES
  
  Options can be defined in a verbose way via key value pairs, but you can also
  use a shorter syntax.
  
  The idea comes from Ingy's L<http://www.schematype.org/>.
  
  The first item of the string is the name of the option using a syntax
  very similar to the one from L<Getopt::Long>.
  
  Then you can optionally define a type, a default value and a summary.
  
  You can see a list of supported syntax in this example from C<t/data/12.dsl.yaml>:
  
  =for comment
  START INLINE t/data/12.dsl.yaml
  
      ---
      # version with short dsl syntax
      name: myapp
      appspec: { version: 0.001 }
      class: App::Spec::Example::MyApp
      title: My Very Cool App
      options:
        - spec: foo                 --Foo
        - spec: verbose|v+          --be verbose
        - spec: +req                --Some required flag
        - spec: number=i            --integer option
        - spec: number2|n= +integer --integer option
        - spec: fnumber=f           --float option
        - spec: fnumber2|f= +float  --float option
        - spec: date|d=s =today
        - spec: items=s@            --multi option
        - spec: set=s%              --multiple key=value pairs
      
      ---
      # version with verbose syntax
      name: myapp
      appspec: { version: 0.001 }
      class: App::Spec::Example::MyApp
      title: My Very Cool App
      options:
        - name: foo
          type: flag
          summary: Foo
        - name: verbose
          summary: be verbose
          type: flag
          multiple: true
          aliases: ["v"]
        - name: req
          summary: Some required flag
          required: true
          type: flag
        - name: number
          summary: integer option
          type: integer
        - name: number2
          summary: integer option
          type: integer
          aliases: ["n"]
        - name: fnumber
          summary: float option
          type: float
        - name: fnumber2
          summary: float option
          type: float
          aliases: ["f"]
        - name: date
          type: string
          default: today
          aliases: ["d"]
        - name: items
          type: string
          multiple: true
          summary: multi option
        - name: set
          type: string
          multiple: true
          mapping: true
          summary: multiple key=value pairs
      
  
  
  =for comment
  STOP INLINE
  
  =head1 METHODS
  
  =over 4
  
  =item common
  
  Builds a hash with the given hashref and fills in some defaults.
  
      my %hash = $class->common($args);
  
  =item from_dsl
  
  Builds a hash from the dsl string
  
      %dsl = $class->from_dsl("verbose|v+ --Be verbose");
  
  
  =item name, type, multiple, required, unique, summary, description, default, completion, enum, values, mapping
  
  Attributes which represent the ones from the spec.
  
  =back
  
  =cut
APP_SPEC_ARGUMENT

$fatpacked{"App/Spec/Completion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_COMPLETION';
  # ABSTRACT: Shell Completion generator
  use strict;
  use warnings;
  package App::Spec::Completion;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  
  has spec => ( is => 'ro' );
  
  1;
  
  __DATA__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Completion - Shell Completion generator
  
  See L<App::Spec::Completion::Bash> and L<App::Spec::Completion::Zsh>
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item spec
  
  Contains the L<App::Spec> object
  
  =back
  
  =cut
APP_SPEC_COMPLETION

$fatpacked{"App/Spec/Completion/Bash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_COMPLETION_BASH';
  # ABSTRACT: Shell Completion generator for bash
  use strict;
  use warnings;
  package App::Spec::Completion::Bash;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  extends 'App::Spec::Completion';
  
  sub generate_completion {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
  
      my $appspec_version = App::Spec->VERSION;
  
      my $functions = [];
      my $completion_outer = $self->completion_commands(
          commands => $spec->subcommands,
          options => $spec->options,
          parameters => $spec->parameters,
          level => 1,
          functions => $functions,
      );
  
      my $global_options = $spec->options;
      my ($flags_string, $options_string) = $self->flags_options($global_options);
      my $body = <<"EOM";
  #!bash
  
  # Generated with perl module App::Spec v$appspec_version
  
  _$appname() \{
  
      COMPREPLY=()
      local program=$appname
      local cur prev words cword
      _init_completion -n : || return
      declare -a FLAGS
      declare -a OPTIONS
      declare -a MYWORDS
  
      local INDEX=`expr \$cword - 1`
      MYWORDS=("\$\{words[@]:1:\$cword\}")
  
      FLAGS=($flags_string)
      OPTIONS=($options_string)
      __${appname}_handle_options_flags
  
  $completion_outer
  \}
  
  _${appname}_compreply() \{
      local prefix=""
      cur="\$(printf '%q' "\$cur")"
      IFS=\$'\\n' COMPREPLY=(\$(compgen -P "\$prefix" -W "\$*" -- "\$cur"))
      __ltrim_colon_completions "\$prefix\$cur"
  
      # http://stackoverflow.com/questions/7267185/bash-autocompletion-add-description-for-possible-completions
      if [[ \$\{#COMPREPLY[*]\} -eq 1 ]]; then # Only one completion
          COMPREPLY=( "\$\{COMPREPLY[0]%% -- *\}" ) # Remove ' -- ' and everything after
          COMPREPLY=( "\$\{COMPREPLY[0]%%+( )\}" ) # Remove trailing spaces
      fi
  \}
  
  @{[ join '', @$functions ]}
  EOM
      my $static_functions = $self->_functions;
  
      $body .= <<"EOM";
  $static_functions
  complete -o default -F _$appname $appname
  EOM
  
      return $body;
  }
  
  sub flags_options {
      my ($self, $options) = @_;
      my @flags;
      my @opt;
      for my $o (@$options) {
          my $name = $o->name;
          my $aliases = $o->aliases;
          my $summary = $o->summary;
          my @names = ($name, @$aliases);
          ($summary, @names) = $self->escape_singlequote( $summary, @names );
          @names = map {
              length $_ > 1 ? "--$_" : "-$_"
          } @names;
  
          my @items = map {
              ("'$_'", "'$summary'")
          } @names;
  
          if ($o->type eq 'flag') {
              push @flags, @items;
          }
          else {
              push @opt, @items;
          }
      }
      return ("@flags", "@opt");
  }
  
  sub escape_singlequote {
      my ($self, @strings) = @_;
      my @result;
      for my $string (@strings) {
          no warnings 'uninitialized';
          $string =~ s/[']/'"\\\\'"'/g;
          push @result, $string;
      }
      return wantarray ? @result : $result[0];
  }
  
  sub completion_commands {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $functions = $args{functions};
      my $previous = $args{previous} || [];
      my $commands = $args{commands};
      my $options = $args{options};
      my $parameters = $args{parameters};
      my $level = $args{level};
      my $indent = "    " x $level;
  
      my @commands = map {
          my $name = $_;
          my $summary = $commands->{ $_ }->summary;
          for ($name, $summary) {
              no warnings 'uninitialized';
              s/['`]/'"'"'/g;
              s/\$/\\\$/g;
          }
          "'$name'" . (length $summary ? q{$'\t'} . "'$summary'" : '')
      } sort grep { not m/^_/ } keys %$commands;
      my $cmds = join q{$'\\n'}, @commands;
  
      my $index = $level - 1;
      my $subc = '';
      if (keys %$commands) {
          $subc = <<"EOM";
  $indent# subcmds
  ${indent}case \$\{MYWORDS\[$index\]\} in
  EOM
      }
  
      for my $name (sort keys %$commands) {
          my $cmd_spec = $commands->{ $name };
          my ($flags_string, $options_string) = $self->flags_options($cmd_spec->options);
          $subc .= <<"EOM";
  ${indent}  $name)
  EOM
          $subc .= $indent . "    FLAGS+=($flags_string)\n" if $flags_string;
          $subc .= $indent . "    OPTIONS+=($options_string)\n" if $options_string;
          $subc .= <<"EOM";
  ${indent}    __${appname}_handle_options_flags
  EOM
          my $subcommands = $cmd_spec->subcommands;
          my $parameters = $cmd_spec->parameters;
          my $cmd_options = $cmd_spec->options;
          if (keys %$subcommands or @$cmd_options or @$parameters) {
              my $comp = $self->completion_commands(
                  commands => $subcommands,
                  options => [ @$options, @$cmd_options ],
                  parameters => $parameters,
                  level => $level + 1,
                  previous => [@$previous, $name],
                  functions => $functions,
              );
              $subc .= $comp;
          }
          else {
              $subc .= $indent . "    __comp_current_options true || return # no subcmds, no params/opts\n";
          }
          $subc .= <<"EOM";
  ${indent}  ;;
  EOM
      }
  
      my $option_comp;
      my $param_comp = '';
      my $subc_comp = '';
      if (@$options) {
          ($option_comp) = $self->completion_options(
              options => $options,
              level => $level,
              functions => $args{functions},
              previous => $previous,
          );
      }
      if (@$parameters) {
          $param_comp = $self->completion_parameters(
              parameters => $parameters,
              level => $level,
              previous => $previous,
              functions => $functions,
          );
          $param_comp = <<"EOM";
  $param_comp
  EOM
      }
  
      if (keys %$commands) {
          $subc .= <<"EOM";
  ${indent}esac
  EOM
          $subc_comp = <<"EOM";
  ${indent}case \$INDEX in
  
  ${indent}$index)
  ${indent}    __comp_current_options || return
  ${indent}    __${appname}_dynamic_comp 'commands' $cmds
  
  ${indent};;
  ${indent}*)
  $subc
  ${indent};;
  ${indent}esac
  EOM
          return $subc_comp;
      }
  
      my $completion = <<"EOM";
  ${indent}case \$\{MYWORDS[\$INDEX-1]\} in
  $option_comp
  ${indent}esac
  ${indent}case \$INDEX in
  $param_comp
  ${indent}*)
  ${indent}    __comp_current_options || return
  ${indent};;
  ${indent}esac
  EOM
      return $completion;
  }
  
  sub completion_parameters {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $parameters = $args{parameters};
      my $level = $args{level};
      my $indent = "    " x $level;
  
      my $comp = '';
  
      for my $i (0 .. $#$parameters) {
          my $param = $parameters->[ $i ];
          my $name = $param->name;
          my $num = $level + $i - 1;
          $comp .= $indent . "  $num)\n";
          $comp .= $indent . "      __comp_current_options || return\n";
          $comp .= $self->completion_parameter(
              parameter => $param,
              level => $level + 1,
              functions => $args{functions},
              previous => $args{previous},
          );
          $comp .= $indent . "  ;;\n";
      }
  
      return $comp;
  }
  
  sub completion_options  {
      my ($self, %args) = @_;
  
      my $appname = $self->spec->name;
      my $options = $args{options};
      my $level = $args{level};
      my $indent = "    " x $level;
  
      my @comp_options;
      my @comp_values;
      my $comp_value = '';
      my $maxlength = 0;
      for my $opt (@$options) {
          my $name = $opt->name;
          my $aliases = $opt->aliases;
          my @names = ($name, @$aliases);
          for my $n (@names) {
              my $length = length $n;
              $length = $length > 1 ? $length+2 : $length+1;
              $maxlength = $length if $length > $maxlength;
          }
      }
      for my $i (0 .. $#$options) {
          my $opt = $options->[ $i ];
          my $name = $opt->name;
          my $type = $opt->type;
          next if $type eq "flag";
          my $enum = $opt->enum;
          my $summary = $opt->summary;
          $summary =~ s/['`]/'"'"'/g;
          $summary =~ s/\$/\\\$/g;
          my $aliases = $opt->aliases;
          my @names = ($name, @$aliases);
          my @option_strings;
          for my $n (@names) {
              my $dash = length $n > 1 ? "--" : "-";
              my $option_string = "$dash$n";
              push @option_strings, $option_string;
              my $length = length $option_string;
              $option_string .= " " x ($maxlength - $length);
              my $string = length $summary
                  ? qq{'$option_string -- $summary'}
                  : qq{'$option_string'};
              push @comp_options, $string;
          }
  
          $comp_value .= <<"EOM";
  ${indent}  @{[ join '|', @option_strings ]})
  EOM
          if ($enum) {
              my @list = @$enum;
              for (@list) {
                  s/['`]/'"'"'/g;
                  s/\\/\\\\/g;
                  s/ /\\\\\\\\ /g;
                  s/\$/\\\$/g;
                  $_ = qq{"$_"};
              }
              $comp_value .= <<"EOM";
  ${indent}    _${appname}_compreply @list
  ${indent}    return
  EOM
          }
          elsif ($type =~ m/^file(name)?\z/) {
              $comp_value .= <<"EOM";
  ${indent}    compopt -o filenames
  ${indent}    return
  EOM
          }
          elsif ($type =~ m/^dir(name)?\z/) {
              $comp_value .= <<"EOM";
  ${indent}    compopt -o dirnames
  ${indent}    return
  EOM
          }
          elsif ($opt->completion) {
              my $function_name = $self->dynamic_completion(
                  option => $opt,
                  level => $level,
                  previous => $args{previous},
                  functions => $args{functions},
              );
              $comp_value .= <<"EOM";
  ${indent}    $function_name
  EOM
          }
          $comp_value .= $indent . "  ;;\n";
      }
  
      return ($comp_value);
  }
  
  sub dynamic_completion {
      my ($self, %args) = @_;
      my $functions = $args{functions};
      my $previous = $args{previous} || [];
      my $p = $args{option};
      my $level = $args{level};
      my $indent = '        ' x $level;
      my $name = $p->name;
      my $shell_name = $name;
      $name =~ tr/^A-Za-z0-9_:-/_/c;
      $shell_name =~ tr/^A-Za-z0-9_/_/c;
  
      my $def = $p->completion;
      my ($op, $command, $command_string);
      if (not ref $def and $def == 1) {
          my $possible_values = $p->values or die "Error for '$name': completion: 1 but 'values' not defined";
          $op = $possible_values->{op} or die "Error for '$name': 'values' needs an 'op'";
      }
      elsif (ref $def) {
          $op = $def->{op};
          $command = $def->{command};
          $command_string = $def->{command_string};
      }
      else {
          die "Error for '$name': invalid value for 'completion'";
      }
  
      my $appname = $self->spec->name;
      my $function_name = "_${appname}_"
          . join ("_", @$previous)
          . "_" . ($p->isa("App::Spec::Option") ? "option" : "param")
          . "_" . $shell_name . "_completion";
  
      my $function;
      if ($op) {
          $function = <<"EOM";
  $function_name() \{
      local __dynamic_completion
      __dynamic_completion=\$(PERL5_APPSPECRUN_SHELL=bash PERL5_APPSPECRUN_COMPLETION_PARAMETER='$name' \${words[@]})
      __${appname}_dynamic_comp '$name' "\$__dynamic_completion"
  \}
  EOM
      }
      elsif ($command or $command_string) {
  
          my $string = '';
          if ($command) {
              my @args;
  
              for my $arg (@$command) {
                  unless (ref $arg) {
                      push @args, "'$arg'";
                      next;
                  }
                  if (my $replace = $arg->{replace}) {
                      if (ref $replace eq 'ARRAY') {
                          my @repl = @$replace;
                          if ($replace->[0] eq 'SHELL_WORDS') {
                              my $num = $replace->[1];
                              my $index = "\$cword";
                              if ($num ne 'CURRENT') {
                                  if ($num =~ m/^-/) {
                                      $index .= $num;
                                  }
                                  else {
                                      $index = $num - 1;
                                  }
                              }
                              my $string = qq{"\$\{words\[$index\]\}"};
                              push @args, $string;
                          }
                      }
                      else {
                          if ($replace eq "SELF") {
                              push @args, "\$program";
                          }
                      }
                  }
              }
              $string = "@args";
          }
          elsif (defined $command_string) {
              $string = $command_string;
          }
          my $varname = "__${name}_completion";
  
          chomp $string;
          $function = <<"EOM";
  $function_name() \{
      local CURRENT_WORD="\${words\[\$cword\]\}"
      local param_$shell_name="\$($string)"
      _${appname}_compreply "\$param_$shell_name"
  \}
  EOM
      }
      push @$functions, $function;
      return $function_name;
  }
  
  # sub list_to_alternative {
  #     my ($self, %args) = @_;
  #     my $list = $args{list};
  #     my $maxlength = 0;
  #     for (@$list) {
  #         if (length($_) > $maxlength) {
  #             $maxlength = length $_;
  #         }
  #     }
  #     my @alt = map {
  #         my ($alt_name, $summary);
  #         if (ref $_ eq 'ARRAY') {
  #             ($alt_name, $summary) = @$_;
  #         }
  #         else {
  #             ($alt_name, $summary) = ($_, '');
  #         }
  #         $summary //= '';
  #         $alt_name =~ s/:/\\\\:/g;
  #         $summary =~ s/['`]/'"'"'/g;
  #         $summary =~ s/\$/\\\$/g;
  #         if (length $summary) {
  #             $alt_name .= " " x ($maxlength - length($alt_name));
  #         }
  #         $alt_name;
  #     } @$list;
  #     return join '', map { "$_\n" } @alt;
  # }
  
  sub completion_parameter {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $param = $args{parameter};
      my $name = $param->name;
      my $level = $args{level};
      my $indent = "    " x $level;
  
      my $comp = '';
  
      my $type = $param->type;
      my $enum = $param->enum;
      if ($enum) {
          my @list = @$enum;
          for (@list) {
              s/['`]/'"'"'/g;
              s/\\/\\\\/g;
              s/ /\\\\ /g;
              s/\$/\\\$/g;
              $_ = qq{"$_"};
          }
          $comp = <<"EOM";
  ${indent}    _${appname}_compreply @list
  EOM
      }
      elsif ($type =~ m/^file(name)?\z/) {
          $comp = <<"EOM";
  ${indent}    compopt -o filenames
  EOM
      }
      elsif ($type =~ m/^dir(name)?\z/) {
          $comp = <<"EOM";
  ${indent}    compopt -o dirnames
  EOM
      }
      elsif ($param->completion) {
          my $function_name = $self->dynamic_completion(
              option => $param,
              level => $level,
              previous => $args{previous},
              functions => $args{functions},
          );
          $comp .= <<"EOM";
  ${indent}    $function_name
  EOM
      }
      return $comp;
  }
  
  sub _functions {
      my ($self) = @_;
      my $string = <<'EOM';
  __APPNAME_dynamic_comp() {
      local argname="$1"
      local arg="$2"
      local name desc cols desclength formatted
      local comp=()
      local max=0
  
      while read -r line; do
          name="$line"
          desc="$line"
          name="${name%$'\t'*}"
          if [[ "${#name}" -gt "$max" ]]; then
              max="${#name}"
          fi
      done <<< "$arg"
  
      while read -r line; do
          name="$line"
          desc="$line"
          name="${name%$'\t'*}"
          desc="${desc/*$'\t'}"
          if [[ -n "$desc" && "$desc" != "$name" ]]; then
              # TODO portable?
              cols=`tput cols`
              [[ -z $cols ]] && cols=80
              desclength=`expr $cols - 4 - $max`
              formatted=`printf "%-*s -- %-*s" "$max" "$name" "$desclength" "$desc"`
              comp+=("$formatted")
          else
              comp+=("'$name'")
          fi
      done <<< "$arg"
      _APPNAME_compreply ${comp[@]}
  }
  
  function __APPNAME_handle_options() {
      local i j
      declare -a copy
      local last="${MYWORDS[$INDEX]}"
      local max=`expr ${#MYWORDS[@]} - 1`
      for ((i=0; i<$max; i++))
      do
          local word="${MYWORDS[$i]}"
          local found=
          for ((j=0; j<${#OPTIONS[@]}; j+=2))
          do
              local option="${OPTIONS[$j]}"
              if [[ "$word" == "$option" ]]; then
                  found=1
                  i=`expr $i + 1`
                  break
              fi
          done
          if [[ -n $found && $i -lt $max ]]; then
              INDEX=`expr $INDEX - 2`
          else
              copy+=("$word")
          fi
      done
      MYWORDS=("${copy[@]}" "$last")
  }
  
  function __APPNAME_handle_flags() {
      local i j
      declare -a copy
      local last="${MYWORDS[$INDEX]}"
      local max=`expr ${#MYWORDS[@]} - 1`
      for ((i=0; i<$max; i++))
      do
          local word="${MYWORDS[$i]}"
          local found=
          for ((j=0; j<${#FLAGS[@]}; j+=2))
          do
              local flag="${FLAGS[$j]}"
              if [[ "$word" == "$flag" ]]; then
                  found=1
                  break
              fi
          done
          if [[ -n $found ]]; then
              INDEX=`expr $INDEX - 1`
          else
              copy+=("$word")
          fi
      done
      MYWORDS=("${copy[@]}" "$last")
  }
  
  __APPNAME_handle_options_flags() {
      __APPNAME_handle_options
      __APPNAME_handle_flags
  }
  
  __comp_current_options() {
      local always="$1"
      if [[ -n $always || ${MYWORDS[$INDEX]} =~ ^- ]]; then
  
        local options_spec=''
        local j=
  
        for ((j=0; j<${#FLAGS[@]}; j+=2))
        do
            local name="${FLAGS[$j]}"
            local desc="${FLAGS[$j+1]}"
            options_spec+="$name"$'\t'"$desc"$'\n'
        done
  
        for ((j=0; j<${#OPTIONS[@]}; j+=2))
        do
            local name="${OPTIONS[$j]}"
            local desc="${OPTIONS[$j+1]}"
            options_spec+="$name"$'\t'"$desc"$'\n'
        done
        __APPNAME_dynamic_comp 'options' "$options_spec"
  
        return 1
      else
        return 0
      fi
  }
  
  EOM
      my $appname = $self->spec->name;
      $string =~ s/APPNAME/$appname/g;
      return $string;
  }
  
  1;
  
  __DATA__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Completion::Bash - Shell Completion generator for bash
  
  See also L<App::Spec::Completion> and L<App::Spec::Completion::Zsh>
  
  =head1 SYNOPSIS
  
  my $completer = App::Spec::Completion::Bash->new( spec => $appspec );
  
  =head1 METHODS
  
  =over 4
  
  =item generate_completion
  
      my $completion = $completer->generate_completion;
  
  =item completion_commands
  
  =item completion_options
  
  =item completion_parameter
  
  =item completion_parameters
  
  =item dynamic_completion
  
  =item escape_singlequote
  
      (@names) = $self->escape_singlequote( @names );
  
  =item flags_options
  
      my ($flags_string, $options_string) = $completer->flags_options($global_options);
  
  =back
  
  =cut
APP_SPEC_COMPLETION_BASH

$fatpacked{"App/Spec/Completion/Zsh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_COMPLETION_ZSH';
  # ABSTRACT: Shell Completion generator for zsh
  use strict;
  use warnings;
  package App::Spec::Completion::Zsh;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  extends 'App::Spec::Completion';
  
  sub generate_completion {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $functions = [];
      my $appspec_version = App::Spec->VERSION;
      my $completion_outer = $self->completion_commands(
          commands => $spec->subcommands,
          options => $spec->options,
          parameters => $spec->parameters,
          level => 1,
          functions => $functions,
      );
  
  
  my $body = <<"EOM";
  #compdef $appname
  
  # Generated with perl module App::Spec v$appspec_version
  
  _$appname() {
      local program=$appname
      typeset -A opt_args
      local curcontext="\$curcontext" state line context
  
  $completion_outer
  }
  
  @{[ join '', @$functions ]}
  __${appname}_dynamic_comp() {
  EOM
      $body .= <<'EOM';
      local argname="$1"
      local arg="$2"
      local comp="arg:$argname:(("
      local line
      while read -r line; do
          local name="$line"
          local desc="$line"
          name="${name%$'\t'*}"
          desc="${desc/*$'\t'}"
          comp="$comp$name"
          if [[ -n "$desc" && "$name" != "$desc" ]]; then
              comp="$comp\\:"'"'"$desc"'"'
          fi
          comp="$comp "
      done <<< "$arg"
  
      comp="$comp))"
      _alternative "$comp"
  }
  EOM
  
      return $body;
  }
  
  sub completion_commands {
      my ($self, %args) = @_;
      my $functions = $args{functions};
      my $spec = $self->spec;
      my $commands = $args{commands};
      my $options = $args{options};
      my $level = $args{level};
      my $previous = $args{previous} || [];
  
      my $indent = '        ' x $level;
      my $indent2 = '        ' x $level . '    ';
      my $state = $level > 1 ? "-C" : "";
      my $arguments = $indent . "_arguments -s $state \\\n";
      my $cmd_count = $level;
      unless (keys %$commands) {
          $cmd_count--;
      }
      for my $i (1 .. $cmd_count) {
          $arguments .= $indent2 . "'$i: :->cmd$i' \\\n";
      }
  
      my ($param_args, $param_case) = $self->parameters(
          parameters => $args{parameters},
          level => $level,
          count => $level,
          functions => $functions,
          previous => $previous,
      );
  
      if ($param_args) {
          $arguments .= "$param_args";
      }
      if (keys %$commands) {
          $arguments .= $indent2 . "'*: :->args' \\\n";
      }
  
      if (@$options and not keys %$commands) {
          my ($opt) = $self->options(
              options => $options,
              level => $level,
              functions => $functions,
              previous => $previous,
          );
          $arguments .= "$opt \\\n";
      }
      $arguments .= $indent2 . "&& ret=0\n";
  
      my $cmds = $self->commands_alternative(
          commands => $commands,
          level => $level + 1,
      );
  
      my $subcmds = '';
      if (keys %$commands) {
          $subcmds .= $indent2 . "case \$line[$level] in\n";
          for my $key (sort keys %$commands) {
              my $cmd_spec = $commands->{ $key };
              my $name = $cmd_spec->name;
              $subcmds .= $indent2 . "$name)\n";
              my $sc = $self->completion_commands(
                  commands => $cmd_spec->subcommands || {},
                  options => [ @$options, @{ $cmd_spec->options } ],
                  parameters => $cmd_spec->parameters,
                  level => $level + 1,
                  previous => [@$previous, $name],
                  functions => $functions,
              );
              $subcmds .= $sc;
              $subcmds .= $indent2 . ";;\n";
          }
          $subcmds .= $indent2 . "esac\n";
      }
  
      my $body = <<"EOM";
  
  $indent# ---- Command: @$previous
  $arguments
  $param_case
  EOM
      my $cmd_state = '';
      if ($cmds) {
          $cmd_state = <<"EOM";
  ${indent}cmd$level)
  ${indent}    $cmds
  ${indent};;
  EOM
      }
  
      my $subcmd_state = '';
      if (keys %$commands) {
          $subcmd_state = <<"EOM";
  ${indent}args)
  $subcmds
  ${indent};;
  EOM
      }
  
      if ($cmd_state or $subcmd_state) {
          $body .= <<"EOM";
  ${indent}case \$state in
  EOM
  
          $body .= <<"EOM";
  $cmd_state
  $subcmd_state
  ${indent}esac
  EOM
      }
  
      return $body;
  }
  
  sub parameters {
      my ($self, %args) = @_;
      my $functions = $args{functions};
      my $spec = $self->spec;
      my $parameters = $args{parameters} || [];
      return ('','') unless @$parameters;
      my $level = $args{level};
      my $count = $args{count};
      my $indent = '        ' x $level;
  
      my $arguments = '';
      my $case = $indent . "case \$state in\n";
      for my $p (@$parameters) {
          my $name = $p->name;
          my $num = $count;
          if ($p->multiple) {
              $num = "*";
          }
          $arguments .= $indent . "    '$num: :->$name' \\\n";
          $count++;
  
          my $completion = '';
          if (my $enum = $p->enum) {
              my @list = map { "'$_'" } @$enum;
              $completion = $indent . "        compadd -X '$name:' @list";
          }
          elsif ($p->type =~ m/^file(name)?\z/) {
              $completion = '_files';
          }
          elsif ($p->type =~ m/^dir(name)?\z/) {
              $completion = '_path_files -/';
          }
          elsif ($p->type eq 'user') {
              $completion = '_users';
          }
          elsif ($p->type eq 'host') {
              $completion = '_hosts';
          }
          elsif ($p->completion) {
              $completion = $self->dynamic_completion(
                  option => $p,
                  level => $level,
                  functions => $functions,
                  previous => $args{previous},
              );
          }
          $case .= <<"EOM";
  ${indent}$name)
  $completion
  ${indent};;
  EOM
      }
      $case .= $indent . "esac\n";
  
      return ($arguments, $case);
  }
  
  sub dynamic_completion {
      my ($self, %args) = @_;
      my $functions = $args{functions};
      my $previous = $args{previous};
      my $p = $args{option};
      my $level = $args{level};
      my $indent = '        ' x $level;
      my $name = $p->name;
      my $shell_name = $name;
      $name =~ tr/^A-Za-z0-9_:-/_/c;
      $shell_name =~ tr/^A-Za-z0-9_/_/c;
  
      my $def = $p->completion;
      my ($op, $command, $command_string);
      if (not ref $def and $def == 1) {
          my $possible_values = $p->values or die "Error for '$name': completion: 1 but 'values' not defined";
          $op = $possible_values->{op} or die "Error for '$name': 'values' needs an 'op'";
      }
      elsif (ref $def) {
          $op = $def->{op};
          $command = $def->{command};
          $command_string = $def->{command_string};
      }
      else {
          die "Error for '$name': invalid value for 'completion'";
      }
  
      my $appname = $self->spec->name;
      my $function_name = "_${appname}_"
          . join ("_", @$previous)
          . "_" . ($p->isa("App::Spec::Option") ? "option" : "param")
          . "_" . $shell_name . "_completion";
  
      my $function;
      if ($op) {
          $function = <<"EOM";
  $function_name() \{
      local __dynamic_completion
      __dynamic_completion=\$(PERL5_APPSPECRUN_SHELL=zsh PERL5_APPSPECRUN_COMPLETION_PARAMETER='$name' "\${words[@]}")
      __${appname}_dynamic_comp '$name' \$__dynamic_completion
  \}
  EOM
      }
      elsif ($command or $command_string) {
          my $string = '';
  
          if ($command) {
              my @args;
              for my $arg (@$command) {
                  unless (ref $arg) {
                      push @args, "'$arg'";
                      next;
                  }
                  if (my $replace = $arg->{replace}) {
                      if (ref $replace eq 'ARRAY') {
                          my @repl = @$replace;
                          if ($replace->[0] eq 'SHELL_WORDS') {
                              my $num = $replace->[1];
                              my $index = "\$CURRENT";
                              if ($num ne 'CURRENT') {
                                  if ($num =~ m/^-/) {
                                      $index .= $num;
                                  }
                                  else {
                                      $index = $num;
                                  }
                              }
                              my $string = qq{"\$words\[$index\]"};
                              push @args, $string;
                          }
                      }
                      else {
                          if ($replace eq "SELF") {
                              push @args, "\$program";
                          }
                      }
                  }
              }
              $string = "@args";
          }
          elsif (defined $command_string) {
              $string = $command_string;
          }
          my $varname = "__${name}_completion";
  
          $function = <<"EOM";
  $function_name() \{
      local __dynamic_completion
      local CURRENT_WORD="\$words\[CURRENT\]"
      IFS=\$'\\n' __dynamic_completion=( \$( $string ) )
      compadd -X "$shell_name:" \$__dynamic_completion
  \}
  EOM
  }
      push @$functions, $function;
      return $function_name;
  }
  
  sub commands_alternative {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $commands = $args{commands};
      return '' unless keys %$commands;
      my $level = $args{level};
      my @subcommands;
      for my $key (sort grep { not m/^_/ } keys %$commands) {
          my $cmd = $commands->{ $key };
          my $name = $cmd->name;
          my $summary = $cmd->summary;
          push @subcommands, [$name, $summary];
      }
      my $string = $self->list_to_alternative(
          name => "cmd$level",
          list => \@subcommands,
      );
      return "_alternative '$string'";
  }
  
  sub list_to_alternative {
      my ($self, %args) = @_;
      my $list = $args{list};
      my $name = $args{name};
      my @alt = map {
          my ($alt_name, $summary);
          if (ref $_ eq 'ARRAY') {
              ($alt_name, $summary) = @$_;
              $summary //= '';
          }
          else {
              ($alt_name, $summary) = ($_, '');
          }
          $alt_name =~ s/:/\\\\:/g;
          $summary =~ s/"/\\"/g;
          $summary =~ s/['`]/'"'"'/g;
          $summary =~ s/\$/\\\$/g;
          length $summary ? qq{$alt_name\\:"$summary"} : $alt_name
      } @$list;
      my $string = qq{args:$name:((@alt))};
  }
  
  sub options {
      my ($self, %args) = @_;
      my $functions = $args{functions};
      my $spec = $self->spec;
      my $options = $args{options};
      my $level = $args{level};
      my $indent = '        ' x $level;
      my @options;
      for my $opt (@$options) {
          my $name = $opt->name;
          my $summary = $opt->summary;
          my $type = $opt->type;
          my $enum = $opt->enum;
          my $aliases = $opt->aliases;
          my $values = '';
          if ($opt->completion) {
              my @names = map {
                  length > 1 ? "--$_" : "-$_"
              } ($name, @$aliases);
              my $comp = $indent . join ('|', @names) . ")\n";
              my $function_name = $self->dynamic_completion(
                  option => $opt,
                  level => $level,
                  functions => $functions,
                  previous => $args{previous},
              );
              $values = ":$name:$function_name";
              $comp .= $indent . ";;\n";
          }
          elsif ($enum) {
              my @list = map {
                  my $item = $_;
                  $item =~ s/:/\\:/g;
                  qq{"$item"};
              } @$enum;
              $values = ":$name:(@list)";
          }
          elsif ($type =~ m/^file(name)?\z/) {
              $values = ":$name:_files";
          }
          elsif ($type =~ m/^dir(name)?\z/) {
              $values = ":$name:_path_files -/";
          }
          elsif (not ref $type and $type ne "flag") {
              $values = ":$name";
          }
          $summary =~ s/['`]/'"'"'/g;
          $summary =~ s/\$/\\\$/g;
  
          my $multiple = $opt->multiple ? "*" : "";
  #        '(-c --count)'{-c,--count}'[Number of list items to show]:c' \
  #        '(-a --all)'{-a,--all}'[Show all list items]' \
          my @names = map {
              length > 1 ? "--$_" : "-$_"
          } ($name, @$aliases);
          for my $name (@names) {
              my $str = "'$multiple$name\[$summary\]$values'";
              push @options, $indent . "    $str";
          }
      }
      my $string = join " \\\n", @options;
      return $string;
  }
  
  
  1;
  
  __DATA__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Completion::Zsh - Shell Completion generator for zsh
  
  See also L<App::Spec::Completion> and L<App::Spec::Completion::Zsh>
  
  =head1 SYNOPSIS
  
  my $completer = App::Spec::Completion::Zsh->new( spec => $appspec );
  
  =head1 METHODS
  
  =over 4
  
  =item generate_completion
  
      my $completion = $completer->generate_completion;
  
  =item commands_alternative
  
  =item completion_commands
  
  =item dynamic_completion
  
  =item list_to_alternative
  
  =item options
  
  =item parameters
  
  =back
  
  =cut
APP_SPEC_COMPLETION_ZSH

$fatpacked{"App/Spec/Option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_OPTION';
  # ABSTRACT: App::Spec objects representing command line option specs
  use strict;
  use warnings;
  package App::Spec::Option;
  
  our $VERSION = '0.013'; # VERSION
  
  use base 'App::Spec::Argument';
  use Moo;
  
  has aliases => ( is => 'ro' );
  
  sub build {
      my ($class, %args) = @_;
      my %hash = $class->common(%args);
      my $self = $class->new({
          aliases => $args{aliases} || [],
          %hash,
      });
      return $self;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Option - App::Spec objects representing command line option specs
  
  =head1 SYNOPSIS
  
  This class inherits from L<App::Spec::Argument>
  
  =head1 METHODS
  
  =over 4
  
  =item build
  
      my $option = App::Spec::Option->build(
          name => 'verbose',
          summary => 'lala',
          aliases => ['v'],
      );
  
  =item aliases
  
  Attribute which represents the one from the spec.
  
  =back
  
  =cut
APP_SPEC_OPTION

$fatpacked{"App/Spec/Parameter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_PARAMETER';
  # ABSTRACT: App::Spec objects representing command line parameters
  use strict;
  use warnings;
  package App::Spec::Parameter;
  
  our $VERSION = '0.013'; # VERSION
  
  use base 'App::Spec::Argument';
  use Moo;
  
  sub build {
      my ($class, %args) = @_;
      my %hash = $class->common(%args);
      my $self = $class->new({
          %hash,
      });
      return $self;
  }
  
  sub to_usage_header {
      my ($self) = @_;
      my $name = $self->name;
      my $usage = '';
      if ($self->multiple and $self->required) {
          $usage = "<$name>+";
      }
      elsif ($self->multiple) {
          $usage = "[<$name>+]";
      }
      elsif ($self->required) {
          $usage = "<$name>";
      }
      else {
          $usage = "[<$name>]";
      }
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Parameter - App::Spec objects representing command line parameters
  
  =head1 SYNOPSIS
  
  This class inherits from L<App::Spec::Argument>
  
  =head1 METHODS
  
  =over 4
  
  =item build
  
      my $param = App::Spec::Parameter->build(
          name => 'verbose',
          summary => 'lala',
      );
  
  =item to_usage_header
  
      my $param_usage_header = $param->to_usage_header;
      # results
      # if multiple and required
      # <$name>+
      # if multiple
      # [<$name>+]
      # if required
      # <$name>
      # else
      # [<$name>}
  
  =back
  
  =cut
APP_SPEC_PARAMETER

$fatpacked{"App/Spec/Plugin/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_PLUGIN_FORMAT';
  # ABSTRACT: App::Spec Plugin for formatting data structures
  use strict;
  use warnings;
  package App::Spec::Plugin::Format;
  our $VERSION = '0.013'; # VERSION
  
  use YAML::PP;
  use Ref::Util qw/ is_arrayref /;
  use Encode;
  
  use Moo;
  with 'App::Spec::Role::Plugin::GlobalOptions';
  
  my $yaml;
  my $options;
  sub _read_data {
      unless ($yaml) {
          $yaml = do { local $/; <DATA> };
          ($options) = YAML::PP::Load($yaml);
      }
  }
  
  
  sub install_options {
      my ($class, %args) = @_;
      _read_data();
      return $options;
  }
  
  sub init_run {
      my ($self, $run) = @_;
      $run->subscribe(
          print_output => {
              plugin => $self,
              method => "print_output",
          },
      );
  }
  
  sub print_output {
      my ($self, %args) = @_;
      my $run = $args{run};
      my $opt = $run->options;
      my $format = $opt->{format} || '';
  
      my $res = $run->response;
      my $outputs = $res->outputs;
      for my $out (@$outputs) {
          next unless $out->type eq 'data';
          my $content = $out->content;
          if ($format eq 'YAML') {
              $content = encode_utf8 YAML::PP::Dump($content);
          }
          elsif ($format eq 'JSON') {
              require JSON::XS;
              my $coder = JSON::XS->new->ascii->pretty->allow_nonref;
              $content = encode_utf8 $coder->encode($content) . "\n";
          }
          elsif ($format eq 'Table' and is_arrayref($content)) {
              require Text::Table;
              my $header = shift @$content;
              my $tb = Text::Table->new( @$header );
              $tb->load(@$content);
              $content = encode_utf8 "$tb";
          }
          elsif ($format eq 'Data::Dump') {
              require Data::Dump;
              $content = Data::Dump::dump($content) . "\n";
          }
          else {
              $content = Data::Dumper->Dump([$content], ['output']);
          }
          $out->content( $content );
          $out->type( "plain" );
      }
  
  }
  
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Plugin::Format - App::Spec Plugin for formatting data structures
  
  =head1 DESCRIPTION
  
  
  =head1 METHODS
  
  =over 4
  
  =item install_options
  
  This method is required by L<App::Spec::Role::Plugin::GlobalOptions>.
  
  See L<App::Spec::Role::Plugin::GlobalOptions#install_options>.
  
  =item init_run
  
  See L<App::Spec::Role::Plugin>
  
  =item print_output
  
  This method is called by L<App::Spec::Run> right before output.
  
  =back
  
  =cut
  
  __DATA__
  ---
  -   name: format
      summary: Format output
      type: string
      enum: [JSON, YAML, Table, "Data::Dumper", "Data::Dump"]
  
APP_SPEC_PLUGIN_FORMAT

$fatpacked{"App/Spec/Plugin/Help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_PLUGIN_HELP';
  # ABSTRACT: App::Spec Plugin for help subcommand and options
  use strict;
  use warnings;
  package App::Spec::Plugin::Help;
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  with 'App::Spec::Role::Plugin::Subcommand';
  with 'App::Spec::Role::Plugin::GlobalOptions';
  
  my $yaml;
  my $cmd = {
      name => 'help',
      summary => 'Show command help',
      class => 'App::Spec::Plugin::Help',
      op => 'cmd_help',
      subcommand_required => 0,
      options => [
          { spec => 'all' },
      ],
  };
  my $options  = [
      {
          name => 'help',
          summary => 'Show command help',
          type => 'flag',
          aliases => ['h'],
      },
  ];
  
  sub install_subcommands {
      my ($class, %args) = @_;
      my $parent = $args{spec};
      my $appspec = App::Spec::Subcommand->read($cmd);
  
      my $help_subcmds = $appspec->subcommands || {};
  
      my $parent_subcmds = $parent->subcommands || {};
      $class->_add_subcommands($help_subcmds, $parent_subcmds, { subcommand_required => 0 });
      $appspec->subcommands($help_subcmds);
  
      return $appspec;
  }
  
  sub cmd_help {
      my ($self, $run) = @_;
      my $spec = $run->spec;
      my $cmds = $run->commands;
      shift @$cmds;
      my $help = $spec->usage(
          commands => $cmds,
          colored => $run->colorize_code,
      );
      $run->out($help);
  }
  
  sub _add_subcommands {
      my ($self, $commands1, $commands2, $ref) = @_;
      for my $name (keys %{ $commands2 || {} }) {
          next if $name eq "help";
          my $cmd = $commands2->{ $name };
          $commands1->{ $name } = App::Spec::Subcommand->new(
              name => $name,
              subcommands => {},
              %$ref,
          );
          my $subcmds = $cmd->{subcommands} || {};
          $self->_add_subcommands($commands1->{ $name }->{subcommands}, $subcmds, $ref);
      }
  }
  
  sub install_options {
      my ($class, %args) = @_;
      return $options;
  }
  
  sub init_run {
      my ($self, $run) = @_;
      $run->subscribe(
          global_options => {
              plugin => $self,
              method => "global_options",
          },
      );
  }
  
  sub global_options {
      my ($self, %args) = @_;
      my $run = $args{run};
      my $options = $run->options;
      my $op;
  
      if ($run->spec->has_subcommands) {
          if ($options->{help} and (not @{ $run->argv } or $run->argv->[0] ne "help")) {
              # call subcommand 'help'
              unshift @{ $run->argv }, "help";
          }
      }
      else {
          if ($options->{help}) {
              $op = "::cmd_help";
          }
      }
  
      $run->op("App::Spec::Plugin::Help$op") if $op;
  }
  
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Plugin::Help - App::Spec Plugin for help subcommand and options
  
  =head1 DESCRIPTION
  
  This plugin is enabled in L<App::Spec> by default.
  
  This is a plugin which adds C<-h|--help> options to your app.
  Also for apps with subcommands it adds a subcommand C<help>.
  
  The help command can then be called with all existing subcommands, like this:
  
      % app cmd1
      % app cmd2
      % app cmd2 cmd2a
      % app help
      % app help cmd1
      % app help cmd2
      % app help cmd2 cmd2a
  
  =head1 METHODS
  
  =over 4
  
  =item cmd_help
  
  This is the code which is executed when using C<-h|--help> or the subcommand
  help.
  
  =item install_options
  
  This method is required by L<App::Spec::Role::Plugin::GlobalOptions>.
  
  See L<App::Spec::Role::Plugin::GlobalOptions#install_options>.
  
  =item install_subcommands
  
  This is required by L<App::Spec::Role::Plugin::Subcommand>.
  
  See L<App::Spec::Role::Plugin::Subcommand#install_subcommands>.
  
  =item global_options
  
  This method is called by L<App::Spec::Run> after global options have been read.
  
  For apps without subcommands it just sets the method to execute to
  L<App::Spec::Plugin::Help::cmd_help>.
  No further processing is done.
  
  For apps with subcommands it inserts C<help> at the beginning of the
  commandline arguments and continues processing.
  
  =item init_run
  
  See L<App::Spec::Plugin>
  
  =back
  
  =cut
  
APP_SPEC_PLUGIN_HELP

$fatpacked{"App/Spec/Plugin/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_PLUGIN_META';
  # ABSTRACT: App::Spec Plugin for meta functions
  use strict;
  use warnings;
  package App::Spec::Plugin::Meta;
  our $VERSION = '0.013'; # VERSION
  
  use List::Util qw/ any /;
  
  use Moo;
  with 'App::Spec::Role::Plugin::Subcommand';
  
  my $yaml = do { local $/; <DATA> };
  
  sub install_subcommands {
      my ($class, %args) = @_;
      my $parent = $args{spec};
      my $appspec = App::Spec::Subcommand->read(\$yaml);
      return $appspec;
  }
  
  sub cmd_self_completion {
      my ($self, $run) = @_;
      my $options = $run->options;
      my $shell = $options->{zsh} ? "zsh" : $options->{bash} ? "bash" : '';
      unless ($shell) {
          my $ppid = getppid();
          chomp($shell = `ps --no-headers -o cmd $ppid`);
          $shell =~ s/.*\W(\w*sh).*$/$1/; #handling case of '-zsh' or '/bin/bash'
                                          #or bash -i -rs
      }
      unless (any { $_ eq $shell } qw/ bash zsh / ) {
          die "Specify which shell, '$shell' not supported";
      }
      my $spec = $run->spec;
      my $completion = $spec->generate_completion(
          shell => $shell,
      );
      $run->out($completion);
  }
  
  sub cmd_self_pod {
      my ($self, $run) = @_;
      my $spec = $run->spec;
  
      require App::Spec::Pod;
      my $generator = App::Spec::Pod->new(
          spec => $self,
      );
      my $pod = $generator->generate;
  
      $run->out($pod);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  App::Spec::Plugin::Meta - App::Spec Plugin for meta functions
  
  =head1 DESCRIPTION
  
  This plugin is enabled in L<App::Spec> by default.
  
  It adds the following commands to your app:
  
      % app meta completion generate
      % app meta pod generate
  
  =head1 METHODS
  
  =over 4
  
  =item cmd_self_completion
  
  This is called by C<app meta completion generate>
  
  =item cmd_self_pod
  
  This is called by C<app meta pod generate>
  
  =item install_subcommands
  
  See L<App::Spec::Role::Plugin::Subcommand#install_subcommands>
  
  =back
  
  =cut
  
  __DATA__
  ---
  name: _meta
  class: App::Spec::Plugin::Meta
  summary: Information and utilities for this app
  subcommands:
      completion:
          summary: Shell completion functions
          subcommands:
              generate:
                  summary: Generate self completion
                  op: cmd_self_completion
                  options:
                      -   name: name
                          summary: name of the program (optional, override name in spec)
                      -   name: zsh
                          summary: for zsh
                          type: flag
                      -   name: bash
                          summary: for bash
                          type: flag
      pod:
          summary: Pod documentation
          subcommands:
              generate:
                  summary: Generate self pod
                  op: cmd_self_pod
APP_SPEC_PLUGIN_META

$fatpacked{"App/Spec/Pod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_POD';
  # ASTRACT: Generates Pod from App::Spec objects
  use strict;
  use warnings;
  package App::Spec::Pod;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  
  has spec => ( is => 'ro' );
  
  sub generate {
      my ($self) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $title = $spec->title;
      my $abstract = $spec->abstract // '';
      my $description = $spec->description // '';
      my $subcmds = $spec->subcommands;
      my $global_options = $spec->options;
  
      $self->markup(text => \$abstract);
      $self->markup(text => \$description);
  
      my @subcmd_pod = $self->subcommand_pod(
          commands => $subcmds,
      );
      my $option_string = '';
      if (@$global_options) {
          $option_string = "=head2 GLOBAL OPTIONS\n\n" . $self->options2pod(
              options => $global_options,
          );
      }
  
      my $pod = <<"EOM";
  \=head1 NAME
  
  $appname - $title
  
  \=head1 ABSTRACT
  
  $abstract
  
  \=head1 DESCRIPTION
  
  $description
  
  $option_string
  
  \=head2 SUBCOMMANDS
  
  @{[ join '', @subcmd_pod ]}
  EOM
  
  }
  
  sub subcommand_pod {
      my ($self, %args) = @_;
      my $spec = $self->spec;
      my $appname = $spec->name;
      my $commands = $args{commands};
      my $previous = $args{previous} || [];
  
      my @pod;
      my %keys;
      @keys{ keys %$commands } = ();
      my @keys;
      if (@$previous) {
          @keys = sort keys %keys;
      }
      else {
          for my $key (qw/ help _meta /) {
              if (exists $keys{ $key }) {
                  push @keys, $key;
                  delete $keys{ $key };
              }
          }
          unshift @keys, sort keys %keys;
      }
      for my $name (@keys) {
          my $cmd_spec = $commands->{ $name };
          my $name = $cmd_spec->name;
          my $summary = $cmd_spec->summary;
          my $description = $cmd_spec->description;
          my $subcmds = $cmd_spec->subcommands;
          my $parameters = $cmd_spec->parameters;
          my $options = $cmd_spec->options;
  
          $self->markup(text => \$summary);
          $self->markup(text => \$description);
  
          my $desc = '';
          if (length $summary) {
              $desc .= "$summary\n\n";
          }
          if (length $description) {
              $desc .= "$description\n\n";
          }
  
          my $usage = "$appname @$previous $name";
          if (keys %$subcmds) {
              $usage .= " <subcommands>";
          }
  
          my $option_string = '';
          if (@$options) {
              $usage .= " [options]";
              $option_string = "Options:\n\n" . $self->options2pod(
                  options => $options,
              );
          }
  
          if (length $option_string) {
              $desc .= "$option_string\n";
          }
  
          my $param_string = '';
          if (@$parameters) {
              $param_string = "Parameters:\n\n" . $self->params2pod(
                  parameters => $parameters,
              );
              for my $param (@$parameters) {
                  my $name = $param->name;
                  my $required = $param->required;
                  $usage .= " " . $param->to_usage_header;
              }
          }
          if (length $param_string) {
              $desc .= $param_string;
          }
  
          my $pod = <<"EOM";
  \=head3 @$previous $name
  
      $usage
  
  $desc
  EOM
          if (keys %$subcmds and $name ne "help") {
              my @sub = $self->subcommand_pod(
                  previous => [@$previous, $name],
                  commands => $subcmds,
              );
              $pod .= join '', @sub;
          }
          push @pod, $pod;
      }
      return @pod;
  }
  
  sub params2pod {
      my ($self, %args) = @_;
      my $params = $args{parameters};
      my @rows;
      for my $param (@$params) {
          my $required = $param->required ? '*' : '';
          my $summary = $param->summary;
          my $multi = '';
          if ($param->mapping) {
              $multi = '{}';
          }
          elsif ($param->multiple) {
              $multi = '[]';
          }
          my $flags = $self->spec->_param_flags_string($param);
          push @rows, ["    " . $param->name, " " . $required, $multi, $summary . $flags];
      }
      my $test = $self->simple_table(\@rows);
      return $test;
  }
  
  sub simple_table {
      my ($self, $rows) = @_;
      my @widths;
  
      for my $row (@$rows) {
          for my $i (0 .. $#$row) {
              my $col = $row->[ $i ];
              $widths[ $i ] ||= 0;
              if ( $widths[ $i ] < length $col) {
                  $widths[ $i ] = length $col;
              }
          }
      }
      my $format = join ' ', map { "%-" . ($_ || 0) . "s" } @widths;
      my @lines;
      for my $row (@$rows) {
          my $string = sprintf "$format\n", map { $_ // '' } @$row;
          push @lines, $string;
      }
      return join '', @lines;
  
  }
  
  sub options2pod {
      my ($self, %args) = @_;
      my $options = $args{options};
      my @rows;
      for my $opt (@$options) {
          my $name = $opt->name;
          my $aliases = $opt->aliases;
          my $summary = $opt->summary;
          my $required = $opt->required ? '*' : '';
          my $multi = '';
          if ($opt->mapping) {
              $multi = '{}';
          }
          elsif ($opt->multiple) {
              $multi = '[]';
          }
          my @names = map {
              length $_ > 1 ? "--$_" : "-$_"
          } ($name, @$aliases);
          my $flags = $self->spec->_param_flags_string($opt);
          push @rows, ["    @names", " " . $required, $multi, $summary . $flags];
      }
      my $test = $self->simple_table(\@rows);
      return $test;
  }
  
  sub markup {
      my ($self, %args) = @_;
      my $text = $args{text};
      return unless defined $$text;
      my $markup = $self->spec->markup // '';
      if ($markup eq "swim") {
          $$text = $self->swim2pod($$text);
      }
  }
  sub swim2pod {
      my ($self, $text) = @_;
      require Swim;
      my $swim = Swim->new(text => $text);
      my $pod = $swim->to_pod;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Pod - Generates Pod from App::Spec objects
  
  =head1 SYNOPSIS
  
      my $generator = App::Spec::Pod->new(
          spec => $appspec,
      );
      my $pod = $generator->generate;
  
  =head1 METHODS
  
  =over 4
  
  =item generate
  
      my $pod = $generator->generate;
  
  =item markup
  
      $pod->markup(text => \$abstract);
  
  Applies markup defined in the spec to the text argument.
  
  =item options2pod
  
      my $option_string = "Options:\n\n" . $self->options2pod(
          options => $options,
      );
  
  =item params2pod
  
      my $param_string = "Parameters:\n\n" . $self->params2pod(
          parameters => $parameters,
      );
  
  =item subcommand_pod
  
  Generates pod for subcommands recursively
  
      my @pod = $self->subcommand_pod(
          previous => [@previous_subcmds],
          commands => $subcmds,
      );
  
  =item swim2pod
  
      my $pod = $self->swim2pod($swim);
  
  Converts Swim markup to Pod.
  See L<Swim>.
  
  =item spec
  
  Accessor for L<App::Spec> object
  
  =back
  
  =cut
  
APP_SPEC_POD

$fatpacked{"App/Spec/Role/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_ROLE_COMMAND';
  use strict;
  use warnings;
  package App::Spec::Role::Command;
  
  our $VERSION = '0.013'; # VERSION
  
  use YAML::PP;
  use List::Util qw/ any /;
  use App::Spec::Option;
  use Ref::Util qw/ is_arrayref /;
  
  use Moo::Role;
  
  has name => ( is => 'rw' );
  has markup => ( is => 'rw', default => 'pod' );
  has class => ( is => 'rw' );
  has op => ( is => 'ro' );
  has plugins => ( is => 'ro' );
  has plugins_by_type => ( is => 'ro', default => sub { +{} } );
  has options => ( is => 'rw', default => sub { +[] } );
  has parameters => ( is => 'rw', default => sub { +[] } );
  has subcommands => ( is => 'rw', default => sub { +{} } );
  has description => ( is => 'rw' );
  
  sub default_plugins {
      qw/ Meta Help /
  }
  
  sub has_subcommands {
      my ($self) = @_;
      return $self->subcommands ? 1 : 0;
  }
  
  sub build {
      my ($class, %spec) = @_;
      $spec{options} ||= [];
      $spec{parameters} ||= [];
      for (@{ $spec{options} }, @{ $spec{parameters} }) {
          $_ = { spec => $_ } unless ref $_;
      }
      $_ = App::Spec::Option->build(%$_) for @{ $spec{options} || [] };
      $_ = App::Spec::Parameter->build(%$_) for @{ $spec{parameters} || [] };
  
      my $commands;
      for my $name (keys %{ $spec{subcommands} || {} }) {
          my $cmd = $spec{subcommands}->{ $name };
          $commands->{ $name } = App::Spec::Subcommand->build(
              name => $name,
              %$cmd,
          );
      }
      $spec{subcommands} = $commands;
  
      if ( defined (my $op = $spec{op}) ) {
          die "Invalid op '$op'" unless $op =~ m/^\w+\z/;
      }
      if ( defined (my $class = $spec{class}) ) {
          die "Invalid class '$class'" unless $class =~ m/^ \w+ (?: ::\w+)* \z/x;
      }
  
      my $self = $class->new(%spec);
  }
  
  sub read {
      my ($class, $file) = @_;
      unless (defined $file) {
          die "No filename given";
      }
  
      my $spec = $class->load_data($file);
  
      my %disable;
      my @plugins;
  
      my $spec_plugins = $spec->{plugins} || [];
      for my $plugin (@$spec_plugins) {
          if ($plugin =~ m/^-(.*)/) {
              $disable{ $1 } = 1;
          }
      }
      my @default_plugins = grep { not $disable{ $_ } } $class->default_plugins;
  
      push @plugins, @default_plugins;
      push @plugins, grep{ not m/^-/ } @$spec_plugins;
      for my $plugin (@plugins) {
          unless ($plugin =~ s/^=//) {
              $plugin = "App::Spec::Plugin::$plugin";
          }
      }
      $spec->{plugins} = \@plugins;
  
      my $self = $class->build(%$spec);
  
      $self->load_plugins;
      $self->init_plugins;
  
      return $self;
  }
  
  sub load_data {
      my ($class, $file) = @_;
      my $spec;
      if (ref $file eq 'GLOB') {
          my $data = do { local $/; <$file> };
          $spec = eval { YAML::PP::Load($data) };
      }
      elsif (not ref $file) {
          $spec = eval { YAML::PP::LoadFile($file) };
      }
      elsif (ref $file eq 'SCALAR') {
          my $data = $$file;
          $spec = eval { YAML::PP::Load($data) };
      }
      elsif (ref $file eq 'HASH') {
          $spec = $file;
      }
  
      unless ($spec) {
          die "Error reading '$file': $@";
      }
      return $spec;
  }
  
  sub load_plugins {
      my ($self) = @_;
      my $plugins = $self->plugins;
      if (@$plugins) {
          require Module::Runtime;
          for my $plugin (@$plugins) {
              my $loaded = Module::Runtime::require_module($plugin);
          }
      }
  }
  
  sub init_plugins {
      my ($self) = @_;
      my $plugins = $self->plugins;
      if (@$plugins) {
          my $subcommands = $self->subcommands;
          my $options = $self->options;
          for my $plugin (@$plugins) {
              if ($plugin->does('App::Spec::Role::Plugin::Subcommand')) {
                  push @{ $self->plugins_by_type->{Subcommand} }, $plugin;
                  my $subc = $plugin->install_subcommands( spec => $self );
                  $subc = [ $subc ] unless is_arrayref($subc);
  
                  if ($subcommands) {
                      for my $cmd (@$subc) {
                          $subcommands->{ $cmd->name } ||= $cmd;
                      }
                  }
              }
  
              if ($plugin->does('App::Spec::Role::Plugin::GlobalOptions')) {
                  push @{ $self->plugins_by_type->{GlobalOptions} }, $plugin;
                  my $new_opts = $plugin->install_options( spec => $self );
                  if ($new_opts) {
                      $options ||= [];
  
                      for my $opt (@$new_opts) {
                          $opt = App::Spec::Option->build(%$opt);
                          unless (any { $_->name eq $opt->name } @$options) {
                              push @$options, $opt;
                          }
                      }
  
                  }
              }
  
          }
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Role::Command - commands and subcommands both use this role
  
  =head1 METHODS
  
  =over 4
  
  =item read
  
  Calls load_data, build, load_plugins, init_plugins
  
  =item build
  
  This builds a tree of objects
  
      my $self = App::Spec->build(%$hashref);
      my $self = App::Spec::Subcommand->build(%$hashref);
  
  =item load_data
  
      my $spec = App::Spec->load_data($file);
  
  Takes a filename as a string, a filehandle, a ref to a YAML string or
  a hashref.
  
  =item default_plugins
  
  Returns ('Meta', 'Help')
  
  =item has_subcommands
  
  Returns 1 if there are any subcommands defined.
  
  =item init_plugins
  
  Initialize plugins
  
  =item load_plugins
  
  Loads the specified plugin modules.
  
  =item plugins_by_type
  
      my $p = $cmd->plugins_by_type->{Subcommand};
  
  =back
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item class
  
  Specifies the class which implements the app.
  
  =item op, description, markup, name, options, parameters, plugins, subcommands
  
  Accessors for specification items
  
  =back
  
  
  =cut
APP_SPEC_ROLE_COMMAND

$fatpacked{"App/Spec/Role/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_ROLE_PLUGIN';
  # ABSTRACT: Main role for App::Spec plugins
  use strict;
  use warnings;
  package App::Spec::Role::Plugin;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo::Role;
  
  sub init_run {
      my ($self, $run) = @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Role::Plugin - Main role for App::Spec plugins
  
  =head1 METHODS
  
  =over 4
  
  =item init_run
  
  Will be called with the plugin object/class and an L<App::Spec::Run>
  object as parameters.
  
      my ($self, $run) = @_;
  
  You can then use the C<subscribe> method of App::Spec::Run to subscribe
  to certain events.
  
  =back
  
  =cut
APP_SPEC_ROLE_PLUGIN

$fatpacked{"App/Spec/Role/Plugin/GlobalOptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_ROLE_PLUGIN_GLOBALOPTIONS';
  # ABSTRACT: Plugins for adding options should use this role
  use strict;
  use warnings;
  package App::Spec::Role::Plugin::GlobalOptions;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo::Role;
  
  requires 'install_options';
  
  with 'App::Spec::Role::Plugin';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Role::Plugin::GlobalOptions - Plugins for adding options should use this role
  
  =head1 DESCRIPTION
  
  See L<App::Spec::Plugin::Help> for an example.
  
  =head1 REQUIRED METHODS
  
  =over 4
  
  =item install_options
  
  This should return an arrayref of options:
  
      [
          {
              name => "help",
              summary: "Show command help",
              ...,
          },
      ]
  
  
  
  =back
APP_SPEC_ROLE_PLUGIN_GLOBALOPTIONS

$fatpacked{"App/Spec/Role/Plugin/Subcommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_ROLE_PLUGIN_SUBCOMMAND';
  # ABSTRACT: Plugins for subcommands should use this role
  use strict;
  use warnings;
  package App::Spec::Role::Plugin::Subcommand;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo::Role;
  
  requires 'install_subcommands';
  
  with 'App::Spec::Role::Plugin';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Role::Plugin::Subcommand - Plugins for subcommands should use this role
  
  =head1 DESCRIPTION
  
  See L<App::Spec::Plugin::Help> for an example.
  
  =head1 REQUIRED METHODS
  
  =over 4
  
  =item install_subcommands
  
  =back
  
  
  =cut
APP_SPEC_ROLE_PLUGIN_SUBCOMMAND

$fatpacked{"App/Spec/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_RUN';
  # ABSTRACT: App::Spec framework to run your app
  use strict;
  use warnings;
  package App::Spec::Run;
  use 5.010;
  our $VERSION = '0.013'; # VERSION
  
  use App::Spec::Run::Validator;
  use App::Spec::Run::Response;
  use Getopt::Long qw/ :config pass_through bundling /;
  use Ref::Util qw/ is_arrayref /;
  use Moo;
  
  has spec => ( is => 'ro' );
  has options => ( is => 'rw' );
  has parameters => ( is => 'rw', default => sub { +{} } );
  has commands => ( is => 'rw' );
  has argv => ( is => 'rw' );
  has argv_orig => ( is => 'rw' );
  #has runmode => ( is => 'rw', default => 'normal' );
  has validation_errors => ( is => 'rw' );
  has op => ( is => 'rw' );
  has cmd => ( is => 'rw' );
  has response => ( is => 'rw', default => sub { App::Spec::Run::Response->new } );
  has subscribers => ( is => 'rw', default => sub { +{} } );
  
  my %EVENTS = (
      print_output => 1,
      global_options => 1,
  );
  
  sub process {
      my ($self) = @_;
  
      my $plugins = $self->spec->plugins || [];
      for my $plugin (@$plugins) {
          $plugin->init_run($self);
      }
      my @callbacks;
      my $subscriber_events = $self->subscribers;
      for my $key (qw/ global_options print_output /) {
          my $subscribers = $subscriber_events->{ $key };
          for my $sub (@$subscribers) {
              my $plugin = $sub->{plugin};
              my $method = $sub->{method};
              my $callback = sub {
                  $plugin->$method( run => $self, @_);
              };
              push @callbacks, $callback;
          }
          $self->response->add_callbacks($key => \@callbacks);
      }
  
      my $argv = $self->argv;
      unless ($argv) {
          $argv = \@ARGV;
          $self->argv($argv);
          $self->argv_orig([ @$argv ]);
      }
  
      my $completion_parameter = $ENV{PERL5_APPSPECRUN_COMPLETION_PARAMETER};
  
      my %option_specs;
      my %param_specs;
      unless ($self->op) {
          $self->process_input(
              option_specs => \%option_specs,
              param_specs => \%param_specs,
          );
      }
  
      unless ($self->response->halted) {
          my $opt = App::Spec::Run::Validator->new({
              options => $self->options,
              option_specs => \%option_specs,
              parameters => $self->parameters,
              param_specs => \%param_specs,
          });
          my %errs;
          my $ok = $opt->process( $self, \%errs );
          unless ($ok) {
              $self->validation_errors(\%errs);
              # if we are in completion mode, some errors might be ok
              if (not $completion_parameter) {
                  $self->error_output;
              }
          }
      }
  
      unless ($self->response->halted) {
  
          my $op = $self->op;
  
          if ($completion_parameter) {
              $self->completion_output(
                  param_specs => \%param_specs,
                  option_specs => \%option_specs,
                  completion_parameter => $completion_parameter,
              );
          }
          else {
              $self->run_op($op);
          }
      }
  
  }
  
  sub run {
      my ($self) = @_;
  
      $self->process;
  
  #    $self->event_processed;
      $self->finish;
  
  }
  
  sub run_op {
      my ($self, $op, $args) = @_;
      $self->cmd->$op($self, $args);
  }
  
  sub out {
      my ($self, $text) = @_;
      $text .= "\n" if (not ref $text and $text !~ m/\n\z/);
      $self->response->add_output($text);
  }
  
  sub err {
      my ($self, $text) = @_;
      $text .= "\n" if (not ref $text and $text !~ m/\n\z/);
      $self->response->add_error($text);
  }
  
  sub halt {
      my ($self, $exit) = @_;
      $self->response->halted(1);
      $self->response->exit($exit || 0);
  }
  
  sub finish {
      my ($self) = @_;
      my $res = $self->response;
      $res->print_output;
      $res->finished(1);
      if (my $exit = $res->exit) {
          exit $exit;
      }
  }
  
  sub completion_output {
      my ($self, %args) = @_;
      my $completion_parameter = $args{completion_parameter};
      my $param_specs = $args{param_specs};
      my $option_specs = $args{option_specs};
      my $shell = $ENV{PERL5_APPSPECRUN_SHELL} or return;
      my $param = $param_specs->{ $completion_parameter };
      $param ||= $option_specs->{ $completion_parameter };
      my $unique = $param->{unique};
      my $completion = $param->completion or return;
      my $op;
      if (ref $completion) {
          $op = $completion->{op} or return;
      }
      else {
          my $possible_values = $param->values or return;
          $op = $possible_values->{op} or return;
      }
      my $args = {
          runmode => "completion",
          parameter => $completion_parameter,
      };
      my $result = $self->run_op($op, $args);
  
      my $string = '';
      my %seen;
      if ($unique) {
          my $params = $self->parameters;
          my $value = $params->{ $completion_parameter };
          $value = [$value] unless is_arrayref $value;
          # cmd param1 param2<TAB> results in
          # @ARGV = ["param1", "param2"]
          # cmd param1 param2 <TAB> results in
          # @ARGV = ["param1", "param2", ""]
          # so we know that there is a new value to be completed
          my $last = pop @$value;
          @seen{ @$value } = (1) x @$value;
      }
      for my $item (@$result) {
          if (ref $item eq 'HASH') {
              my $name = $item->{name};
              $unique and $seen{ $name }++ and next;
              my $desc = $item->{description};
              $string .= "$name\t$desc\n";
          }
          else {
              $unique and $seen{ $item }++ and next;
              $string .= "$item\n";
          }
      }
  
      $self->out($string);
      return;
  }
  
  sub error_output {
      my ($self) = @_;
      my $errs = $self->validation_errors;
      my @error_output;
      for my $key (sort keys %$errs) {
          my $errors = $errs->{ $key };
          if ($key eq "parameters" or $key eq "options") {
              for my $name (sort keys %$errors) {
                  my $error = $errors->{ $name };
                  $key =~ s/s$//;
                  push @error_output, "Error: $key '$name': $error";
              }
          }
          else {
              require Data::Dumper;
              my $err = Data::Dumper->Dump([$errs], ['errs']);
              push @error_output, $err;
          }
      }
      my $help = $self->spec->usage(
          commands => $self->commands,
          highlights => $errs,
          colored => $self->colorize_code('err'),
      );
      $self->err($help);
      for my $msg (@error_output) {
          $msg = $self->colored('err', [qw/ error /], $msg);
          $self->err("$msg\n");
      }
      $self->halt(1);
  }
  
  sub colorize_code {
      my ($self, $out) = @_;
      $self->colorize($out)
          ? sub {
              my $colored = $self->colored($out, $_[0], $_[1]);
              unless (defined wantarray) {
                  $_[1] = $colored;
              }
              return $colored;
          }
          : sub { $_[1] },
  }
  
  sub colorize {
      my ($self, $out) = @_;
      $out ||= 'out';
      if (($ENV{PERL5_APPSPECRUN_COLOR} // '') eq 'always') {
          return 1;
      }
      if (($ENV{PERL5_APPSPECRUN_COLOR} // '') eq 'never') {
          return 0;
      }
      if ($out eq 'out' and -t STDOUT or $out eq 'err' and -t STDERR) {
          return 1;
      }
      return 0;
  }
  
  sub process_parameters {
      my ($self, %args) = @_;
      my $param_list = $args{parameter_list};
      my $parameters = $self->parameters;
      my $param_specs = $args{param_specs};
      for my $p (@$param_list) {
          my $name = $p->name;
          my $type = $p->type;
          my $multiple = $p->multiple;
          my $required = $p->required;
          my $value;
          if ($multiple) {
              $value = [@{ $self->argv }];
              @{ $self->argv } = ();
          }
          else {
              $value = shift @{ $self->argv };
          }
          $parameters->{ $name } = $value;
          $param_specs->{ $name } = $p;
      }
  }
  
  sub process_input {
      my ($self, %args) = @_;
      my %options;
      $self->options(\%options);
      my @cmds;
      my $spec = $self->spec;
      my $option_specs = $args{option_specs};
      my $param_specs = $args{param_specs};
      my $global_options = $spec->options;
      my $global_parameters = $spec->parameters;
      my @getopt = $spec->make_getopt($global_options, \%options, $option_specs);
      GetOptions(@getopt);
      $self->event_globaloptions;
      my $op = $self->op;
  
      $self->process_parameters(
          parameter_list => $global_parameters,
          param_specs => $param_specs,
      );
  
  
  
      my $commands = $spec->subcommands;
      my $opclass = $self->spec->class;
      my $cmd_spec;
      my $subcommand_required = 1;
      while (keys %$commands) {
          my $cmd = shift @{ $self->argv };
          if (not defined $cmd) {
              if (not $op or $subcommand_required) {
                  $self->err($spec->usage(
                      commands => \@cmds,
                      colored => $self->colorize_code('err'),
                      highlights => {
                          subcommands => 1,
                      },
                  ));
                  $self->err( $self->colorize_error("Missing subcommand(s)") );
                  $self->halt(1);
              }
              last;
          }
          $cmd_spec = $commands->{ $cmd } or do {
              $self->err($spec->usage(
                  commands => \@cmds,
                  colored => $self->colorize_code('err'),
                  highlights => {
                      subcommands => 1,
                  },
              ));
              $self->err( $self->colorize_error("Unknown subcommand '$cmd'") );
              $self->halt(1);
              last;
          };
          $subcommand_required = $cmd_spec->{subcommand_required} // 1;
          my $cmd_options = $cmd_spec->options;
          my @getopt = $spec->make_getopt($cmd_options, \%options, $option_specs);
          GetOptions(@getopt);
          push @cmds, $cmd;
          $commands = $cmd_spec->subcommands || {};
          $op = '::' . $cmd_spec->op if $cmd_spec->op;
          $opclass = $cmd_spec->class if $cmd_spec->class;
  
          $self->process_parameters(
              parameter_list => $cmd_spec->parameters,
              param_specs => $param_specs,
          );
      }
  
      unless ($self->response->halted) {
          unless ($op) {
              if ($spec->has_subcommands) {
                  $self->err( "Missing op for commands (@cmds)\n" );
                  my $help = $spec->usage(
                      commands => \@cmds,
                      colored => $self->colorize_code('err'),
                  );
                  $self->err( $help );
                  $self->halt(1);
              }
              else {
                  $op = "::execute";
              }
          }
          $self->commands(\@cmds);
          $self->options(\%options);
          if ($op =~ m/^::/) {
              $op = $opclass . $op;
          }
          $self->op($op);
          return $op;
      }
  
      return;
  }
  
  sub colorize_error {
      my ($self, $msg) = @_;
      $msg = $self->colored('err', [qw/ error /], $msg) . "\n";
  }
  
  sub colored {
      my ($self, $out, $colors, $msg) = @_;
      $colors = [ map { $_ eq 'error' ? qw/ bold red / : $_ } @$colors ];
      require Term::ANSIColor;
      $self->colorize($out)
          and $msg = Term::ANSIColor::colored($colors, $msg);
      return $msg;
  }
  
  sub subscribe {
      my ($self, %args) = @_;
  
      for my $event (sort keys %args) {
          next unless exists $EVENTS{ $event };
          my $info = $args{ $event };
          push @{ $self->subscribers->{ $event } }, $info;
      }
  
  }
  
  sub event_globaloptions {
      my ($self) = @_;
  
      my $subscribers = $self->subscribers->{global_options};
      for my $sub (@$subscribers) {
          my $plugin = $sub->{plugin};
          my $method = $sub->{method};
          $plugin->$method( run => $self);
      }
  }
  
  #sub event_processed {
  #    my ($self) = @_;
  #    my $plugins = $self->spec->plugins_by_type->{GlobalOptions};
  #    for my $plugin (@$plugins) {
  #        next unless $plugin->can("event_processed");
  #        $plugin->event_processed(
  #            run => $self,
  #        );
  #    }
  #}
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Spec::Run - App::Spec framework to run your app
  
  =head1 DESCRIPTION
  
  App::Spec::Run is the framework which runs your app defined by the spec.
  Your app class should inherit from L<App::Spec::Run::Cmd>.
  
  =head1 SYNOPSIS
  
      sub your_command {
          my ($self, $run) = @_;
          my $options = $run->options;
          $run->out("It works");
      }
  
  =head1 METHODS
  
  =over 4
  
  =item Constructor
  
  You can create the object yourself like this:
  
      my $run = App::Spec::Run->new(
          spec => $appspec,
          cmd => App::YourApp->new,
      );
  
  Or you use the runner method of L<App::Spec>, which will create it for you:
  
      my $run = $appspec->runner(...);
  
  Both methods take optional arguments:
  
      my $run = App::Spec::Run->new(
          spec => $appspec,
          cmd => App::YourApp->new,
  
          # Custom array instead of the default ARGV.
          # The contents of this array will be modified
          argv => \@my_arguments,
      );
  
  =item run
  
      $run->run;
  
  Actually runs your app. Calls C<process> and C<finish>.
  
  =item process
  
      $run->process;
  
  Processes input, validates, runs your command and fills the
  response object.
  
  Does not print the output and does not exit.
  
  =item out
  
      $run->out("Hello world!");
  
  Appends to response output. Adds a newline if not present. You can also
  pass a data structure:
  
      $run->out($hashref);
  
  This will be formatted with L<Data::Dumper>.
  
  See also L<App::Spec::Plugin::Format>.
  
  =item err
  
      $run->err("Oops, that went wrong");
  
  Appends to response error output. Adds a newline if not present
  
  =item halt
  
      $run->halt;
  
  Further processing is halted.
  
  =item finish
  
      $run->finish;
  
  Prints the output and exits with the exit code stored in C<response>.
  
  =item process_input
  
      $run->process_input(
          option_specs => \%option_specs,
          param_specs => \%param_specs,
      );
  
  =item process_parameters
  
      $run->process_parameters(
          parameter_list => $global_parameters,
          param_specs => $param_specs,
      );
  
  =item run_op
  
      $run->run_op("yourcommand");
      # shortcut for
      $run->cmd->yourcommand($run);
  
  =item completion_output
  
      $run->completion_output(
          param_specs => \%param_specs,
          completion_parameter => $completion_parameter,
      );
  
  Is called when in completion mode
  
  =item colored
  
  Returns the given text colored, if colors are active for the given
  output.
  
      $msg = $run->colored('err', [qw/ error /], "Oops");
      $msg = $run->colored('out', [qw/ green /], "Everything is fine!");
  
  =item colorize
  
      my $color_active = $run->colorize('out');
      my $color_error_active = $run->colorize('err');
  
  Returns 1 or 0 if given output color are active. That means, the output
  is going to a terminal instead of being redirected.
  
  =item colorize_code
  
      my $colored = $run->colorize_code('out');
      my $text = $colored->(['green'], "Hurray");
      # or
      my $text = "Hurray";
      $colored->(['green'], $text);
  
  Returns a coderef which you can use for coloring
  
  =item colorize_error
  
      my $msg = $run->colorize_error("ouch");
  
  Returns the message in the standard error color (bold red).
  
  =item error_output
  
      $run->error_output;
  
  Outputs any errors.
  
  Calls C<halt>
  
  =item event_globaloptions
  
  Calls any plugin that needs to know
  
  =item subscribe
  
  A plugin can subscribe for an event:
  
      $run->subscribe(
          print_output => {
              plugin => $self,
              method => "print_output",
          },
  
  =back
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item spec
  
  Your spec, (App::Spec)
  
  =item options
  
  A hashref with the given options
  
      {
          verbose => 1,
          foo => 23,
      }
  
  =item parameters
  
  A hashref with the given parameters
  
  =item commands
  
  An arrayref containing all subcommands from the commandline
  
  =item argv_orig
  
  This contains the original contents of C<argv> before processing
  
  =item argv
  
  This is a reference to the commandline arguments array C<@ARGV>, or the
  array reference you specified otherwise. When calling your command method,
  it will contain the rest of the arguments which weren't processed as
  any subcommand, option or parameter.
  
  =item validation_errors
  
  Contains errors from option/parameter validation
  
  =item op
  
  Contains the operation (subroutine) which will be executed to run
  yor command
  
  =item cmd
  
  This is an instance of your app class
  
  =item response
  
  This contains the response of your command (exit code, output, ...)
  
  See L<App::Spec::Run::Response>
  
  =item subscribers
  
  Contains a hashref
  
      {
          print_output => {
              module => $plugin,
              method => 'print_output',
          },
      }
  
  =back
  
  =cut
  
APP_SPEC_RUN

$fatpacked{"App/Spec/Run/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_RUN_CMD';
  # ABSTRACT: The App::Spec command which is run
  use strict;
  use warnings;
  package App::Spec::Run::Cmd;
  our $VERSION = '0.013'; # VERSION
  
  use App::Spec::Run;
  use Moo;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Run::Cmd - The App::Spec command which is run
  
  =cut
APP_SPEC_RUN_CMD

$fatpacked{"App/Spec/Run/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_RUN_OUTPUT';
  # ABSTRACT: Output class for App::Spec::Run
  use strict;
  use warnings;
  package App::Spec::Run::Output;
  
  our $VERSION = '0.013'; # VERSION
  
  use Moo;
  
  has type => ( is => 'rw', default => 'plain' );
  has error => ( is => 'rw' );
  has content => ( is => 'rw' );
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Run::Output - Output class for App::Spec::Run
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item type
  
  Currently two types ar esupported: C<plain>, C<data>
  
  =item error
  
  If set to 1, output is supposed to go to stderr.
  
  =item content
  
  The text or data content.
  
  =back
  
  =cut
APP_SPEC_RUN_OUTPUT

$fatpacked{"App/Spec/Run/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_RUN_RESPONSE';
  # ABSTRACT: Response class for App::Spec::Run
  use strict;
  use warnings;
  package App::Spec::Run::Response;
  
  our $VERSION = '0.013'; # VERSION
  
  use App::Spec::Run::Output;
  use Scalar::Util qw/ blessed /;
  
  use Moo;
  
  has exit => ( is => 'rw', default => 0 );
  has outputs => ( is => 'rw', default => sub { [] } );
  has finished => ( is => 'rw' );
  has halted => ( is => 'rw' );
  has buffered => ( is => 'rw', default => 0 );
  has callbacks => ( is => 'rw', default => sub { +{} } );
  
  sub add_output {
      my ($self, @out) = @_;
  
      for my $out (@out) {
          unless (blessed $out) {
              $out = App::Spec::Run::Output->new(
                  content => $out,
                  ref $out ? (type => 'data') : (),
              );
          }
      }
  
      if ($self->buffered) {
          my $outputs = $self->outputs;
          push @$outputs, @out;
      }
      else {
          $self->print_output(@out);
      }
  }
  
  sub add_error {
      my ($self, @out) = @_;
  
      for my $out (@out) {
          unless (blessed $out) {
              $out = App::Spec::Run::Output->new(
                  error => 1,
                  content => $out,
              );
          }
      }
  
      if ($self->buffered) {
          my $outputs = $self->outputs;
          push @$outputs, @out;
      }
      else {
          $self->print_output(@out);
      }
  }
  
  sub print_output {
      my ($self, @out) = @_;
      my $outputs = $self->outputs;
      push @$outputs, @out;
  
      my $callbacks = $self->callbacks->{print_output} || [];
      for my $cb (@$callbacks) {
          $cb->();
      }
  
      while (my $out = shift @$outputs) {
          my $content = $out->content;
          if (ref $content) {
              require Data::Dumper;
              $content = Data::Dumper->Dump([$content], ['output']);
          }
          if ($out->error) {
              print STDERR $content;
          }
          else {
              print $content;
          }
      }
  }
  
  sub add_callbacks {
      my ($self, $event, $cb_add) = @_;
      my $callbacks = $self->callbacks;
      my $cb = $callbacks->{ $event } ||= [];
      push @$cb, @$cb_add;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Run::Response - Response class for App::Spec::Run
  
  =head1 METHODS
  
  =over 4
  
  =item add_output
  
  If you pass it a string, it will create a L<App::Spec::Run::Output>.
  
      $res->add_output("string\n", "string2\n");
      my $output = App::Spec::Run::Output->new(
          content => "string\n",
      );
      $res->add_output($output);
  
  This will call C<print_output> if buffered is false, otherwise it will
  add the output to C<outputs>
  
  =item add_error
  
  Like C<add_output>, but the created Output object will have an attribute
  C<error> set to 1.
  
      $res->add_error("string\n", "string2\n");
      my $output = App::Spec::Run::Output->new(
          error => 1,
          content => "string\n",
      );
      $res->add_error($output);
  
  =item print_output
  
      $res->print_output(@out);
  
  Prints the given output and all output in C<outputs>.
  
  =item add_callbacks
  
      $response->add_callbacks(print_output => \@callbacks);
  
  Where C<@callbacks> are coderefs.
  
  =back
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item buffered
  
  If true, output should be buffered until print_output is called.
  
  Default: false
  
  =item exit
  
  The exit code
  
  =item outputs
  
  Holds an array of L<App::Spec::Run::Output> objects.
  
  =item finished
  
  Set to 1 after print_output has been called.
  
  =item halted
  
  If set to 1, no further processing should be done.
  
  =item callbacks
  
  Contains a hashref of callbacks
  
      {
          print_output => $coderef,
      },
  
  =back
  
  =cut
APP_SPEC_RUN_RESPONSE

$fatpacked{"App/Spec/Run/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_RUN_VALIDATOR';
  # ABSTRACT: Processes and validates options and parameters
  use strict;
  use warnings;
  package App::Spec::Run::Validator;
  
  our $VERSION = '0.013'; # VERSION;
  
  use List::Util qw/ any /;
  use List::MoreUtils qw/ uniq /;
  use Ref::Util qw/ is_arrayref is_hashref /;
  use Moo;
  
  has options => ( is => 'ro' );
  has option_specs => ( is => 'ro' );
  has parameters => ( is => 'ro' );
  has param_specs => ( is => 'ro' );
  
  my %validate = (
      string => sub { length($_[0]) > 0 },
      file => sub { $_[0] eq '-' or -f $_[0] },
      filename => sub { 1 },
      dir => sub { -d $_[0] },
      dirname => sub { 1 },
      integer => sub { $_[0] =~ m/^[+-]?\d+$/ },
      float => sub { $_[0] =~ m/^[+-]?\d+(?:\.\d+)?$/ },
      flag => sub { 1 },
      enum => sub {
          my ($value, $list) = @_;
          any { $value eq $_ } @$list;
      },
  );
  
  sub process {
      my ($self, $run, $errs) = @_;
      my ($ok) = $self->_process( $errs, type => "parameters", app => $run );
      $ok &&= $self->_process( $errs, type => "options", app => $run );
      return $ok;
  }
  
  sub _process {
      my ($self, $errs, %args) = @_;
      my $run = $args{app};
      my $type = $args{type};
      my ($items, $specs);
      if ($args{type} eq "parameters") {
          $items = $self->parameters;
          $specs = $self->param_specs;
      }
      else {
          $items = $self->options;
          $specs = $self->option_specs;
      }
  
      # TODO: iterate over parameters in original cmdline order
      for my $name (sort keys %$specs) {
          my $spec = $specs->{ $name };
          my $value = $items->{ $name };
          my $param_type = $spec->type;
          my $enum = $spec->enum;
  
          if ($spec->type eq "flag") {
              if ($spec->multiple) {
                  if (defined $value and $value !~ m/^\d+$/) {
                      die "Value for '$name': '$value' shouldn't happen";
                  }
              }
              else {
                  if (defined $value and $value != 1) {
                      die "Value for '$name': '$value' shouldn't happen";
                  }
              }
              next;
          }
  
          my $values;
          if ($spec->multiple and $spec->mapping) {
              if (not defined $value) {
                  $items->{ $name } = $value = {};
              }
              $values = $value;
  
              if (not keys %$values) {
                  if (defined (my $default = $spec->default)) {
                      $values = { split m/=/, $default, 2 };
                      $items->{ $name } = $values;
                  }
              }
  
              if (not keys %$values and $spec->required) {
                  $errs->{ $type }->{ $name } = "missing";
                  next;
              }
  
              if (not keys %$values) {
                  next;
              }
  
          }
          elsif ($spec->multiple) {
              if (not defined $value) {
                  $items->{ $name } = $value = [];
              }
              $values = $value;
  
              if (not @$values) {
                  if (defined (my $default = $spec->default)) {
                      $values = [ $default ];
                      $items->{ $name } = $values;
                  }
              }
  
              if ( not @$values and $spec->required) {
                  $errs->{ $type }->{ $name } = "missing";
                  next;
              }
  
              if (not @$values) {
                  next;
              }
  
              if ($spec->unique and (uniq @$values) != @$values) {
                  $errs->{ $type }->{ $name } = "not_unique";
                  next;
              }
  
          }
          else {
  
              if (not defined $value) {
                  if (defined (my $default = $spec->default)) {
                      $value = $default;
                      $items->{ $name } = $value;
                  }
              }
  
              if ( not defined $value and $spec->required) {
                  $errs->{ $type }->{ $name } = "missing";
                  next;
              }
  
              if (not defined $value) {
                  next;
              }
  
              $values = [ $value ];
          }
  
          my $def;
          if (ref $param_type eq 'HASH') {
              ($param_type, $def) = %$param_type;
          }
          my $code = $validate{ $param_type }
              or die "Missing method for validation type $param_type";
  
          my $possible_values = $spec->mapping ? {} : [];
          if (my $spec_values = $spec->values) {
              if (my $op = $spec_values->{op}) {
                  my $args = {
                      runmode => "validation",
                      parameter => $name,
                  };
                  $possible_values = $run->cmd->$op($run, $args) || [];
              }
              elsif ($spec->mapping) {
                  $possible_values = $spec_values->{mapping};
              }
              else {
                  $possible_values = $values->{enum};
              }
          }
  
          my @to_check = $spec->mapping
              ? map { [ $_ => $values->{ $_ } ] } keys %$values
              : @$values;
          for my $item (@to_check) {
              my ($key, $v);
              if ($spec->mapping) {
                  ($key, $v) = @$item;
              }
              else {
                  $v = $item;
              }
              # check type validity
              my $ok = $code->($v, $def);
              unless ($ok) {
                  $errs->{ $type }->{ $name } = "invalid $param_type";
              }
              # check static enums
              if ($enum) {
                  my $code = $validate{enum}
                      or die "Missing method for validation type enum";
                  my $ok = $code->($v, $enum);
                  unless ($ok) {
                      $errs->{ $type }->{ $name } = "invalid enum";
                  }
              }
              if ($param_type eq 'file' and $v eq '-') {
                  $v = do { local $/; my $t = <STDIN>; \$t };
                  # TODO does not work for multiple
                  $items->{ $name } = $v;
              }
  
              if ($spec->mapping and keys %$possible_values) {
                  my $ok = 0;
                  if (exists $possible_values->{ $key }) {
                      if (my $list = $possible_values->{ $key }) {
                          $ok = any { $_ eq $v } @$list;
                      }
                      else {
                          # can have any value
                          $ok = 1;
                      }
                  }
                  unless ($ok) {
                      $errs->{ $type }->{ $name } = "invalid value";
                  }
              }
              elsif (@$possible_values) {
                  my $ok = any {
                      is_hashref($_) ? $_->{name} eq $v : $_ eq $v
                  } @$possible_values;
                  unless ($ok) {
                      $errs->{ $type }->{ $name } = "invalid value";
                  }
              }
          }
      }
      return (keys %$errs) ? 0 : 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Run::Validator - Processes and validates options and parameters
  
  =head1 METHODS
  
  =over 4
  
  =item process
  
      my %errs;
      my $ok = $validator->process( $run, \%errs );
  
  Returns 1 or 0. In case of validation errors, it fills C<%errs>.
  
  =back
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item options
  
  Holds the read commandline options
  
  =item parameters
  
  Holds the read commandline parameters
  
  =item option_specs
  
  Holds the items from App::Spec for options
  
  =item param_specs
  
  Holds the items from App::Spec for parameters
  
  =back
  
  =cut
APP_SPEC_RUN_VALIDATOR

$fatpacked{"App/Spec/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_SCHEMA';
  use strict;
  use warnings;
  package App::Spec::Schema;
  
  our $VERSION = '0.013'; # VERSION
  
  use base 'Exporter';
  our @EXPORT_OK = qw/ $SCHEMA /;
  
  our $SCHEMA;
  
  # START INLINE
  $SCHEMA = {
    'additionalProperties' => '',
    'definitions' => {
      'bool' => {
        'anyOf' => [
          {
            'type' => 'boolean'
          },
          {
            'type' => 'integer'
          },
          {
            'maxLength' => 0,
            'type' => 'string'
          }
        ]
      },
      'command' => {
        'additionalProperties' => '',
        'properties' => {
          'description' => {
            'type' => 'string'
          },
          'op' => {
            'type' => 'string'
          },
          'options' => {
            '$ref' => '#/definitions/options'
          },
          'parameters' => {
            '$ref' => '#/definitions/options'
          },
          'subcommands' => {
            'additionalProperties' => '',
            'patternProperties' => {
              '^[a-zA-Z0-9_]+$' => {
                '$ref' => '#/definitions/command'
              }
            },
            'type' => 'object'
          },
          'summary' => {
            'type' => 'string'
          }
        },
        'type' => 'object'
      },
      'option' => {
        'additionalProperties' => '',
        'anyOf' => [
          {
            'required' => [
              'name'
            ]
          },
          {
            'required' => [
              'spec'
            ]
          }
        ],
        'properties' => {
          'aliases' => {
            'items' => {
              'type' => 'string'
            },
            'type' => 'array'
          },
          'completion' => {
            'oneOf' => [
              {
                'type' => 'object'
              },
              {
                '$ref' => '#/definitions/bool'
              }
            ]
          },
          'default' => {
            'type' => 'string'
          },
          'description' => {
            'type' => 'string'
          },
          'enum' => {
            'items' => {
              'type' => 'string'
            },
            'type' => 'array'
          },
          'mapping' => {
            '$ref' => '#/definitions/bool'
          },
          'multiple' => {
            '$ref' => '#/definitions/bool'
          },
          'name' => {
            'type' => 'string'
          },
          'required' => {
            '$ref' => '#/definitions/bool'
          },
          'spec' => {
            'type' => 'string'
          },
          'summary' => {
            'type' => 'string'
          },
          'type' => {
            'oneOf' => [
              {
                '$ref' => '#/definitions/optionTypeSimple'
              }
            ]
          },
          'unique' => {
            '$ref' => '#/definitions/bool'
          },
          'values' => {
            'additionalProperties' => '',
            'properties' => {
              'enum' => {
                'items' => {
                  'type' => 'string'
                },
                'type' => 'array'
              },
              'mapping' => {
                'type' => 'object'
              },
              'op' => {
                'type' => 'string'
              }
            },
            'type' => 'object'
          }
        },
        'type' => [
          'object',
          'string'
        ]
      },
      'optionTypeSimple' => {
        'enum' => [
          'flag',
          'string',
          'integer',
          'float',
          'file',
          'filename',
          'dir',
          'dirname'
        ]
      },
      'options' => {
        'items' => {
          '$ref' => '#/definitions/option'
        },
        'type' => 'array'
      }
    },
    'properties' => {
      'abstract' => {
        'type' => 'string'
      },
      'appspec' => {
        'additionalProperties' => '',
        'properties' => {
          'version' => {
            'type' => 'number'
          }
        },
        'required' => [
          'version'
        ],
        'type' => 'object'
      },
      'class' => {
        'type' => 'string'
      },
      'description' => {
        'type' => 'string'
      },
      'markup' => {
        'type' => 'string'
      },
      'name' => {
        'type' => 'string'
      },
      'options' => {
        '$ref' => '#/definitions/options'
      },
      'parameters' => {
        '$ref' => '#/definitions/options'
      },
      'plugins' => {
        'items' => {
          'type' => 'string'
        },
        'type' => 'array'
      },
      'subcommands' => {
        'additionalProperties' => '',
        'patternProperties' => {
          '^[a-zA-Z0-9_]+$' => {
            '$ref' => '#/definitions/command'
          }
        },
        'type' => 'object'
      },
      'title' => {
        'type' => 'string'
      }
    },
    'required' => [
      'name',
      'appspec'
    ],
    'type' => 'object'
  };
  # END INLINE
  
  1;
APP_SPEC_SCHEMA

$fatpacked{"App/Spec/Subcommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SPEC_SUBCOMMAND';
  # ABSTRACT: Represents an App::Spec subcommand
  use strict;
  use warnings;
  package App::Spec::Subcommand;
  
  our $VERSION = '0.013'; # VERSION
  
  use App::Spec::Option;
  use App::Spec::Parameter;
  
  use Moo;
  
  with('App::Spec::Role::Command');
  
  has summary => ( is => 'ro' );
  has subcommand_required => ( is => 'ro' );
  
  sub default_plugins { }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Spec::Subcommand - Represents an App::Spec subcommand
  
  =head1 METHODS
  
  =over 4
  
  =item default_plugins
  
  Returns an empty list
  
  =back
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item summary, subcommand_required
  
  Items from the specification.
  
  =back
  
  =cut
APP_SPEC_SUBCOMMAND

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.14';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  my $have_xs;
  
  BEGIN
  {
      our $VERSION = '0.419';
      unless (defined($have_xs))
      {
          eval { require List::MoreUtils::XS; } unless $ENV{LIST_MOREUTILS_PP};
          die $@ if $@ && defined $ENV{LIST_MOREUTILS_PP} && $ENV{LIST_MOREUTILS_PP} == 0;
          $have_xs = 0+defined( $INC{'List/MoreUtils/XS.pm'});
      }
  
      use List::MoreUtils::PP qw();
  }
  
  use Exporter::Tiny qw();
  
  my @junctions = qw(any all none notall);
  my @v0_22     = qw(
    true false
    firstidx lastidx
    insert_after insert_after_string
    apply indexes
    after after_incl before before_incl
    firstval lastval
    each_array each_arrayref
    pairwise natatime
    mesh uniq
    minmax part
    _XScompiled
  );
  my @v0_24  = qw(bsearch);
  my @v0_33  = qw(sort_by nsort_by);
  my @v0_400 = qw(one any_u all_u none_u notall_u one_u
    firstres onlyidx onlyval onlyres lastres
    singleton bsearchidx
  );
  
  my @all_functions = (@junctions, @v0_22, @v0_24, @v0_33, @v0_400);
  
  no strict "refs";
  if ($have_xs)
  {
      my $x;
      for (@all_functions)
      {
          List::MoreUtils->can($_) or *$_ = $x if ($x = List::MoreUtils::XS->can($_));
      }
  }
  List::MoreUtils->can($_) or *$_ = List::MoreUtils::PP->can($_) for (@all_functions);
  use strict;
  
  my %alias_list = (
      v0_22 => {
          first_index => "firstidx",
          last_index  => "lastidx",
          first_value => "firstval",
          last_value  => "lastval",
          zip         => "mesh",
      },
      v0_33 => {
          distinct => "uniq",
      },
      v0_400 => {
          first_result  => "firstres",
          only_index    => "onlyidx",
          only_value    => "onlyval",
          only_result   => "onlyres",
          last_result   => "lastres",
          bsearch_index => "bsearchidx",
      },
  );
  
  our @ISA         = qw(Exporter::Tiny);
  our @EXPORT_OK   = (@all_functions, map { keys %$_ } values %alias_list);
  our %EXPORT_TAGS = (
      all         => \@EXPORT_OK,
      'like_0.22' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          none_u   => {-as => 'none'},
          notall_u => {-as => 'notall'},
          @v0_22,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.24' => [
          any_u    => {-as => 'any'},
          all_u    => {-as => 'all'},
          notall_u => {-as => 'notall'},
          'none',
          @v0_22,
          @v0_24,
          keys %{$alias_list{v0_22}},
      ],
      'like_0.33' => [
          @junctions,
          @v0_22,
          # v0_24 functions were omitted
          @v0_33,
          keys %{$alias_list{v0_22}},
          keys %{$alias_list{v0_33}},
      ],
  );
  
  for my $set (values %alias_list)
  {
      for my $alias (keys %$set)
      {
          no strict qw(refs);
          *$alias = __PACKAGE__->can($set->{$alias});
      }
  }
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      # import specific functions
  
      use List::MoreUtils qw(any uniq);
  
      if ( any { /foo/ } uniq @has_duplicates ) {
          # do stuff
      }
  
      # import everything
  
      use List::MoreUtils ':all';
  
      # import by API
  
      # has "original" any/all/none/notall behavior
      use List::MoreUtils ':like_0.22';
      # 0.22 + bsearch
      use List::MoreUtils ':like_0.24';
      # has "simplified" any/all/none/notall behavior + (n)sort_by
      use List::MoreUtils ':like_0.33';
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =head1 EXPORTS
  
  =head2 Default behavior
  
  Nothing by default. To import all of this module's symbols use the C<:all> tag.
  Otherwise functions can be imported by name as usual:
  
      use List::MoreUtils ':all';
  
      use List::MoreUtils qw{ any firstidx };
  
  Because historical changes to the API might make upgrading List::MoreUtils
  difficult for some projects, the legacy API is available via special import
  tags.
  
  =head2 Like version 0.22 (last release with original API)
  
  This API was available from 2006 to 2009, returning undef for empty lists on
  C<all>/C<any>/C<none>/C<notall>:
  
      use List::MoreUtils ':like_0.22';
  
  This import tag will import all functions available as of version 0.22.
  However, it will import C<any_u> as C<any>, C<all_u> as C<all>, C<none_u> as
  C<none>, and C<notall_u> as C<notall>.
  
  =head2 Like version 0.24 (first incompatible change)
  
  This API was available from 2010 to 2011.  It changed the return value of C<none>
  and added the C<bsearch> function.
  
      use List::MoreUtils ':like_0.24';
  
  This import tag will import all functions available as of version 0.24.
  However it will import C<any_u> as C<any>, C<all_u> as C<all>, and
  C<notall_u> as C<notall>.  It will import C<none> as described in
  the documentation below (true for empty list).
  
  =head2 Like version 0.33 (second incompatible change)
  
  This API was available from 2011 to 2014. It is widely used in several CPAN
  modules and thus it's closest to the current API.  It changed the return values
  of C<any>, C<all>, and C<notall>.  It added the C<sort_by> and C<nsort_by> functions
  and the C<distinct> alias for C<uniq>.  It omitted C<bsearch>.
  
      use List::MoreUtils ':like_0.33';
  
  This import tag will import all functions available as of version 0.33.  Note:
  it will not import C<bsearch> for consistency with the 0.33 API.
  
  =head1 FUNCTIONS
  
  =head2 Junctions
  
  =head3 I<Treatment of an empty list>
  
  There are two schools of thought for how to evaluate a junction on an
  empty list:
  
  =over
  
  =item *
  
  Reduction to an identity (boolean)
  
  =item *
  
  Result is undefined (three-valued)
  
  =back
  
  In the first case, the result of the junction applied to the empty list is
  determined by a mathematical reduction to an identity depending on whether
  the underlying comparison is "or" or "and".  Conceptually:
  
                      "any are true"      "all are true"
                      --------------      --------------
      2 elements:     A || B || 0         A && B && 1
      1 element:      A || 0              A && 1
      0 elements:     0                   1
  
  In the second case, three-value logic is desired, in which a junction
  applied to an empty list returns C<undef> rather than true or false 
  
  Junctions with a C<_u> suffix implement three-valued logic.  Those
  without are boolean.
  
  =head3 all BLOCK LIST
  
  =head3 all_u BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "All values are non-negative"
      if all { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<all> returns true (i.e. no values failed the condition)
  and C<all_u> returns C<undef>.
  
  Thus, C<< all_u(@list) >> is equivalent to C<< @list ? all(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<all_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 any BLOCK LIST
  
  =head3 any_u BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "At least one non-negative value"
      if any { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<any> returns false and C<any_u> returns C<undef>.
  
  Thus, C<< any_u(@list) >> is equivalent to C<< @list ? any(@list) : undef >>.
  
  =head3 none BLOCK LIST
  
  =head3 none_u BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
    print "No non-negative values"
      if none { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<none> returns true (i.e. no values failed the condition)
  and C<none_u> returns C<undef>.
  
  Thus, C<< none_u(@list) >> is equivalent to C<< @list ? none(@list) : undef >>.
  
  B<Note>: because Perl treats C<undef> as false, you must check the return value
  of C<none_u> with C<defined> or you will get the opposite result of what you
  expect.
  
  =head3 notall BLOCK LIST
  
  =head3 notall_u BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
    print "Not all values are non-negative"
      if notall { $_ >= 0 } ($x, $y, $z);
  
  For an empty LIST, C<notall> returns false and C<notall_u> returns C<undef>.
  
  Thus, C<< notall_u(@list) >> is equivalent to C<< @list ? notall(@list) : undef >>.
  
  =head3 one BLOCK LIST
  
  =head3 one_u BLOCK LIST
  
  Returns a true value if precisely one item in LIST meets the criterion
  given through BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "Precisely one value defined"
          if one { defined($_) } @list;
  
  Returns false otherwise.
  
  For an empty LIST, C<one> returns false and C<one_u> returns C<undef>.
  
  The expression C<one BLOCK LIST> is almost equivalent to
  C<1 == true BLOCK LIST>, except for short-cutting.
  Evaluation of BLOCK will immediately stop at the second true value.
  
  =head2 Transformation
  
  =head3 apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
    my @list = (1 .. 4);
    my @mult = apply { $_ *= 2 } @list;
    print "\@list = @list\n";
    print "\@mult = @mult\n";
    __END__
    @list = 1 2 3 4
    @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
    for (my @mult = @list) { $_ *= 2 }
  
  =head3 insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
    my @list = qw/This is a list/;
    insert_after { $_ eq "a" } "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
    my @list = qw/This is a list/;
    insert_after_string "a", "longer" => @list;
    print "@list";
    __END__
    This is a longer list
  
  =head3 pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
    @a = (1 .. 5);
    @b = (11 .. 15);
    @x = pairwise { $a + $b } @a, @b;     # returns 12, 14, 16, 18, 20
  
    # mesh with pairwise
    @a = qw/a b c/;
    @b = qw/1 2 3/;
    @x = pairwise { ($a, $b) } @a, @b;    # returns a, 1, b, 2, c, 3
  
  =head3 mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =head3 zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
    @x = qw/a b c d/;
    @y = qw/1 2 3 4/;
    @z = mesh @x, @y;         # returns a, 1, b, 2, c, 3, d, 4
  
    @a = ('x');
    @b = ('1', '2');
    @c = qw/zip zap zot/;
    @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =head3 uniq LIST
  
  =head3 distinct LIST
  
  Returns a new list by stripping duplicate values in LIST by comparing
  the values as hash keys, except that undef is considered separate from ''.
  The order of elements in the returned list is the same as in LIST. In
  scalar context, returns the number of unique elements in LIST.
  
    my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
    my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
    # returns "Mike", "Michael", "Richard", "Rick"
    my @n = distinct "Mike", "Michael", "Richard", "Rick", "Michael", "Rick"
    # returns "A8", "", undef, "A5", "S1"
    my @s = distinct "A8", "", undef, "A5", "S1", "A5", "A8"
    # returns "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C"
    my @w = uniq "Giulia", "Giulietta", undef, "", 156, "GTA", "GTV", 159, "Brera", "4C", "Giulietta", "Giulia"
  
  C<distinct> is an alias for C<uniq>.
  
  B<RT#49800> can be used to give feedback about this behavior.
  
  =head3 singleton
  
  Returns a new list by stripping values in LIST occurring more than once by
  comparing the values as hash keys, except that undef is considered separate
  from ''.  The order of elements in the returned list is the same as in LIST.
  In scalar context, returns the number of elements occurring only once in LIST.
  
    my @x = singleton 1,1,2,2,3,4,5 # returns 3 4 5
  
  =head2 Partitioning
  
  =head3 after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
    @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =head3 after_incl BLOCK LIST
  
  Same as C<after> but also includes the element for which BLOCK is true.
  
  =head3 before BLOCK LIST
  
  Returns a list of values of LIST up to (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =head3 before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =head3 part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
    my $i = 0;
    my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
    my @part = part { 2 } 1 .. 10;            # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
    my @part = part { -1 } 1 .. 10;
    __END__
    Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
    my @idx  = ( 0, 1, -1 );
    my $i    = 0;
    my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =head2 Iteration
  
  =head3 each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
    my $ea = each_array(@a, @b, @c);
    while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it returns
  the index of the last fetched set of values, as a scalar.
  
  =head3 each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =head3 natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
    my @x = ('a' .. 'g');
    my $it = natatime 3, @x;
    while (my @vals = $it->())
    {
      print "@vals\n";
    }
  
  This prints
  
    a b c
    d e f
    g
  
  =head2 Searching
  
  =head3 bsearch BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns a boolean value in scalar context. In list context, it returns the element
  if it was found, otherwise the empty list.
  
  =head3 bsearchidx BLOCK LIST
  
  =head3 bsearch_index BLOCK LIST
  
  Performs a binary search on LIST which must be a sorted list of values. BLOCK
  must return a negative value if the current element (stored in C<$_>) is smaller,
  a positive value if it is bigger and zero if it matches.
  
  Returns the index of found element, otherwise C<-1>.
  
  C<bsearch_index> is an alias for C<bsearchidx>.
  
  =head3 firstval BLOCK LIST
  
  =head3 first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_value> is an alias for C<firstval>.
  
  =head3 onlyval BLOCK LIST
  
  =head3 only_value BLOCK LIST
  
  Returns the only element in LIST for which BLOCK evaluates to true. Sets
  C<$_> for each item in LIST in turn. Returns C<undef> if no such element
  has been found.
  
  C<only_value> is an alias for C<onlyval>.
  
  =head3 lastval BLOCK LIST
  
  =head3 last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_value> is an alias for C<lastval>.
  
  =head3 firstres BLOCK LIST
  
  =head3 first_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<first_result> is an alias for C<firstres>.
  
  =head3 onlyres BLOCK LIST
  
  =head3 only_result BLOCK LIST
  
  Returns the result of BLOCK for the first element in LIST for which BLOCK
  evaluates to true. Sets C<$_> for each item in LIST in turn. Returns
  C<undef> if no such element has been found.
  
  C<only_result> is an alias for C<onlyres>.
  
  =head3 lastres BLOCK LIST
  
  =head3 last_result BLOCK LIST
  
  Returns the result of BLOCK for the last element in LIST for which BLOCK
  evaluates to true. Each element of LIST is set to C<$_> in turn. Returns
  C<undef> if no such element has been found.
  
  C<last_result> is an alias for C<lastres>.
  
  =head3 indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
    @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =head3 firstidx BLOCK LIST
  
  =head3 first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
    __END__
    item with index 1 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =head3 onlyidx BLOCK LIST
  
  =head3 only_index BLOCK LIST
  
  Returns the index of the only element in LIST for which the criterion
  in BLOCK is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 3, 4, 3, 2, 4);
      printf "uniqe index of item 2 in list is %i", onlyidx { $_ == 2 } @list;
      __END__
      unique index of item 2 in list is 4
  
  Returns C<-1> if either no such item or more than one of these
  has been found.
  
  C<only_index> is an alias for C<onlyidx>.
  
  =head3 lastidx BLOCK LIST
  
  =head3 last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
    my @list = (1, 4, 3, 2, 4, 6);
    printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
    __END__
    item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =head2 Sorting
  
  =head3 sort_by BLOCK LIST
  
  Returns the list of values sorted according to the string values returned by the
  KEYFUNC block or function. A typical use of this may be to sort objects according
  to the string value of some accessor, such as
  
    sort_by { $_->name } @people
  
  The key function is called in scalar context, being passed each value in turn as
  both $_ and the only argument in the parameters, @_. The values are then sorted
  according to string comparisons on the values returned.
  This is equivalent to
  
    sort { $a->name cmp $b->name } @people
  
  except that it guarantees the name accessor will be executed only once per value.
  One interesting use-case is to sort strings which may have numbers embedded in them
  "naturally", rather than lexically.
  
    sort_by { s/(\d+)/sprintf "%09d", $1/eg; $_ } @strings
  
  This sorts strings by generating sort keys which zero-pad the embedded numbers to
  some level (9 digits in this case), helping to ensure the lexical sort puts them
  in the correct order.
  
  =head3 nsort_by BLOCK LIST
  
  Similar to sort_by but compares its key values numerically.
  
  =head2 Counting and calculation
  
  =head3 true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
    printf "%i item(s) are defined", true { defined($_) } @list;
  
  =head3 false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
    printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =head3 minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 MAINTENANCE
  
  The maintenance goal is to preserve the documented semantics of the API;
  bug fixes that bring actual behavior in line with semantics are allowed.
  New API functions may be added over time.  If a backwards incompatible
  change is unavoidable, we will attempt to provide support for the legacy
  API using the same export tag mechanism currently in place.
  
  This module attempts to use few non-core dependencies. Non-core
  configuration and testing modules will be bundled when reasonable;
  run-time dependencies will be added only if they deliver substantial
  benefit.
  
  =head1 CONTRIBUTING
  
  While contributions are appreciated, a contribution should not cause more
  effort for the maintainer than the contribution itself saves (see
  L<Open Source Contribution Etiquette|http://tirania.org/blog/archive/2010/Dec-31.html>).
  
  To get more familiar where help could be needed - see L<List::MoreUtils::Contributing>.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  You can find documentation for this module with the perldoc command.
  
      perldoc List::MoreUtils
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<https://rt.cpan.org/Dist/Display.html?Name=List-MoreUtils>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/List-MoreUtils>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/dist/List-MoreUtils>
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/List-MoreUtils>
  
  =item * CPAN Search
  
  L<http://search.cpan.org/dist/List-MoreUtils/>
  
  =item * Git Repository
  
  L<https://github.com/perl5-utils/List-MoreUtils>
  
  =back
  
  =head2 Where can I go for help?
  
  If you have a bug report, a patch or a suggestion, please open a new
  report ticket at CPAN (but please check previous reports first in case
  your issue has already been addressed) or open an issue on GitHub.
  
  Report tickets should contain a detailed description of the bug or
  enhancement request and at least an easily verifiable way of
  reproducing the issue or fix. Patches are always welcome, too - and
  it's cheap to send pull-requests on GitHub. Please keep in mind that
  code changes are more likely accepted when they're bundled with an
  approving test.
  
  If you think you've found a bug then please read
  "How to Report Bugs Effectively" by Simon Tatham:
  L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
  
  =head2 Where can I go for help with a concrete version?
  
  Bugs and feature requests are accepted against the latest version
  only. To get patches for earlier versions, you need to get an
  agreement with a developer of your choice - who may or not report the
  issue and a suggested fix upstream (depends on the license you have
  chosen).
  
  =head2 Business support and maintenance
  
  Generally, in volunteered projects, there is no right for support.
  While every maintainer is happy to improve the provided software,
  spare time is limited.
  
  For those who have a use case which requires guaranteed support, one of
  the maintainers should be hired or contracted.  For business support you
  can contact Jens via his CPAN email address rehsackATcpan.org. Please
  keep in mind that business support is neither available for free nor
  are you eligible to receive any support based on the license distributed
  with this package.
  
  =head1 THANKS
  
  =head2 Tassilo von Parseval
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete.
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head2 Jens Rehsack
  
  Credits goes to all people contributing feedback during the v0.400
  development releases.
  
  Special thanks goes to David Golden who spent a lot of effort to develop
  a design to support current state of CPAN as well as ancient software
  somewhere in the dark. He also contributed a lot of patches to refactor
  the API frontend to welcome any user of List::MoreUtils - from ancient
  past to recently last used.
  
  Toby Inkster provided a lot of useful feedback for sane importer code
  and was a nice sounding board for API discussions.
  
  Peter Rabbitson provided a sane git repository setup containing entire
  package history.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>, L<List::AllUtils>, L<List::UtilsBy>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;
  
  use 5.008_001;
  use strict;
  use warnings;
  
  our $VERSION = '0.419';
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils::PP - Provide List::MoreUtils pure Perl implementation
  
  =head1 SYNOPSIS
  
    BEGIN { $ENV{LIST_MOREUTILS_PP} = 1; }
    use List::MoreUtils qw(:all);
  
  =cut
  
  sub any (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 if $f->();
      }
      return 0;
  }
  
  sub all (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 unless $f->();
      }
      return 1;
  }
  
  sub none (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 0 if $f->();
      }
      return 1;
  }
  
  sub notall (&@)
  {
      my $f = shift;
      foreach (@_)
      {
          return 1 unless $f->();
      }
      return 0;
  }
  
  sub one (&@)
  {
      my $f     = shift;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub any_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 1 foreach (@_);
      return 0;
  }
  
  sub all_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 0 foreach (@_);
      return 1;
  }
  
  sub none_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() and return 0 foreach (@_);
      return 1;
  }
  
  sub notall_u (&@)
  {
      my $f = shift;
      return if !@_;
      $f->() or return 1 foreach (@_);
      return 0;
  }
  
  sub one_u (&@)
  {
      my $f = shift;
      return if !@_;
      my $found = 0;
      foreach (@_)
      {
          $f->() and $found++ and return 0;
      }
      $found;
  }
  
  sub true (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() and ++$count foreach (@_);
      return $count;
  }
  
  sub false (&@)
  {
      my $f     = shift;
      my $count = 0;
      $f->() or ++$count foreach (@_);
      return $count;
  }
  
  sub firstidx (&@)
  {
      my $f = shift;
      foreach my $i ( 0 .. $#_ )
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub firstval (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub firstres (&@)
  {
      my $test = shift;
      foreach (@_)
      {
          my $testval = $test->();
          $testval and return $testval;
      }
      return undef;
  }
  
  sub onlyidx (&@)
  {
      my $f = shift;
      my $found;
      foreach my $i ( 0 .. $#_ )
      {
          local *_ = \$_[$i];
          $f->() or next;
          defined $found and return -1;
          $found = $i;
      }
      return defined $found ? $found : -1;
  }
  
  sub onlyval (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          $test->() or next;
          $result = $_;
          $found++ and return undef;
      }
      return $result;
  }
  
  sub onlyres (&@)
  {
      my $test   = shift;
      my $result = undef;
      my $found  = 0;
      foreach (@_)
      {
          my $rv = $test->() or next;
          $result = $rv;
          $found++ and return undef;
      }
      return $found ? $result : undef;
  }
  
  sub lastidx (&@)
  {
      my $f = shift;
      foreach my $i ( reverse 0 .. $#_ )
      {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastval (&@)
  {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- )
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub lastres (&@)
  {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- )
      {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $testval if $testval;
      }
      return undef;
  }
  
  sub insert_after (&$\@)
  {
      my ( $f, $val, $list ) = @_;
      my $c = &firstidx( $f, @$list );
      @$list = ( @{$list}[ 0 .. $c ], $val, @{$list}[ $c + 1 .. $#$list ], ) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@)
  {
      my ( $string, $val, $list ) = @_;
      my $c = firstidx { defined $_ and $string eq $_ } @$list;
      @$list = ( @{$list}[ 0 .. $c ], $val, @{$list}[ $c + 1 .. $#$list ], ) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@)
  {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@)
  {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do
      {
          my $x = $lag;
          $lag = $test->();
          $x;
      }, @_;
  }
  
  sub after_incl (&@)
  {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@)
  {
      my $test = shift;
      my $more = 1;
      grep $more &&= !$test->(), @_;
  }
  
  sub before_incl (&@)
  {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do
      {
          my $x = $lag;
          $lag = !$test->();
          $x;
      }, @_;
  }
  
  sub indexes (&@)
  {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub pairwise (&\@\@)
  {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local ( *A, *B ) = @_;
  
      # Localise $a, $b
      my ( $caller_a, $caller_b ) = do
      {
          my $pkg = caller();
          no strict 'refs';
          \*{ $pkg . '::a' }, \*{ $pkg . '::b' };
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B ? $#A : $#B;
  
      # This map expression is also the return value
      local ( *$caller_a, *$caller_b );
      map {
          # Assign to $a, $b as refs to caller's array elements
          ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
  
          # Perform the transformation
          $op->();
      } 0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      return each_arrayref(@_);
  }
  
  sub each_arrayref
  {
      my @list  = @_;    # The list of references to the arrays
      my $index = 0;     # Which one the caller will get next
      my $max   = 0;     # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach (@list)
      {
          unless ( ref $_ eq 'ARRAY' )
          {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if (@_)
          {
              my $method = shift;
              unless ( $method eq 'index' )
              {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0 || $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list;
        }
  }
  
  sub natatime ($@)
  {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
        }
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@)
  {
      my $max = -1;
      $max < $#$_ && ( $max = $#$_ ) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max;
  }
  
  sub uniq (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { defined $_ ? not $seen{ $k = $_ }++ : not $seen_undef++ } @_;
  }
  
  sub singleton (@)
  {
      my %seen = ();
      my $k;
      my $seen_undef;
      grep { 1 == ( defined $_ ? $seen{ $k = $_ } : $seen_undef ) }
        grep { defined $_ ? not $seen{ $k = $_ }++ : not $seen_undef++ } @_;
  }
  
  sub minmax (@)
  {
      return unless @_;
      my $min = my $max = $_[0];
  
      for ( my $i = 1; $i < @_; $i += 2 )
      {
          if ( $_[ $i - 1 ] <= $_[$i] )
          {
              $min = $_[ $i - 1 ] if $min > $_[ $i - 1 ];
              $max = $_[$i]       if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]       if $min > $_[$i];
              $max = $_[ $i - 1 ] if $max < $_[ $i - 1 ];
          }
      }
  
      if ( @_ & 1 )
      {
          my $i = $#_;
          if ( $_[ $i - 1 ] <= $_[$i] )
          {
              $min = $_[ $i - 1 ] if $min > $_[ $i - 1 ];
              $max = $_[$i]       if $max < $_[$i];
          }
          else
          {
              $min = $_[$i]       if $min > $_[$i];
              $max = $_[ $i - 1 ] if $max < $_[ $i - 1 ];
          }
      }
  
      return ( $min, $max );
  }
  
  sub part (&@)
  {
      my ( $code, @list ) = @_;
      my @parts;
      push @{ $parts[ $code->($_) ] }, $_ foreach @list;
      return @parts;
  }
  
  sub bsearch(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int( ( $i + $j ) / 2 );
  
          $k >= @_ and return;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0
            and return wantarray ? $_ : 1;
  
          if ( $rc < 0 )
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return;
  }
  
  sub bsearchidx(&@)
  {
      my $code = shift;
  
      my $rc;
      my $i = 0;
      my $j = @_;
      do
      {
          my $k = int( ( $i + $j ) / 2 );
  
          $k >= @_ and return -1;
  
          local *_ = \$_[$k];
          $rc = $code->();
  
          $rc == 0 and return $k;
  
          if ( $rc < 0 )
          {
              $i = $k + 1;
          }
          else
          {
              $j = $k - 1;
          }
      } until $i > $j;
  
      return -1;
  }
  
  sub sort_by(&@)
  {
      my ( $code, @list ) = @_;
      return map { $_->[0] }
        sort     { $a->[1] cmp $b->[1] }
        map { [ $_, scalar( $code->() ) ] } @list;
  }
  
  sub nsort_by(&@)
  {
      my ( $code, @list ) = @_;
      return map { $_->[0] }
        sort     { $a->[1] <=> $b->[1] }
        map { [ $_, scalar( $code->() ) ] } @list;
  }
  
  sub _XScompiled { 0 }
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Jens Rehsack E<lt>rehsack AT cpan.orgE<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  Copyright 2013 - 2017 by Jens Rehsack
  
  All code added with 0.417 or later is licensed under the Apache License,
  Version 2.0 (the "License"); you may not use this file except in compliance
  with the License. You may obtain a copy of the License at
  
   http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  All code until 0.416 is licensed under the same terms as Perl itself,
  either Perl version 5.8.4 or, at your option, any later version of
  Perl 5 you may have available.
  
  =cut
  
  1;
LIST_MOREUTILS_PP

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module _maybe_load_module _install_coderef);
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quoted_from_sub quotify sanitize_identifier);
  use Scalar::Util 'blessed';
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::_Utils) }
  use overload ();
  BEGIN {
    *_CAN_WEAKEN_READONLY = (
      "$]" < 5.008_003 or $ENV{MOO_TEST_PRE_583}
    ) ? sub(){0} : sub(){1};
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  BEGIN {
    package
      Method::Generate::Accessor::_Generated;
    $Carp::Internal{+__PACKAGE__} = 1;
  }
  
  my $module_name_only = qr/\A$Module::Runtime::module_name_rx\z/;
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    croak "You cannot overwrite a locally defined method ($method) with "
      . ( $type || 'an accessor' );
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      no_defer => 1,
      package => 'Method::Generate::Accessor::_Generated',
      %{ $quote_opts||{} },
    };
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    croak "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless exists $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      croak "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      croak "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ $module_name_only;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
    if (($spec->{coerce}||0) eq 1) {
      my $isa = $spec->{isa};
      if (blessed $isa and $isa->can('coercion')) {
        $spec->{coerce} = $isa->coercion;
      } elsif (blessed $isa and $isa->can('coerce')) {
        $spec->{coerce} = sub { $isa->coerce(@_) };
      } else {
        croak "Invalid coercion for $into->$name - no appropriate type constraint";
      }
    }
  
    foreach my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name",
          'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      foreach my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && defined &{"${into}::${reader}"};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    Carp::croak("'.$reader.' is a read-only accessor") if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && defined &{"${into}::${accessor}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${writer}"};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && defined &{"${into}::${pred}"};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$pred} =
          quote_sub "${into}::${pred}"
            => $self->_generate_simple_has('$_[0]', $name, $spec)."\n"
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $builder = delete $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $builder );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && defined &{"${into}::${cl}"};
      $self->{captures} = {};
      $methods{$cl} =
        quote_sub "${into}::${cl}"
          => $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          require Moo::Role;
          _load_module $hspec;
          map [ $_ => $_ ], Moo::Role->methods_provided_by($hspec)
        } else {
          croak "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && defined &{"${into}::${proxy}"};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}"
            => $self->_generate_delegation($asserter, $target, \@args)
            => delete $self->{captures}
            => $quote_opts
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      _die_overwrite($into, $asserter, 'an asserter')
        if !$spec->{allow_overwrite} && defined &{"${into}::${asserter}"};
      local $self->{captures} = {};
      $methods{$asserter} =
        quote_sub "${into}::${asserter}"
          => $self->_generate_asserter($name, $spec)
          => delete $self->{captures}
          => $quote_opts
        ;
    }
    \%methods;
  }
  
  sub merge_specs {
    my ($self, @specs) = @_;
    my $spec = shift @specs;
    for my $old_spec (@specs) {
      foreach my $key (keys %$old_spec) {
        if ($key eq 'handles') {
        }
        elsif ($key eq 'moosify') {
          $spec->{$key} = [
            map { ref $_ eq 'ARRAY' ? @$_ : $_ }
            grep defined,
            ($old_spec->{$key}, $spec->{$key})
          ];
        }
        elsif (!exists $spec->{$key}) {
          $spec->{$key} = $old_spec->{$key};
        }
      }
    }
    $spec;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_default {
    my ($self, $name, $spec) = @_;
    $spec->{builder} or exists $spec->{default} or (($spec->{is}||'') eq 'lazy');
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\quotify $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\quotify $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa} ?
         "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n"
    );
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
      : quotify $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_simple_get(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    my ($me, $source) = ('$_[0]', '$_[1]');
    if ($self->is_simple_set($name, $spec)) {
      return $self->_generate_simple_set($me, $name, $spec, $source);
    }
  
    my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
    if ($coerce) {
      $source = $self->_generate_coerce($name, $source, $coerce);
    }
    if ($isa_check) {
      'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check($name, '$value', $isa_check)."),\n"
      .'  ('.$self->_generate_simple_set($me, $name, $spec, '$value')."),\n"
      .($trigger
        ? '('.$self->_generate_trigger($name, $me, '$value', $trigger)."),\n"
        : '')
      .'  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      ."}";
    }
    elsif ($trigger) {
      my $set = $self->_generate_simple_set($me, $name, $spec, $source);
      "scalar (\n"
      . '  ('.$self->_generate_trigger($name, $me, "($set)", $trigger)."),\n"
      . '  ('.$self->_generate_simple_get($me, $name, $spec)."),\n"
      . ")";
    }
    else {
      '('.$self->_generate_simple_set($me, $name, $spec, $source).')';
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return quotify($name) if !defined($init_arg) or $init_arg eq $name;
    return quotify($name).' (constructor argument: '.quotify($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce),
      1,
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _wrap_attr_exception {
    my ($self, $name, $step, $arg, $code, $want_return) = @_;
    my $prefix = quotify("${step} for "._attr_desc($name, $arg).' failed: ');
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'."\n"
    .'    init_arg => '.quotify($arg).",\n"
    .'    name     => '.quotify($name).",\n"
    .'    step     => '.quotify($step).",\n"
    ."  };\n"
    .($want_return ? '  (my $_return),'."\n" : '')
    .'  (my $_error), (my $_old_error = $@);'."\n"
    ."  (eval {\n"
    .'    ($@ = $_old_error),'."\n"
    .'    ('
    .($want_return ? '$_return ='."\n" : '')
    .$code."),\n"
    ."    1\n"
    ."  } or\n"
    .'    $_error = CORE::ref $@ ? $@ : '.$prefix.'.$@);'."\n"
    .'  ($@ = $_old_error),'."\n"
    .'  (defined $_error and CORE::die $_error);'."\n"
    .($want_return ? '  $_return;'."\n" : '')
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_wrap_attr_exception(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.sanitize_identifier($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify($code, $values,
          Sub::Quote::capture_unroll($cap_name, $captures, 6), $local);
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.sanitize_identifier($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name { sanitize_identifier($_[1]) }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
  
    my $has_default = $self->has_eager_default($name, $spec);
    if (!($has_default || $test)) {
      return '';
    }
    if ($has_default) {
      my $get_default = $self->_generate_get_default($me, $name, $spec);
      $source =
        $test
          ? "(\n  ${test}\n"
              ."   ? ${source}\n   : "
              .$get_default
              .")"
          : $get_default;
    }
    if ($spec->{coerce}) {
      $source = $self->_generate_coerce(
        $name, $source,
        $spec->{coerce}, $init_arg
      )
    }
    if ($spec->{isa}) {
      $source = 'scalar do { my $value = '.$source.";\n"
      .'  ('.$self->_generate_isa_check(
          $name, '$value', $spec->{isa}, $init_arg
        )."),\n"
      ."  \$value\n"
      ."}\n";
    }
    my $set = $self->_generate_simple_set($me, $name, $spec, $source);
    my $trigger = $spec->{trigger} ? $self->_generate_trigger(
      $name, $me, $self->_generate_simple_get($me, $name, $spec),
      $spec->{trigger}
    ) : undef;
    if ($has_default) {
      "($set)," . ($trigger && $test ? "($test and $trigger)," : '') . "\n";
    }
    else {
      "($test and ($set)" . ($trigger ? ", ($trigger)" : '') . "),\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = quotify $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      # &Internals::SvREADONLY($foo, 0);
      # Scalar::Util::weaken($foo);
      # &Internals::SvREADONLY($foo, 1);
      #
      # but requires Internal functions and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = _CAN_WEAKEN_READONLY
        ? "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }"
        : <<"EOC"
          ( eval { Scalar::Util::weaken($simple); 1 }
            ? do { no warnings 'void'; $get }
            : do {
              if( \$@ =~ /Modification of a read-only value attempted/) {
                require Carp;
                Carp::croak( sprintf (
                  'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                  $name_str,
                ) );
              } else {
                die \$@;
              }
            }
          )
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
    my $name_str = quotify($name);
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  ".$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
     ."    or Carp::croak(q{Attempted to access '}.${name_str}.q{' but it is not set});\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using quotify
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      croak "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      croak "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL"
      => join('',
        $self->_handle_subbuild($into),
        qq{    my \$self = shift;\n},
        $self->buildall_body_for($into, '$self', '@_'),
        qq{    return \$self\n},
      )
      => {}
      => { no_defer => 1 }
    ;
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{mro::get_linear_isa($into)};
    '    (('.$args.')[0]->{__no_BUILD__} or ('."\n"
    .join('', map qq{      ${me}->${_}(${args}),\n}, @builds)
    ."    )),\n";
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use Moo::_strictures;
  use Sub::Quote qw(quote_sub quotify);
  use Sub::Defer;
  use Moo::_Utils qw(_getstash _getglob);
  use Moo::_mro;
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  use Carp::Heavy ();
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  BEGIN {
    local $Moo::sification::disabled = 1;
    require Moo;
    Moo->import;
  }
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    $self->assert_constructor;
    my $specs = $self->{attribute_specs}||={};
    my $ag = $self->accessor_generator;
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        croak "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        $ag->merge_specs($new_spec, $old_spec);
      }
      if ($new_spec->{required}
        && !(
          $ag->has_default($name, $new_spec)
          || !exists $new_spec->{init_arg}
          || defined $new_spec->{init_arg}
        )
      ) {
        croak "You cannot have a required attribute (${name})"
          . " without a default, builder, or an init_arg";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    $self->assert_constructor;
    my $package = $self->{package};
    my (undef, @isa) = @{mro::get_linear_isa($package)};
    my $isa = join ',', @isa;
    my (undef, $from_file, $from_line) = caller(Carp::short_error_loc());
    my $constructor = defer_sub "${package}::new" => sub {
      my (undef, @new_isa) = @{mro::get_linear_isa($package)};
      if (join(',', @new_isa) ne $isa) {
        my ($expected_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa;
        my ($found_new) = grep { *{_getglob($_.'::new')}{CODE} } @new_isa;
        if (($found_new||'') ne ($expected_new||'')) {
          $found_new ||= 'none';
          $expected_new ||= 'none';
          croak "Expected parent constructor of $package to be"
          . " $expected_new, but found $found_new: changing the inheritance"
          . " chain (\@ISA) at runtime (after $from_file line $from_line) is unsupported";
        }
      }
  
      my $constructor = $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1, no_defer => 1 }
      );
      $self->{inlined} = 1;
      weaken($self->{constructor} = $constructor);
      $constructor;
    };
    $self->{inlined} = 0;
    weaken($self->{constructor} = $constructor);
    $self;
  }
  
  sub current_constructor {
    my ($self, $package) = @_;
    return *{_getglob("${package}::new")}{CODE};
  }
  
  sub assert_constructor {
    my ($self) = @_;
    my $package = $self->{package} or return 1;
    my $current = $self->current_constructor($package)
      or return 1;
    my $constructor = $self->{constructor}
      or croak "Unknown constructor for $package already exists";
    croak "Constructor for $package has been replaced with an unknown sub"
      if $constructor != $current;
    croak "Constructor for $package has been inlined and cannot be updated"
      if $self->{inlined};
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $quote_opts = {
      %{$quote_opts||{}},
      package => $into,
    };
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
  
    my $into_buildargs = $into->can('BUILDARGS');
  
    my $body
      = '    my $invoker = CORE::shift();'."\n"
      . '    my $class = CORE::ref($invoker) ? CORE::ref($invoker) : $invoker;'."\n"
      . $self->_handle_subconstructor($into, $name)
      . ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS
        ? $self->_generate_args_via_buildargs
        : $self->_generate_args
      )
      . $self->_check_required($spec)
      . '    my $new = '.$self->construction_string.";\n"
      . $self->_assign_new($spec)
      . ( $into->can('BUILD')
        ? $self->buildall_generator->buildall_body_for( $into, '$new', '$args' )
        : ''
      )
      . '    return $new;'."\n";
  
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.quotify($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    Carp::croak("BUILDARGS did not return a hashref") unless CORE::ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args = scalar @_ == 1
        ? CORE::ref $_[0] eq 'HASH'
          ? { %{ $_[0] } }
          : Carp::croak("Single parameters to new() must be a HASH ref"
              . " data => ". $_[0])
        : @_ % 2
          ? Carp::croak("The new() method for $class expects a hash reference or a"
              . " key/value list. You passed an odd number of arguments")
          : {@_}
      ;
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg = $test{$_};
      my $arg_key = quotify($arg);
      my $test = defined $arg ? "exists \$args->{$arg_key}" : undef;
      my $source = defined $arg ? "\$args->{$arg_key}" : undef;
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $arg,
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or exists $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, '
      .join(', ', map quotify($_), @required_init).') {'."\n"
      .q{      Carp::croak("Missing required arguments: ".CORE::join(', ', sort @missing));}."\n"
      ."    }\n";
  }
  
  # bootstrap our own constructor
  sub new {
    my $class = shift;
    delete _getstash(__PACKAGE__)->{new};
    bless $class->BUILDARGS(@_), $class;
  }
  Moo->_constructor_maker_for(__PACKAGE__)
  ->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'bare' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'bare' },
  );
  if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
    Moo::HandleMoose::inject_fake_metaclass_for(__PACKAGE__);
  }
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use Moo::_strictures;
  use Moo::Object ();
  BEGIN { our @ISA = qw(Moo::Object) }
  use Sub::Quote qw(quote_sub quotify);
  use Moo::_Utils qw(_getglob);
  use Moo::_mro;
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Devel::GlobalDestruction;
        eval {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
        };
        $@;
      };
  
      # fatal warnings+die in DESTROY = bad times (perl rt#123398)
      no warnings FATAL => 'all';
      use warnings 'all';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{mro::get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.quotify($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use Moo::_strictures;
  use Moo::_mro;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _set_loaded
    _unimport_coderefs
  );
  use Carp qw(croak);
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Constructor
      Method::Generate::Accessor
      Moo::sification
      Moo::_Utils
      Moo::Role
    );
  }
  
  our $VERSION = '2.003002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
  
    strict->import;
    warnings->import;
  
    if ($INC{'Role/Tiny.pm'} and Role::Tiny->is_role($target)) {
      croak "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak "Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_;
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{'Role/Tiny.pm'} && Role::Tiny->is_role($superclass)) {
        croak "Can't extend role '$superclass'";
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      $old->assert_constructor;
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              require Sub::Defer;
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
  
      my %construct_opts = (
        package => $target,
        accessor_generator => $class->_accessor_maker_for($target),
        subconstructor_handler => (
          '      if ($Moo::MAKERS{$class}) {'."\n"
          .'        if ($Moo::MAKERS{$class}{constructor}) {'."\n"
          .'          package '.$target.';'."\n"
          .'          return $invoker->SUPER::new(@_);'."\n"
          .'        }'."\n"
          .'        '.$class.'->_constructor_maker_for($class);'."\n"
          .'        return $invoker->new(@_)'.";\n"
          .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
          .'        return $meta->new_object('."\n"
          .'          $class->can("BUILDARGS") ? $class->BUILDARGS(@_)'."\n"
          .'                      : $class->Moo::Object::BUILDARGS(@_)'."\n"
          .'        );'."\n"
          .'      }'."\n"
        ),
      );
  
      my $con;
      my @isa = @{mro::get_linear_isa($target)};
      shift @isa;
      if (my ($parent_new) = grep { *{_getglob($_.'::new')}{CODE} } @isa) {
        if ($parent_new eq 'Moo::Object') {
          # no special constructor needed
        }
        elsif (my $makers = $MAKERS{$parent_new}) {
          $con = $makers->{constructor};
          $construct_opts{construction_string} = $con->construction_string
            if $con;
        }
        elsif ($parent_new->can('BUILDALL')) {
          $construct_opts{construction_builder} = sub {
            my $inv = $target->can('BUILDARGS') ? '' : 'Moo::Object::';
            'do {'
            .'  my $args = $class->'.$inv.'BUILDARGS(@_);'
            .'  $args->{__no_BUILD__} = 1;'
            .'  $invoker->'.$target.'::SUPER::new($args);'
            .'}'
          };
        }
        else {
          $construct_opts{construction_builder} = sub {
            '$invoker->'.$target.'::SUPER::new('
              .($target->can('FOREIGNBUILDARGS') ?
                '$class->FOREIGNBUILDARGS(@_)' : '@_')
              .')'
          };
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(%construct_opts)
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
    package Cat::Food;
  
    use Moo;
    use strictures 2;
    use namespace::clean;
  
    sub feed_lion {
      my $self = shift;
      my $amount = shift || 1;
  
      $self->pounds( $self->pounds - $amount );
    }
  
    has taste => (
      is => 'ro',
    );
  
    has brand => (
      is  => 'ro',
      isa => sub {
        die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
      },
    );
  
    has pounds => (
      is  => 'rw',
      isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
    );
  
    1;
  
  And elsewhere:
  
    my $full = Cat::Food->new(
        taste  => 'DELICIOUS.',
        brand  => 'SWEET-TREATZ',
        pounds => 10,
    );
  
    $full->feed_lion;
  
    say $full->pounds;
  
  =head1 DESCRIPTION
  
  C<Moo> is an extremely light-weight Object Orientation system. It allows one to
  concisely define objects and roles with a convenient syntax that avoids the
  details of Perl's object system.  C<Moo> contains a subset of L<Moose> and is
  optimised for rapid startup.
  
  C<Moo> avoids depending on any XS modules to allow for simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite --
  two thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead to provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  But if you don't want to use L<Moose>, you may not want "less metaprotocol"
  like L<Mouse> offers, but you probably want "no metaprotocol", which is what
  Moo provides. C<Moo> is ideal for some situations where deployment or startup
  time precludes using L<Moose> and L<Mouse>:
  
  =over 2
  
  =item a command line or CGI script where fast startup is essential
  
  =item code designed to be deployed as a single file via L<App::FatPacker>
  
  =item a CPAN module that may be used by others in the above situations
  
  =back
  
  C<Moo> maintains transparent compatibility with L<Moose> so if you install and
  load L<Moose> you can use Moo classes and roles in L<Moose> code without
  modification.
  
  Moo -- Minimal Object Orientation -- aims to make it smooth to upgrade to
  L<Moose> when you need more than the minimal features offered by Moo.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without modification.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  L<Moo> classes and roles, so that in Moose classes C<< isa => 'MyMooClass' >>
  and C<< isa => 'MyMooRole' >> work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  Extending a L<Mouse> class or consuming a L<Mouse::Role> will also work. But
  note that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  global and turns the mechanism off entirely so don't put this in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it will be used
  to generate simple accessors, readers, and writers for better performance.
  Simple accessors are those without lazy defaults, type checks/coercions, or
  triggers.  Simple readers are those without lazy defaults. Readers and writers
  generated by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 PUBLIC METHODS
  
  Moo provides several methods to any class using it.
  
  =head2 new
  
    Foo::Bar->new( attr1 => 3 );
  
  or
  
    Foo::Bar->new({ attr1 => 3 });
  
  The constructor for the class.  By default it will accept attributes either as a
  hashref, or a list of key value pairs.  This can be customized with the
  L</BUILDARGS> method.
  
  =head2 does
  
    if ($foo->does('Some::Role1')) {
      ...
    }
  
  Returns true if the object composes in the passed role.
  
  =head2 DOES
  
    if ($foo->DOES('Some::Role1') || $foo->DOES('Some::Class1')) {
      ...
    }
  
  Similar to L</does>, but will also return true for both composed roles and
  superclasses.
  
  =head2 meta
  
    my $meta = Foo::Bar->meta;
    my @methods = $meta->get_method_list;
  
  Returns an object that will behave as if it is a
  L<Moose metaclass|Moose::Meta::Class> object for the class. If you call
  anything other than C<make_immutable> on it, the object will be transparently
  upgraded to a genuine L<Moose::Meta::Class> instance, loading Moose in the
  process if required. C<make_immutable> itself is a no-op, since we generate
  metaclasses that are already immutable, and users converting from Moose had
  an unfortunate tendency to accidentally load Moose by calling it.
  
  =head1 LIFECYCLE METHODS
  
  There are several methods that you can define in your class to control
  construction and destruction of objects.  They should be used rather than trying
  to modify C<new> or C<DESTROY> yourself.
  
  =head2 BUILDARGS
  
    around BUILDARGS => sub {
      my ( $orig, $class, @args ) = @_;
  
      return { attr1 => $args[0] }
        if @args == 1 && !ref $args[0];
  
      return $class->$orig(@args);
    };
  
    Foo::Bar->new( 3 );
  
  This class method is used to transform the arguments to C<new> into a hash
  reference of attribute values.
  
  The default implementation accepts a hash or hash reference of named parameters.
  If it receives a single argument that isn't a hash reference it will throw an
  error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
    sub FOREIGNBUILDARGS {
      my ( $class, $options ) = @_;
      return $options->{foo};
    }
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as L</BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
    sub BUILD {
      my ($self, $args) = @_;
      die "foo and bar cannot be used at the same time"
        if exists $args->{foo} && exists $args->{bar};
    }
  
  On object creation, any C<BUILD> methods in the class's inheritance hierarchy
  will be called on the object and given the results of L</BUILDARGS>.  They each
  will be called in order from the parent classes down to the child, and thus
  should not themselves call the parent's method.  Typically this is used for
  object validation or possibly logging.
  
  =head2 DEMOLISH
  
    sub DEMOLISH {
      my ($self, $in_global_destruction) = @_;
      ...
    }
  
  When an object is destroyed, any C<DEMOLISH> methods in the inheritance
  hierarchy will be called on the object.  They are given boolean to inform them
  if global destruction is in progress, and are called from the child class upwards
  to the parent.  This is similar to L</BUILD> methods but in the opposite order.
  
  Note that this is implemented by a C<DESTROY> method, which is only created on
  on the first construction of an object of your class.  This saves on overhead for
  classes that are never instantiated or those without C<DEMOLISH> methods.  If you
  try to define your own C<DESTROY>, this will cause undefined results.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
    extends 'Parent::Class';
  
  Declares a base class. Multiple superclasses can be passed for multiple
  inheritance but please consider using L<roles|Moo::Role> instead.  The class
  will be loaded but no errors will be triggered if the class can't be found and
  there are already subs in the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
    with 'Some::Role1';
  
  or
  
    with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles cannot be composed because they
  have conflicting method definitions.  The roles will be loaded using the same
  mechanism as C<extends> uses.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class.
  
    package Foo;
    use Moo;
    has 'attr' => (
      is => 'ro'
    );
  
    package Bar;
    use Moo;
    extends 'Foo';
    has '+attr' => (
      default => sub { "blah" },
    );
  
  Using the C<+> notation, it's possible to override an attribute.
  
    has [qw(attr1 attr2 attr3)] => (
      is => 'ro',
    );
  
  Using an arrayref with multiple attribute names, it's possible to declare
  multiple attributes with the same options.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item C<is>
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> stands for "read-only" and generates an accessor that dies if you attempt
  to write to it - i.e.  a getter only - by defaulting C<reader> to the name of
  the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> stands for "read-write protected" and generates a reader like C<ro>, but
  also sets C<writer> to C<_set_${attribute_name}> for attributes that are
  designed to be written from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> stands for "read-write" and generates a normal getter/setter by
  defaulting the C<accessor> to the name of the attribute specified.
  
  =item C<isa>
  
  Takes a coderef which is used to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
    use Scalar::Util qw(looks_like_number);
    ...
    isa => sub {
      die "$_[0] is not a number!" unless looks_like_number $_[0]
    },
  
  Note that the return value for C<isa> is discarded. Only if the sub dies does
  type validation fail.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<Moose> compatible or L<MooseX::Types> style named types, look at
  L<Type::Tiny>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item C<coerce>
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always execute your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  If the C<isa> option is a blessed object providing a C<coerce> or
  C<coercion> method, then the C<coerce> option may be set to just C<1>.
  
  =item C<handles>
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a L<role|Moo::Role> that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
    handles => [ qw( one two ) ]
  
  Takes a hashref
  
    handles => {
      un => 'one',
    }
  
  =item C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. The coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<default>
  
  Takes a coderef which will get called with $self as its only argument to
  populate an attribute if no value for that attribute was supplied to the
  constructor. Alternatively, if the attribute is lazy, C<default> executes when
  the attribute is first retrieved if no value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  B<NOTE:> If the attribute is C<lazy>, it will be regenerated from C<default> or
  C<builder> the next time it is accessed. If it is not lazy, it will be C<undef>.
  
  =item C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on object instantiation.
  
  =item C<reader>
  
  The name of the method that returns the value of the attribute.  If you like
  Java style methods, you might set this to C<get_foo>
  
  =item C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened. Use this when circular references, which cause memory leaks, are
  possible.
  
  =item C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
    before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 around
  
    around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... }; >> for full
  documentation.
  
  =head2 after
  
    after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... }; >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
    package Record;
  
    use Digest::MD5 qw(md5_hex);
  
    use Moo;
    use namespace::clean;
  
    has name => (is => 'ro', required => 1);
    has id => (is => 'lazy');
    sub _build_id {
      my ($self) = @_;
      return md5_hex($self->name);
    }
  
    1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> Older versions of L<namespace::autoclean> would
  inflate Moo classes to full L<Moose> classes, losing the benefits of Moo.  If
  you want to use L<namespace::autoclean> with a Moo class, make sure you are
  using version 0.16 or newer.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, L<Type::Tiny> can provide types, type libraries, and
  will work seamlessly with both L<Moo> and L<Moose>.  L<Type::Tiny> can be
  considered the successor to L<MooseX::Types> and provides a similar API, so
  that you can write
  
    use Types::Standard qw(Int);
    has days_to_live => (is => 'ro', isa => Int);
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you need
  L<Moose> - Moo is small because it explicitly does not provide a metaprotocol.
  However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and
  L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  Handling of warnings: when you C<use Moo> we enable strict and warnings, in a
  similar way to Moose. The authors recommend the use of C<strictures>, which
  enables FATAL warnings, and several extra pragmas when used in development:
  L<indirect>, L<multidimensional>, and L<bareword::filehandles>.
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
    package MyClass;
    use Moo;
    use strictures 2;
  
  The nearest L<Moose> invocation would be:
  
    package MyClass;
  
    use Moose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
    package MyClass;
  
    use Moose;
    use MooseX::NonMoose;
    use warnings FATAL => "all";
    use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
    __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. BurzyÅ„ski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari MannsÃ¥ker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  bubaflub - Bob Kuo (cpan:BUBAFLUB) <bubaflub@cpan.org>
  
  ether = Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2015 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  use Moo::_strictures;
  use Moo::_Utils qw(_getstash);
  use Sub::Quote qw(quotify);
  use Carp qw(croak);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', keys %Moo::MAKERS;
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
    @Moo::HandleMoose::FakeMeta::ISA = 'Moose::Meta::Method::Meta';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    require Sub::Defer;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $am_class, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, 0, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, 1, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, 0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    {
      local $DID_INJECT{$name} = 1;
      foreach my $spec (values %$attr_specs) {
        if (my $inflators = delete $spec->{moosify}) {
          $_->($spec) for @$inflators;
        }
      }
  
      my %methods
        = %{($am_role ? 'Moo::Role' : 'Moo')->_concrete_methods_of($name)};
  
      # if stuff gets added afterwards, _maybe_reset_handlemoose should
      # trigger the recreation of the metaclass but we need to ensure the
      # Moo::Role cache is cleared so we don't confuse Moo itself.
      if (my $info = $Moo::Role::INFO{$name}) {
        delete $info->{methods};
      }
  
      # needed to ensure the method body is stable and get things named
      $methods{$_} = Sub::Defer::undefer_sub($methods{$_})
        for
          grep $_ ne 'new',
          keys %methods;
      my @attrs;
      {
        # This local is completely not required for roles but harmless
        local @{_getstash($name)}{keys %methods};
        my %seen_name;
        foreach my $attr_name (@$attr_order) {
          $seen_name{$attr_name} = 1;
          my %spec = %{$attr_specs->{$attr_name}};
          my %spec_map = (
            map { $_->name => $_->init_arg||$_->name }
            (
              (grep { $_->has_init_arg }
                $meta->attribute_metaclass->meta->get_all_attributes),
              grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
              map {
                my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                            ->meta;
                map $meta->get_attribute($_), $meta->get_attribute_list
              }  @{$spec{traits}||[]}
            )
          );
          # have to hard code this because Moose's role meta-model is lacking
          $spec_map{traits} ||= 'traits';
  
          $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
          my $coerce = $spec{coerce};
          if (my $isa = $spec{isa}) {
            my $tc = $spec{isa} = do {
              if (my $mapped = $TYPE_MAP{$isa}) {
                my $type = $mapped->();
                unless ( Scalar::Util::blessed($type)
                    && $type->isa("Moose::Meta::TypeConstraint") ) {
                  croak "error inflating attribute '$attr_name' for package '$name': "
                    ."\$TYPE_MAP{$isa} did not return a valid type constraint'";
                }
                $coerce ? $type->create_child_type(name => $type->name) : $type;
              } else {
                Moose::Meta::TypeConstraint->new(
                  constraint => sub { eval { &$isa; 1 } }
                );
              }
            };
            if ($coerce) {
              $tc->coercion(Moose::Meta::TypeCoercion->new)
                ->_compiled_type_coercion($coerce);
              $spec{coerce} = 1;
            }
          } elsif ($coerce) {
            my $attr = quotify($attr_name);
            my $tc = Moose::Meta::TypeConstraint->new(
                      constraint => sub { die "This is not going to work" },
                      inlined => sub {
                          'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                      },
                    );
            $tc->coercion(Moose::Meta::TypeCoercion->new)
              ->_compiled_type_coercion($coerce);
            $spec{isa} = $tc;
            $spec{coerce} = 1;
          }
          %spec =
            map { $spec_map{$_} => $spec{$_} }
            grep { exists $spec_map{$_} }
            keys %spec;
          push @attrs, $meta->add_attribute($attr_name => %spec);
        }
        foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
          foreach my $attr ($mouse->get_all_attributes) {
            my %spec = %{$attr};
            delete @spec{qw(
              associated_class associated_methods __METACLASS__
              provides curries
            )};
            my $attr_name = delete $spec{name};
            next if $seen_name{$attr_name}++;
            push @attrs, $meta->add_attribute($attr_name => %spec);
          }
        }
      }
      foreach my $meth_name (keys %methods) {
        my $meth_code = $methods{$meth_name};
        $meta->add_method($meth_name, $meth_code);
      }
  
      if ($am_role) {
        my $info = $Moo::Role::INFO{$name};
        $meta->add_required_methods(@{$info->{requires}});
        foreach my $modifier (@{$info->{modifiers}}) {
          my ($type, @args) = @$modifier;
          my $code = pop @args;
          $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
        }
      }
      elsif ($am_class) {
        foreach my $attr (@attrs) {
          foreach my $method (@{$attr->associated_methods}) {
            $method->{body} = $name->can($method->name);
          }
        }
        bless(
          $meta->find_method_by_name('new'),
          'Moo::HandleMoose::FakeConstructor',
        );
        my $meta_meth;
        if (
          $meta_meth = $meta->find_method_by_name('meta')
          and $meta_meth->body == \&Moo::Object::meta
        ) {
          bless($meta_meth, 'Moo::HandleMoose::FakeMeta');
        }
        # a combination of Moo and Moose may bypass a Moo constructor but still
        # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
        # global destruction.
        require Method::Generate::DemolishAll;
      }
      $meta->add_role(Class::MOP::class_of($_))
        for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
          keys %{$Moo::Role::APPLIED_TO{$name}}
    }
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  use Moo::_strictures;
  use Carp ();
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    my $self = shift;
    Carp::croak "Can't call $meth without object instance"
      if !ref $self;
    Carp::croak "Can't inflate Moose metaclass with Moo::sification disabled"
      if $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->$meth(@_)
  }
  sub can {
    my $self = shift;
    return $self->SUPER::can(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->can(@_)
  }
  sub isa {
    my $self = shift;
    return $self->SUPER::isa(@_)
      if !ref $self or $Moo::sification::disabled;
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for($self->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use Moo::_strictures;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  use Config;
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)([A-Z]+)\(0x([0-9a-zA-Z]+)\)$/) {
      my $type = $1;
      my $id = do { no warnings 'portable'; hex "$2" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref or Scalar::Util::reftype($ref) ne $type) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  if ($Config{useithreads}) {
    my @types = %TYPE_MAP;
    tie %TYPE_MAP, __PACKAGE__;
    %TYPE_MAP = @types;
  }
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use Moo::_strictures;
  use Carp ();
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    my $proto = $class->BUILDARGS(@_);
    $NO_BUILD{$class} and
      return bless({}, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({}, $class)
      : bless({}, $class)->BUILDALL($proto);
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
    my $class = shift;
    scalar @_ == 1
      ? ref $_[0] eq 'HASH'
        ? { %{ $_[0] } }
        : Carp::croak("Single parameters to new() must be a HASH ref"
            . " data => ". $_[0])
      : @_ % 2
        ? Carp::croak("The new() method for $class expects a hash reference or a"
            . " key/value list. You passed an odd number of arguments")
        : {@_}
    ;
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    return !!0
      unless ($INC{'Moose/Role.pm'} || $INC{'Role/Tiny.pm'});
    require Moo::Role;
    my $does = Moo::Role->can("does_role");
    { no warnings 'redefine'; *does = $does }
    goto &$does;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use Moo::_strictures;
  use Moo::_Utils qw(
    _getglob
    _getstash
    _install_coderef
    _install_modifier
    _load_module
    _name_coderef
    _set_loaded
    _unimport_coderefs
  );
  use Carp qw(croak);
  use Role::Tiny ();
  BEGIN { our @ISA = qw(Role::Tiny) }
  BEGIN {
    our @CARP_NOT = qw(
      Method::Generate::Accessor
      Method::Generate::Constructor
      Moo::sification
      Moo::_Utils
    );
  }
  
  our $VERSION = '2.003002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  Moo::sification->import;
  
  BEGIN {
      *INFO = \%Role::Tiny::INFO;
      *APPLIED_TO = \%Role::Tiny::APPLIED_TO;
      *COMPOSED = \%Role::Tiny::COMPOSED;
      *ON_ROLE_CREATE = \@Role::Tiny::ON_ROLE_CREATE;
  }
  
  our %INFO;
  our %APPLIED_TO;
  our %APPLY_DEFAULTS;
  our %COMPOSED;
  our @ON_ROLE_CREATE;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      croak "Cannot import Moo::Role into a Moo class";
    }
    _set_loaded(caller);
    goto &Role::Tiny::import;
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    *{_getglob("${target}::meta")} = $me->can('meta');
  }
  
  push @ON_ROLE_CREATE, sub {
    my $target = shift;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  };
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    _load_module($role);
    $self->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $self->is_role($role);
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub is_role {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    $self->SUPER::is_role($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    my $meta;
    if (!$self->SUPER::is_role($role)
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
            require Sub::Quote;
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
            my $tc_var = '$_check_for_'.Sub::Quote::sanitize_identifier($tc->name);
  
            $spec->{isa} = Sub::Quote::quote_sub(
              qq{
                &${tc_var} or Carp::croak "Type constraint failed for \$_[0]"
              },
              { $tc_var => \$check },
              {
                package => $role,
              },
            );
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub _undefer_subs {
    my ($self, $target, $role) = @_;
    if ($INC{'Sub/Defer.pm'}) {
      Sub::Defer::undefer_package($role);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _undefer_subs _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    _load_module($role);
    $me->_inhale_if_moose($role);
    croak "${role} is not a Moo::Role" unless $me->is_role($role);
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      $me->_inhale_if_moose($role);
      croak "${role} is not a Moo::Role" unless $me->is_role($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      @{*{_getglob("${new_name}::ISA")}{ARRAY}} = ($superclass);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->apply_roles_to_package($new_name, @roles);
    }
    else {
      $me->SUPER::create_class_with_roles($superclass, @roles);
      $Moo::MAKERS{$new_name} = {is_class => 1};
      $me->_handle_constructor($new_name, $_) for @roles;
    }
  
    if ($INC{'Moo/HandleMoose.pm'} && !$Moo::sification::disabled) {
      Moo::HandleMoose::inject_fake_metaclass_for($new_name);
    }
    $COMPOSED{class}{$new_name} = 1;
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    my $class = ref $new;
    _set_loaded($class, (caller)[1]);
  
    my $apply_defaults = exists $APPLY_DEFAULTS{$class} ? $APPLY_DEFAULTS{$class}
      : $APPLY_DEFAULTS{$class} = do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for($class)
          and my $m = Moo->_accessor_maker_for($class)) {
  
        my $specs = $con_gen->all_attribute_specs;
  
        my %captures;
        my $code = join('',
          ( map {
            my $name = $_;
            my $spec = $specs->{$name};
            if ($m->has_eager_default($name, $spec)) {
              my ($has, $has_cap)
                = $m->generate_simple_has('$_[0]', $name, $spec);
              my ($set, $pop_cap)
                = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
              @captures{keys %$has_cap, keys %$pop_cap}
                = (values %$has_cap, values %$pop_cap);
              "($set),";
            }
            else {
              ();
            }
          } sort keys %attrs ),
        );
        if ($code) {
          require Sub::Quote;
          Sub::Quote::quote_sub(
            "${class}::_apply_defaults",
            "no warnings 'void';\n$code",
            \%captures,
            {
              package => $class,
              no_install => 1,
            }
          );
        }
        else {
          0;
        }
      }
      else {
        0;
      }
    };
    if ($apply_defaults) {
      local $Carp::Internal{+__PACKAGE__} = 1;
      local $Carp::Internal{$class} = 1;
      $new->$apply_defaults;
    }
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _install_does {
      my ($me, $to) = @_;
  
      # If Role::Tiny actually installed the DOES, give it a name
      my $new = $me->SUPER::_install_does($to) or return;
      return _name_coderef("${to}::DOES", $new);
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    return 1
      if Role::Tiny::does_role($proto, $role);
    my $meta;
    if ($INC{'Moose.pm'}
        and $meta = Class::MOP::class_of($proto)
        and ref $meta ne 'Moo::HandleMoose::FakeMetaClass'
        and $meta->can('does_role')
    ) {
      return $meta->does_role($role);
    }
    return 0;
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    my $info = $INFO{$to};
    my $con = $INC{"Moo.pm"} && Moo->_constructor_maker_for($to);
    my %existing
      = $info ? @{$info->{attributes} || []}
      : $con  ? %{$con->all_attribute_specs || {}}
      : ();
  
    my @attr_info =
      map { @{$attr_info}[$_, $_+1] }
      grep { ! $existing{$attr_info->[$_]} }
      map { 2 * $_ } 0..@$attr_info/2-1;
  
    if ($info) {
      push @{$info->{attributes}||=[]}, @attr_info;
    }
    elsif ($con) {
      # shallow copy of the specs since the constructor will assign an index
      $con->register_attribute_specs(map ref() ? { %$_ } : $_, @attr_info);
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
    package My::Role;
  
    use Moo::Role;
    use strictures 2;
  
    sub foo { ... }
  
    sub bar { ... }
  
    has baz => (
      is => 'ro',
    );
  
    1;
  
  And elsewhere:
  
    package Some::Class;
  
    use Moo;
    use strictures 2;
  
    # bar gets imported, but not foo
    with('My::Role');
  
    sub foo { ... }
  
    1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
    has attr => (
      is => 'ro',
    );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
    package My::Role::ID;
  
    use Digest::MD5 qw(md5_hex);
    use Moo::Role;
    use Digest::SHA qw(sha1_hex);
  
    requires 'name';
  
    sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
    sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
    1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  use Moo::_strictures;
  
  {
    no strict 'refs';
    sub _getglob { \*{$_[0]} }
    sub _getstash { \%{"$_[0]::"} }
  }
  
  BEGIN {
    my ($su, $sn);
    $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname
      or $sn = $INC{'Sub/Name.pm'}
      or $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname
      or $sn = eval { require Sub::Name; };
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_CAN_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use Exporter qw(import);
  use Config;
  use Carp qw(croak);
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _getstash _install_coderef _name_coderef
      _unimport_coderefs _set_loaded
  );
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if ($INC{'Sub/Defer.pm'} and my $to_modify = $into->can($name)) { # CMM will throw for us if not
      Sub::Defer::undefer_sub($to_modify);
    }
  
    require Class::Method::Modifiers;
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  sub _load_module {
    my $module = $_[0];
    my $file = eval { module_notional_filename($module) } or croak $@;
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    croak $error;
  }
  
  our %MAYBE_LOADED;
  sub _maybe_load_module {
    my $module = $_[0];
    return $MAYBE_LOADED{$module}
      if exists $MAYBE_LOADED{$module};
    if(! eval { use_package_optimistically($module) }) {
      warn "$module exists but failed to load with error: $@";
    }
    elsif ( $INC{module_notional_filename($module)} ) {
      return $MAYBE_LOADED{$module} = 1;
    }
    return $MAYBE_LOADED{$module} = 0;
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  use Moo::_strictures;
  
  if ("$]" >= 5.010_000) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/_strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__STRICTURES';
  package Moo::_strictures;
  use strict;
  use warnings;
  
  sub import {
    if ($ENV{MOO_FATAL_WARNINGS}) {
      require strictures;
      strictures->VERSION(2);
      @_ = ('strictures');
      goto &strictures::import;
    }
    else {
      strict->import;
      warnings->import;
      warnings->unimport('once');
    }
  }
  
  1;
MOO__STRICTURES

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use Moo::_strictures;
  no warnings 'once';
  use Devel::GlobalDestruction qw(in_global_destruction);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Moo::HandleMoose) }
  
  sub unimport {
    croak "Can't disable Moo::sification after inflation has been done"
      if $Moo::HandleMoose::SETUP_DONE;
    our $disabled = 1;
  }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disabled or in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  sub import {
    return
      if our $setup_done;
    if ($INC{"Moose.pm"}) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    } else {
      $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
    }
    $setup_done = 1;
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Ref/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REF_UTIL';
  package Ref::Util;
  # ABSTRACT: Utility functions for checking references
  $Ref::Util::VERSION = '0.203';
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  
  {
      my $impl = $ENV{PERL_REF_UTIL_IMPLEMENTATION}
          || our $IMPLEMENTATION
          || 'XS';
      if ($impl ne 'PP' && eval { require Ref::Util::XS; 1 }) {
          _install_aliases('Ref::Util::XS');
      }
      else {
          require Ref::Util::PP;
          _install_aliases('Ref::Util::PP');
      }
  }
  
  sub _install_aliases {
      my ($package) = @_;
      no warnings 'once';
      no strict 'refs';
      our %EXPORT_TAGS = %{"${package}::EXPORT_TAGS"};
      our @EXPORT_OK   = @{"${package}::EXPORT_OK"};
      *$_ = \&{"${package}::$_"} for '_using_custom_ops', @EXPORT_OK;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Ref::Util - Utility functions for checking references
  
  =head1 VERSION
  
  version 0.203
  
  =head1 SYNOPSIS
  
      use Ref::Util qw( is_plain_arrayref is_plain_hashref );
  
      if ( is_plain_arrayref( $something ) ) {
          print for @{ $something };
      } elsif ( is_plain_hashref( $something ) ) {
          print for sort values %{ $something };
      }
  
  =head1 DESCRIPTION
  
  Ref::Util introduces several functions to help identify references in a
  B<smarter> (and usually faster) way. In short:
  
      # conventional approach             # with Ref::Util
  
      ref( $foo ) eq 'ARRAY'              is_plain_arrayref( $foo )
  
      use Scalar::Util qw( reftype );
      reftype( $foo ) eq 'ARRAY'          is_arrayref( $foo )
  
  The difference:
  
  =over 4
  
  =item * No comparison against a string constant
  
  When you call C<ref>, you stringify the reference and then compare it
  to some string constant (like C<ARRAY> or C<HASH>). Not just awkward,
  it's brittle since you can mispell the string.
  
  If you use L<Scalar::Util>'s C<reftype>, you still compare it as a
  string:
  
      if ( reftype($foo) eq 'ARRAY' ) { ... }
  
  =item * Supports blessed variables
  
  B<Note:> In future versions, the idea is to make the default functions
  use the B<plain> variation, which means explicitly non-blessed references.
  
  If you want to explicitly check for B<blessed> references, you should use
  the C<is_blessed_*> functions. There will be an C<is_any_*> variation
  which will act like the current main functions - not caring whether it's
  blessed or not.
  
  When calling C<ref>, you receive either the reference type (B<SCALAR>,
  B<ARRAY>, B<HASH>, etc.) or the package it's blessed into.
  
  When calling C<is_arrayref> (et. al.), you check the variable flags,
  so even if it's blessed, you know what type of variable is blessed.
  
      my $foo = bless {}, 'PKG';
      ref($foo) eq 'HASH'; # fails
  
      use Ref::Util 'is_hashref';
      my $foo = bless {}, 'PKG';
      is_hashref($foo); # works
  
  On the other hand, in some situations it might be better to specifically
  exclude blessed references. The rationale for that might be that merely
  because some object happens to be implemented using a hash doesn't mean it's
  necessarily correct to treat it as a hash. For these situations, you can use
  C<is_plain_hashref> and friends, which have the same performance benefits as
  C<is_hashref>.
  
  There is also a family of functions with names like C<is_blessed_hashref>;
  these return true for blessed object instances that are implemented using
  the relevant underlying type.
  
  =item * Supports tied variables and magic
  
  Tied variables (used in L<Readonly>, for example) are supported.
  
      use Ref::Util qw<is_plain_hashref>;
      use Readonly;
  
      Readonly::Scalar my $rh2 => { a => { b => 2 } };
      is_plain_hashref($rh2); # success
  
  L<Ref::Util> added support for this in 0.100. Prior to this version
  the test would fail.
  
  =item * Ignores overloading
  
  These functions ignore overloaded operators and simply check the
  variable type. Overloading will likely not ever be supported, since I
  deem it problematic and confusing.
  
  Overloading makes your variables opaque containers and hides away
  B<what> they are and instead require you to figure out B<how> to use
  them. This leads to code that has to test different abilities (in
  C<eval>, so it doesn't crash) and to interfaces that get around what
  a person thought you would do with a variable. This would have been
  alright, except there is no clear way of introspecting it.
  
  =item * Ignores subtle types:
  
  The following types, provided by L<Scalar::Util>'s C<reftype>, are
  not supported:
  
  =over 4
  
  =item * C<VSTRING>
  
  This is a C<PVMG> ("normal" variable) with a flag set for VSTRINGs.
  Since this is not a reference, it is not supported.
  
  =item * C<LVALUE>
  
  A variable that delegates to another scalar. Since this is not a
  reference, it is not supported.
  
  =item * C<INVLIST>
  
  I couldn't find documentation for this type.
  
  =back
  
  Support might be added, if a good reason arises.
  
  =item * Usually fast
  
  When possible, Ref::Util uses L<Ref::Util::XS> as its implementation. (If
  you don't have a C compiler available, it uses a pure Perl fallback that has
  all the other advantages of Ref::Util, but isn't as fast.)
  
  In fact, Ref::Util::XS has two alternative implementations available
  internally, depending on the features supported by the version of Perl
  you're using. For Perls that supports custom OPs, we actually add an OP
  (which is faster); for other Perls, the implementation that simply calls an
  XS function (which is still faster than the pure-Perl equivalent).
  
  See below for L<benchmark results|/"BENCHMARKS">.
  
  =back
  
  =head1 EXPORT
  
  Nothing is exported by default. You can ask for specific subroutines
  (described below) or ask for all subroutines at once:
  
      use Ref::Util qw<is_scalarref is_arrayref is_hashref ...>;
  
      # or
  
      use Ref::Util ':all';
  
  =head1 SUBROUTINES
  
  =head2 is_ref($ref)
  
  Check for a reference to anything.
  
      is_ref([]);
  
  =head2 is_scalarref($ref)
  
  Check for a scalar reference.
  
      is_scalarref(\"hello");
      is_scalarref(\30);
      is_scalarref(\$value);
  
  Note that, even though a reference is itself a type of scalar value, a
  reference to another reference is not treated as a scalar reference:
  
      !is_scalarref(\\1);
  
  The rationale for this is two-fold. First, callers that want to decide how
  to handle inputs based on their reference type will usually want to treat a
  ref-ref and a scalar-ref differently. Secondly, this more closely matches
  the behavior of the C<ref> built-in and of L<Scalar::Util/reftype>, which
  report a ref-ref as C<REF> rather than C<SCALAR>.
  
  =head2 is_arrayref($ref)
  
  Check for an array reference.
  
      is_arrayref([]);
  
  =head2 is_hashref($ref)
  
  Check for a hash reference.
  
      is_hashref({});
  
  =head2 is_coderef($ref)
  
  Check for a code reference.
  
      is_coderef( sub {} );
  
  =head2 is_regexpref($ref)
  
  Check for a regular expression (regex, regexp) reference.
  
      is_regexpref( qr// );
  
  =head2 is_globref($ref)
  
  Check for a glob reference.
  
      is_globref( \*STDIN );
  
  =head2 is_formatref($ref)
  
  Check for a format reference.
  
      # set up format in STDOUT
      format STDOUT =
      .
  
      # now we can test it
      is_formatref( *main::STDOUT{'FORMAT'} );
  
  This function is not available in Perl 5.6 and will trigger a
  C<croak()>.
  
  =head2 is_ioref($ref)
  
  Check for an IO reference.
  
      is_ioref( *STDOUT{IO} );
  
  =head2 is_refref($ref)
  
  Check for a reference to a reference.
  
      is_refref( \[] ); # reference to array reference
  
  =head2 is_plain_scalarref($ref)
  
  Check for an unblessed scalar reference.
  
      is_plain_scalarref(\"hello");
      is_plain_scalarref(\30);
      is_plain_scalarref(\$value);
  
  =head2 is_plain_ref($ref)
  
  Check for an unblessed reference to anything.
  
      is_plain_ref([]);
  
  =head2 is_plain_arrayref($ref)
  
  Check for an unblessed array reference.
  
      is_plain_arrayref([]);
  
  =head2 is_plain_hashref($ref)
  
  Check for an unblessed hash reference.
  
      is_plain_hashref({});
  
  =head2 is_plain_coderef($ref)
  
  Check for an unblessed code reference.
  
      is_plain_coderef( sub {} );
  
  =head2 is_plain_globref($ref)
  
  Check for an unblessed glob reference.
  
      is_plain_globref( \*STDIN );
  
  =head2 is_plain_formatref($ref)
  
  Check for an unblessed format reference.
  
      # set up format in STDOUT
      format STDOUT =
      .
  
      # now we can test it
      is_plain_formatref(bless *main::STDOUT{'FORMAT'} );
  
  =head2 is_plain_refref($ref)
  
  Check for an unblessed reference to a reference.
  
      is_plain_refref( \[] ); # reference to array reference
  
  =head2 is_blessed_scalarref($ref)
  
  Check for a blessed scalar reference.
  
      is_blessed_scalarref(bless \$value);
  
  =head2 is_blessed_ref($ref)
  
  Check for a blessed reference to anything.
  
      is_blessed_ref(bless [], $class);
  
  =head2 is_blessed_arrayref($ref)
  
  Check for a blessed array reference.
  
      is_blessed_arrayref(bless [], $class);
  
  =head2 is_blessed_hashref($ref)
  
  Check for a blessed hash reference.
  
      is_blessed_hashref(bless {}, $class);
  
  =head2 is_blessed_coderef($ref)
  
  Check for a blessed code reference.
  
      is_blessed_coderef( bless sub {}, $class );
  
  =head2 is_blessed_globref($ref)
  
  Check for a blessed glob reference.
  
      is_blessed_globref( bless \*STDIN, $class );
  
  =head2 is_blessed_formatref($ref)
  
  Check for a blessed format reference.
  
      # set up format for FH
      format FH =
      .
  
      # now we can test it
      is_blessed_formatref(bless *FH{'FORMAT'}, $class );
  
  =head2 is_blessed_refref($ref)
  
  Check for a blessed reference to a reference.
  
      is_blessed_refref( bless \[], $class ); # reference to array reference
  
  =head1 BENCHMARKS
  
  Here is a benchmark comparing similar checks.
  
      my $bench = Dumbbench->new(
          target_rel_precision => 0.005,
          initial_runs         => 20,
      );
  
      my $amount = 1e7;
      my $ref    = [];
      $bench->add_instances(
          Dumbbench::Instance::PerlSub->new(
              name => 'Ref::Util::is_plain_arrayref (CustomOP)',
              code => sub {
                  Ref::Util::is_plain_arrayref($ref) for ( 1 .. $amount )
              },
          ),
  
          Dumbbench::Instance::PerlSub->new(
              name => 'ref(), reftype(), !blessed()',
              code => sub {
                  ref $ref
                      && Scalar::Util::reftype($ref) eq 'ARRAY'
                      && !Scalar::Util::blessed($ref)
                      for ( 1 .. $amount );
              },
          ),
  
          Dumbbench::Instance::PerlSub->new(
              name => 'ref()',
              code => sub { ref($ref) eq 'ARRAY' for ( 1 .. $amount ) },
          ),
  
          Dumbbench::Instance::PerlSub->new(
              name => 'Data::Util::is_array_ref',
              code => sub { is_array_ref($ref) for ( 1 .. $amount ) },
          ),
  
      );
  
  The results:
  
      ref():                                   5.335e+00 +/- 1.8e-02 (0.3%)
      ref(), reftype(), !blessed():            1.5545e+01 +/- 3.1e-02 (0.2%)
      Ref::Util::is_plain_arrayref (CustomOP): 2.7951e+00 +/- 6.2e-03 (0.2%)
      Data::Util::is_array_ref:                5.9074e+00 +/- 7.5e-03 (0.1%)
  
  (Rounded run time per iteration)
  
  A benchmark against L<Data::Util>:
  
      Ref::Util::is_plain_arrayref: 3.47157e-01 +/- 6.8e-05 (0.0%)
      Data::Util::is_array_ref:     6.7562e-01 +/- 7.5e-04 (0.1%)
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Params::Classify>
  
  =item * L<Scalar::Util>
  
  =item * L<Data::Util>
  
  =back
  
  =head1 THANKS
  
  The following people have been invaluable in their feedback and support.
  
  =over 4
  
  =item * Yves Orton
  
  =item * Steffen MÃ¼ller
  
  =item * Jarkko Hietaniemi
  
  =item * Mattia Barbon
  
  =item * Zefram
  
  =item * Tony Cook
  
  =item * Sergey Aleynikov
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item * Aaron Crane
  
  =item * Vikentiy Fesunov
  
  =item * Sawyer X
  
  =item * Gonzalo Diethelm
  
  =item * p5pclub
  
  =back
  
  =head1 LICENSE
  
  This software is made available under the MIT Licence as stated in the
  accompanying LICENSE file.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Sawyer X <xsawyerx@cpan.org>
  
  =item *
  
  Aaron Crane <arc@cpan.org>
  
  =item *
  
  Vikenty Fesunov <vyf@cpan.org>
  
  =item *
  
  Gonzalo Diethelm <gonzus@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2017 by Sawyer X.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
REF_UTIL

$fatpacked{"Ref/Util/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REF_UTIL_PP';
  package Ref::Util::PP;
  $Ref::Util::PP::VERSION = '0.203';
  # ABSTRACT: pure-Perl version of Ref::Util
  
  use strict;
  use warnings;
  use Carp         ();
  use Scalar::Util ();
  use Exporter 5.57 'import';
  
  use constant _FORMAT_REFS_WORK => ("$]" >= 5.007);
  use constant _RX_NEEDS_MAGIC   => (Scalar::Util::reftype(qr/^/) ne 'REGEXP');
  
  our %EXPORT_TAGS = ( 'all' => [qw<
      is_ref
      is_scalarref
      is_arrayref
      is_hashref
      is_coderef
      is_regexpref
      is_globref
      is_formatref
      is_ioref
      is_refref
  
      is_plain_ref
      is_plain_scalarref
      is_plain_arrayref
      is_plain_hashref
      is_plain_coderef
      is_plain_globref
      is_plain_formatref
      is_plain_refref
  
      is_blessed_ref
      is_blessed_scalarref
      is_blessed_arrayref
      is_blessed_hashref
      is_blessed_coderef
      is_blessed_globref
      is_blessed_formatref
      is_blessed_refref
  >] );
  our @EXPORT      = ();
  our @EXPORT_OK   = ( @{ $EXPORT_TAGS{'all'} } );
  
  sub _using_custom_ops () { 0 }
  
  if (_RX_NEEDS_MAGIC) {
      require B;
      *_is_regexp = sub {
          no warnings 'uninitialized';
          return 0 if ref($_[0]) eq '';
          my $o = B::svref_2object($_[0]) or return 0;
          return 0 if Scalar::Util::blessed($o) ne 'B::PVMG';
  
          my $m = $o->MAGIC;
          while ($m) {
              return 1 if $m->TYPE eq 'r';
              $m = $m->MOREMAGIC;
          }
  
          return 0;
      };
  }
  
  # ----
  # -- is_*
  # ----
  
  sub is_ref($) { length ref $_[0] }
  
  sub is_scalarref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_scalarref") if @_ > 1;
      my $reftype = Scalar::Util::reftype( $_[0] );
      ( $reftype eq 'SCALAR' || $reftype eq 'VSTRING' )
          && (!_RX_NEEDS_MAGIC || !_is_regexp($_[0]));
  }
  
  sub is_arrayref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_arrayref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'ARRAY';
  }
  
  sub is_hashref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_hashref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'HASH';
  }
  
  sub is_coderef($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_coderef") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'CODE';
  }
  
  sub is_regexpref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_regexpref") if @_ > 1;
      _RX_NEEDS_MAGIC ? _is_regexp( $_[0] )
          : re::is_regexp( $_[0] );
  }
  
  sub is_globref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_globref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'GLOB';
  }
  
  sub is_formatref($) {
      _FORMAT_REFS_WORK
          or
          Carp::croak("is_formatref() isn't available on Perl 5.6.x and under");
  
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_formatref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'FORMAT';
  }
  
  sub is_ioref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_ioref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'IO';
  }
  
  sub is_refref($) {
      no warnings 'uninitialized';
      Carp::croak("Too many arguments for is_refref") if @_ > 1;
      Scalar::Util::reftype( $_[0] ) eq 'REF';
  }
  
  # ----
  # -- is_plain_*
  # ----
  
  sub is_plain_ref($) {
      Carp::croak("Too many arguments for is_plain_ref") if @_ > 1;
      ref $_[0] && !Scalar::Util::blessed( $_[0] );
  }
  
  sub is_plain_scalarref($) {
      Carp::croak("Too many arguments for is_plain_scalarref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ( ref( $_[0] ) eq 'SCALAR' || ref( $_[0] ) eq 'VSTRING' );
  }
  
  sub is_plain_arrayref($) {
      Carp::croak("Too many arguments for is_plain_arrayref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'ARRAY';
  }
  
  sub is_plain_hashref($) {
      Carp::croak("Too many arguments for is_plain_hashref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'HASH';
  }
  
  sub is_plain_coderef($) {
      Carp::croak("Too many arguments for is_plain_coderef") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'CODE';
  }
  
  sub is_plain_globref($) {
      Carp::croak("Too many arguments for is_plain_globref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'GLOB';
  }
  
  sub is_plain_formatref($) {
      _FORMAT_REFS_WORK
          or
          Carp::croak("is_plain_formatref() isn't available on Perl 5.6.x and under");
  
      Carp::croak("Too many arguments for is_plain_formatref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'FORMAT';
  }
  
  sub is_plain_refref($) {
      Carp::croak("Too many arguments for is_plain_refref") if @_ > 1;
      !defined Scalar::Util::blessed( $_[0] )
          && ref( $_[0] ) eq 'REF';
  }
  
  # ----
  # -- is_blessed_*
  # ----
  
  sub is_blessed_ref($) {
      Carp::croak("Too many arguments for is_blessed_ref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] );
  }
  
  sub is_blessed_scalarref($) {
      Carp::croak("Too many arguments for is_blessed_scalarref") if @_ > 1;
      my $reftype = Scalar::Util::reftype( $_[0] );
      defined Scalar::Util::blessed( $_[0] )
          && ($reftype eq 'SCALAR' || $reftype eq 'VSTRING')
          && (!_RX_NEEDS_MAGIC || !_is_regexp( $_[0] ));
  }
  
  sub is_blessed_arrayref($) {
      Carp::croak("Too many arguments for is_blessed_arrayref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'ARRAY';
  }
  
  sub is_blessed_hashref($) {
      Carp::croak("Too many arguments for is_blessed_hashref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'HASH';
  }
  
  sub is_blessed_coderef($) {
      Carp::croak("Too many arguments for is_blessed_coderef") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'CODE';
  }
  
  sub is_blessed_globref($) {
      Carp::croak("Too many arguments for is_blessed_globref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'GLOB';
  }
  
  sub is_blessed_formatref($) {
      _FORMAT_REFS_WORK
          or
          Carp::croak("is_blessed_formatref() isn't available on Perl 5.6.x and under");
  
      Carp::croak("Too many arguments for is_blessed_formatref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'FORMAT';
  }
  
  sub is_blessed_refref($) {
      Carp::croak("Too many arguments for is_blessed_refref") if @_ > 1;
      defined Scalar::Util::blessed( $_[0] )
          && Scalar::Util::reftype( $_[0] ) eq 'REF';
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Ref::Util::PP - pure-Perl version of Ref::Util
  
  =head1 VERSION
  
  version 0.203
  
  =head1 SYNOPSIS
  
      use Ref::Util;
  
  =head1 DESCRIPTION
  
  This module provides a pure-Perl implementation of the functions in
  L<Ref::Util>.
  
  Ref::Util:PP will be used automatically if Ref::Util is installed on a
  system with no C compiler, but you can force its usage by setting either
  C<$Ref::Util::IMPLEMENTATION> or the C<PERL_REF_UTIL_IMPLEMENTATION>
  environment variable to C<PP>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Sawyer X <xsawyerx@cpan.org>
  
  =item *
  
  Aaron Crane <arc@cpan.org>
  
  =item *
  
  Vikenty Fesunov <vyf@cpan.org>
  
  =item *
  
  Gonzalo Diethelm <gonzus@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2017 by Sawyer X.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
REF_UTIL_PP

$fatpacked{"Role/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY';
  package Role::Tiny;
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000005';
  $VERSION = eval $VERSION;
  
  our %INFO;
  our %APPLIED_TO;
  our %COMPOSED;
  our %COMPOSITE_INFO;
  our @ON_ROLE_CREATE;
  
  # Module state workaround totally stolen from Zefram's Module::Runtime.
  
  BEGIN {
    *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
    *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
  }
  
  sub croak {
    require Carp;
    no warnings 'redefine';
    *croak = \&Carp::croak;
    goto &Carp::croak;
  }
  
  sub Role::Tiny::__GUARD__::DESTROY {
    delete $INC{$_[0]->[0]} if @{$_[0]};
  }
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    $proto .= '.pm';
    return 1 if $INC{$proto};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
    my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
      && bless([ $proto ], 'Role::Tiny::__GUARD__');
    require $proto;
    pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
    return 1;
  }
  
  sub import {
    my $target = caller;
    my $me = shift;
    strict->import;
    warnings->import;
    $me->_install_subs($target);
    return if $me->is_role($target); # already exported into this package
    $INFO{$target}{is_role} = 1;
    # get symbol table reference
    my $stash = _getstash($target);
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) with a map to the coderefs in
    # case of copying or re-use
    my @not_methods = (map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $APPLIED_TO{$target} = { $target => undef };
    foreach my $hook (@ON_ROLE_CREATE) {
      $hook->($target);
    }
  }
  
  sub _install_subs {
    my ($me, $target) = @_;
    return if $me->is_role($target);
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      *{_getglob "${target}::${type}"} = sub {
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        return;
      };
    }
    *{_getglob "${target}::requires"} = sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      return;
    };
    *{_getglob "${target}::with"} = sub {
      $me->apply_roles_to_package($target, @_);
      return;
    };
  }
  
  sub role_application_steps {
    qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
  
    _load_module($role);
  
    croak "This is apply_role_to_package" if ref($to);
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
  
    foreach my $step ($me->role_application_steps) {
      $me->$step($to, $role);
    }
  }
  
  sub _copy_applied_list {
    my ($me, $to, $role) = @_;
    # copy our role list into the target's
    @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    croak "No roles supplied!" unless @roles;
    my $class = ref($object);
    # on perl < 5.8.9, magic isn't copied to all ref copies. bless the parameter
    # directly, so at least the variable passed to us will get any magic applied
    bless($_[1], $me->create_class_with_roles($class, @roles));
  }
  
  my $role_suffix = 'A000';
  sub _composite_name {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    if (length($new_name) > 252) {
      $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
        my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
        $abbrev =~ s/(?<!:):$//;
        $abbrev.'__'.$role_suffix++;
      };
    }
    return wantarray ? ($new_name, $compose_name) : $new_name;
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    croak "No roles supplied!" unless @roles;
  
    _load_module($superclass);
    {
      my %seen;
      if (my @dupes = grep 1 == $seen{$_}++, @roles) {
        croak "Duplicated roles: ".join(', ', @dupes);
      }
    }
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
      _load_module($role);
      croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    }
  
    require(_MRO_MODULE);
  
    my $composite_info = $me->_composite_info_for(@roles);
    my %conflicts = %{$composite_info->{conflicts}};
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Method name conflict for '$_' between roles "
            ."'".join("' and '", sort values %{$conflicts{$_}})."'"
            .", cannot apply these simultaneously to an object."
          } keys %conflicts;
      croak $fail;
    }
  
    my @composable = map $me->_composable_package_for($_), reverse @roles;
  
    # some methods may not exist in the role, but get generated by
    # _composable_package_for (Moose accessors via Moo).  filter out anything
    # provided by the composable packages, excluding the subs we generated to
    # make modifiers work.
    my @requires = grep {
      my $method = $_;
      !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
        @composable
    } @{$composite_info->{requires}};
  
    $me->_check_requires(
      $superclass, $compose_name, \@requires
    );
  
    *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
  
    @{$APPLIED_TO{$new_name}||={}}{
      map keys %{$APPLIED_TO{$_}}, @roles
    } = ();
  
    $COMPOSED{class}{$new_name} = 1;
    return $new_name;
  }
  
  # preserved for compat, and apply_roles_to_package calls it to allow an
  # updated Role::Tiny to use a non-updated Moo::Role
  
  sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
  
    return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
  
    my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
    my @have = grep $to->can($_), keys %conflicts;
    delete @conflicts{@have};
  
    if (keys %conflicts) {
      my $fail =
        join "\n",
          map {
            "Due to a method name conflict between roles "
            ."'".join(' and ', sort values %{$conflicts{$_}})."'"
            .", the method '$_' must be implemented by '${to}'"
          } keys %conflicts;
      croak $fail;
    }
  
    # conflicting methods are supposed to be treated as required by the
    # composed role. we don't have an actual composed role, but because
    # we know the target class already provides them, we can instead
    # pretend that the roles don't do for the duration of application.
    my @role_methods = map $me->_concrete_methods_of($_), @roles;
    # separate loops, since local ..., delete ... for ...; creates a scope
    local @{$_}{@have} for @role_methods;
    delete @{$_}{@have} for @role_methods;
  
    # the if guard here is essential since otherwise we accidentally create
    # a $INFO for something that isn't a Role::Tiny (or Moo::Role) because
    # autovivification hates us and wants us to die()
    if ($INFO{$to}) {
      delete $INFO{$to}{methods}; # reset since we're about to add methods
    }
  
    # backcompat: allow subclasses to use apply_single_role_to_package
    # to apply changes.  set a local var so ours does nothing.
    our %BACKCOMPAT_HACK;
    if($me ne __PACKAGE__
        and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
        $BACKCOMPAT_HACK{$me} =
          $me->can('role_application_steps')
            == \&role_application_steps
          && $me->can('apply_single_role_to_package')
            != \&apply_single_role_to_package
    ) {
      foreach my $role (@roles) {
        $me->apply_single_role_to_package($to, $role);
      }
    }
    else {
      foreach my $step ($me->role_application_steps) {
        foreach my $role (@roles) {
          $me->$step($to, $role);
        }
      }
    }
    $APPLIED_TO{$to}{join('|',@roles)} = 1;
  }
  
  sub _composite_info_for {
    my ($me, @roles) = @_;
    $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
      foreach my $role (@roles) {
        _load_module($role);
      }
      my %methods;
      foreach my $role (@roles) {
        my $this_methods = $me->_concrete_methods_of($role);
        $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
      }
      my %requires;
      @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
      delete $requires{$_} for keys %methods;
      delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
      +{ conflicts => \%methods, requires => [keys %requires] }
    };
  }
  
  sub _composable_package_for {
    my ($me, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $COMPOSED{role}{$composed_name};
    $me->_install_methods($composed_name, $role);
    my $base_name = $composed_name.'::_BASE';
    # force stash to exist so ->can doesn't complain
    _getstash($base_name);
    # Not using _getglob, since setting @ISA via the typeglob breaks
    # inheritance on 5.10.0 if the stash has previously been accessed an
    # then a method called on the class (in that order!), which
    # ->_install_methods (with the help of ->_install_does) ends up doing.
    { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
    my $modifiers = $INFO{$role}{modifiers}||[];
    my @mod_base;
    my @modifiers = grep !$composed_name->can($_),
      do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
    foreach my $modified (@modifiers) {
      push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
    }
    my $e;
    {
      local $@;
      eval(my $code = join "\n", "package ${base_name};", @mod_base);
      $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
    }
    die $e if $e;
    $me->_install_modifiers($composed_name, $role);
    $COMPOSED{role}{$composed_name} = {
      modifiers_only => { map { $_ => 1 } @modifiers },
    };
    return $composed_name;
  }
  
  sub _check_requires {
    my ($me, $to, $name, $requires) = @_;
    return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
    if (my @requires_fail = grep !$to->can($_), @requires) {
      # role -> role, add to requires, role -> class, error out
      if (my $to_info = $INFO{$to}) {
        push @{$to_info->{requires}||=[]}, @requires_fail;
      } else {
        croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
      }
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $info = $INFO{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$info->{not_methods}||{}} };
    $info->{methods} ||= +{
      # grab all code entries that aren't in the not_methods list
      map {;
        no strict 'refs';
        my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  sub methods_provided_by {
    my ($me, $role) = @_;
    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
    (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
  }
  
  sub _install_methods {
    my ($me, $to, $role) = @_;
  
    my $info = $INFO{$role};
  
    my $methods = $me->_concrete_methods_of($role);
  
    # grab target symbol table
    my $stash = _getstash($to);
  
    # determine already extant methods of target
    my %has_methods;
    @has_methods{grep
      +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
      keys %$stash
    } = ();
  
    foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
      no warnings 'once';
      my $glob = _getglob "${to}::${i}";
      *$glob = $methods->{$i};
  
      # overloads using method names have the method stored in the scalar slot
      # and &overload::nil in the code slot.
      next
        unless $i =~ /^\(/
          && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
              || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
  
      my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
      next
        unless defined $overload;
  
      *$glob = \$overload;
    }
  
    $me->_install_does($to);
  }
  
  sub _install_modifiers {
    my ($me, $to, $name) = @_;
    return unless my $modifiers = $INFO{$name}{modifiers};
    my $info = $INFO{$to};
    my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
    my @modifiers = grep {
      my $modifier = $_;
      !grep $_ == $modifier, @$existing;
    } @{$modifiers||[]};
    push @$existing, @modifiers;
  
    if (!$info) {
      foreach my $modifier (@modifiers) {
        $me->_install_single_modifier($to, @$modifier);
      }
    }
  }
  
  my $vcheck_error;
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    defined($vcheck_error) or $vcheck_error = do {
      local $@;
      eval {
        require Class::Method::Modifiers;
        Class::Method::Modifiers->VERSION(1.05);
        1;
      } ? 0 : $@;
    };
    $vcheck_error and die $vcheck_error;
    Class::Method::Modifiers::install_modifier(@args);
  }
  
  my $FALLBACK = sub { 0 };
  sub _install_does {
    my ($me, $to) = @_;
  
    # only add does() method to classes
    return if $me->is_role($to);
  
    my $does = $me->can('does_role');
    # add does() only if they don't have one
    *{_getglob "${to}::does"} = $does unless $to->can('does');
  
    return
      if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
  
    my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
    my $new_sub = sub {
      my ($proto, $role) = @_;
      $proto->$does($role) or $proto->$existing($role);
    };
    no warnings 'redefine';
    return *{_getglob "${to}::DOES"} = $new_sub;
  }
  
  sub does_role {
    my ($proto, $role) = @_;
    require(_MRO_MODULE);
    foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
      return 1 if exists $APPLIED_TO{$class}{$role};
    }
    return 0;
  }
  
  sub is_role {
    my ($me, $role) = @_;
    return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Role::Tiny - Roles. Like a nouvelle cuisine portion size slice of Moose.
  
  =head1 SYNOPSIS
  
   package Some::Role;
  
   use Role::Tiny;
  
   sub foo { ... }
  
   sub bar { ... }
  
   around baz => sub { ... };
  
   1;
  
  elsewhere
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   # bar gets imported, but not foo
   with 'Some::Role';
  
   sub foo { ... }
  
   # baz is wrapped in the around modifier by Class::Method::Modifiers
   sub baz { ... }
  
   1;
  
  If you wanted attributes as well, look at L<Moo::Role>.
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.
  
  =head1 ROLE COMPOSITION
  
  Role composition can be thought of as much more clever and meaningful multiple
  inheritance.  The basics of this implementation of roles is:
  
  =over 2
  
  =item *
  
  If a method is already defined on a class, that method will not be composed in
  from the role. A method inherited by a class gets overridden by the role's
  method of the same name, though.
  
  =item *
  
  If a method that the role L</requires> to be implemented is not implemented,
  role application will fail loudly.
  
  =back
  
  Unlike L<Class::C3>, where the B<last> class inherited from "wins," role
  composition is the other way around, where the class wins. If multiple roles
  are applied in a single call (single with statement), then if any of their
  provided methods clash, an exception is raised unless the class provides
  a method since this conflict indicates a potential problem.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 requires
  
   requires qw(foo bar);
  
  Declares a list of methods that must be defined to compose role.
  
  =head2 with
  
   with 'Some::Role1';
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes another role into the current role (or class via L<Role::Tiny::With>).
  
  If you have conflicts and want to resolve them in favour of Some::Role1 you
  can instead write:
  
   with 'Some::Role1';
   with 'Some::Role2';
  
  If you have conflicts and want to resolve different conflicts in favour of
  different roles, please refactor your codebase.
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  Note that since you are not required to use method modifiers,
  L<Class::Method::Modifiers> is lazily loaded and we do not declare it as
  a dependency. If your L<Role::Tiny> role uses modifiers you must depend on
  both L<Class::Method::Modifiers> and L<Role::Tiny>.
  
  =head2 Strict and Warnings
  
  In addition to importing subroutines, using C<Role::Tiny> applies L<strict> and
  L<warnings> to the caller.
  
  =head1 SUBROUTINES
  
  =head2 does_role
  
   if (Role::Tiny::does_role($foo, 'Some::Role')) {
     ...
   }
  
  Returns true if class has been composed with role.
  
  This subroutine is also installed as ->does on any class a Role::Tiny is
  composed into unless that class already has an ->does method, so
  
    if ($foo->does('Some::Role')) {
      ...
    }
  
  will work for classes but to test a role, one must use ::does_role directly.
  
  Additionally, Role::Tiny will override the standard Perl C<DOES> method
  for your class. However, if C<any> class in your class' inheritance
  hierarchy provides C<DOES>, then Role::Tiny will not override it.
  
  =head1 METHODS
  
  =head2 apply_roles_to_package
  
   Role::Tiny->apply_roles_to_package(
     'Some::Package', 'Some::Role', 'Some::Other::Role'
   );
  
  Composes role with package.  See also L<Role::Tiny::With>.
  
  =head2 apply_roles_to_object
  
   Role::Tiny->apply_roles_to_object($foo, qw(Some::Role1 Some::Role2));
  
  Composes roles in order into object directly. Object is reblessed into the
  resulting class. Note that the object's methods get overridden by the role's
  ones with the same names.
  
  =head2 create_class_with_roles
  
   Role::Tiny->create_class_with_roles('Some::Base', qw(Some::Role1 Some::Role2));
  
  Creates a new class based on base, with the roles composed into it in order.
  New class is returned.
  
  =head2 is_role
  
   Role::Tiny->is_role('Some::Role1')
  
  Returns true if the given package is a role.
  
  =head1 CAVEATS
  
  =over 4
  
  =item * On perl 5.8.8 and earlier, applying a role to an object won't apply any
  overloads from the role to other copies of the object.
  
  =item * On perl 5.16 and earlier, applying a role to a class won't apply any
  overloads from the role to any existing instances of the class.
  
  =back
  
  =head1 SEE ALSO
  
  L<Role::Tiny> is the attribute-less subset of L<Moo::Role>; L<Moo::Role> is
  a meta-protocol-less subset of the king of role systems, L<Moose::Role>.
  
  Ovid's L<Role::Basic> provides roles with a similar scope, but without method
  modifiers, and having some extra usage restrictions.
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. BurzyÅ„ski (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari MannsÃ¥ker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2012 the Role::Tiny L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
ROLE_TINY

$fatpacked{"Role/Tiny/With.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ROLE_TINY_WITH';
  package Role::Tiny::With;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.000005';
  $VERSION = eval $VERSION;
  
  use Role::Tiny ();
  
  use Exporter 'import';
  our @EXPORT = qw( with );
  
  sub with {
      my $target = caller;
      Role::Tiny->apply_roles_to_package($target, @_)
  }
  
  1;
  
  =head1 NAME
  
  Role::Tiny::With - Neat interface for consumers of Role::Tiny roles
  
  =head1 SYNOPSIS
  
   package Some::Class;
  
   use Role::Tiny::With;
  
   with 'Some::Role';
  
   # The role is now mixed in
  
  =head1 DESCRIPTION
  
  C<Role::Tiny> is a minimalist role composition tool.  C<Role::Tiny::With>
  provides a C<with> function to compose such roles.
  
  =head1 AUTHORS
  
  See L<Role::Tiny> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Role::Tiny> for the copyright and license.
  
  =cut
  
  
ROLE_TINY_WITH

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  use strict;
  use warnings;
  use Exporter qw(import);
  use Scalar::Util qw(weaken);
  use Carp qw(croak);
  
  our $VERSION = '2.004000';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  our @EXPORT_OK = qw(undefer_package defer_info);
  
  our %DEFERRED;
  
  sub _getglob { no strict 'refs'; \*{$_[0]} }
  
  BEGIN {
    my $no_subname;
    *_subname
      = defined &Sub::Util::set_subname ? \&Sub::Util::set_subname
      : defined &Sub::Name::subname     ? \&Sub::Name::subname
      : (eval { require Sub::Util } && defined &Sub::Util::set_subname) ? \&Sub::Util::set_subname
      : (eval { require Sub::Name } && defined &Sub::Name::subname    ) ? \&Sub::Name::subname
      : ($no_subname = 1, sub { $_[1] });
    *_CAN_SUBNAME = $no_subname ? sub(){0} : sub(){1};
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    _CAN_SUBNAME ? _subname(@_) : $_[1];
  }
  
  sub _install_coderef {
    my ($glob, $code) = (_getglob($_[0]), _name_coderef(@_));
    no warnings 'redefine';
    if (*{$glob}{CODE}) {
      *{$glob} = $code;
    }
    # perl will sometimes warn about mismatched prototypes coming from the
    # inheritance cache, so disable them if we aren't redefining a sub
    else {
      no warnings 'prototype';
      *{$glob} = $code;
    }
  }
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    $DEFERRED{$made} = $DEFERRED{$deferred};
    weaken $DEFERRED{$made}
      unless $target;
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub undefer_package {
    my $package = shift;
    undefer_sub($_)
      for grep {
        my $name = $DEFERRED{$_} && $DEFERRED{$_}[0];
        $name && $name =~ /^${package}::[^:]+$/
      } keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    my $info = $DEFERRED{$deferred||''} or return undef;
    [ @$info ];
  }
  
  sub defer_sub {
    my ($target, $maker, $options) = @_;
    my $package;
    my $subname;
    ($package, $subname) = $target =~ /^(.*)::([^:]+)$/
      or croak "$target is not a fully qualified sub name!"
      if $target;
    $package ||= $options && $options->{package} || caller;
    my @attributes = @{$options && $options->{attributes} || []};
    if (@attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @attributes;
    }
    my $deferred;
    my $undeferred;
    my $deferred_info = [ $target, $maker, \$undeferred ];
    if (@attributes || $target && !_CAN_SUBNAME) {
      my $code
        =  q[#line ].(__LINE__+2).q[ "].__FILE__.qq["\n]
        . qq[package $package;\n]
        . ($target ? "sub $subname" : '+sub') . join('', map " :$_", @attributes)
        . q[ {
          package Sub::Defer;
          # uncoverable subroutine
          # uncoverable statement
          $undeferred ||= undefer_sub($deferred_info->[3]);
          goto &$undeferred; # uncoverable statement
          $undeferred; # fake lvalue return
        }]."\n"
        . ($target ? "\\&$subname" : '');
      my $e;
      $deferred = do {
        no warnings qw(redefine closure);
        local $@;
        eval $code or $e = $@; # uncoverable branch true
      };
      die $e if defined $e; # uncoverable branch true
    }
    else {
      # duplicated from above
      $deferred = sub {
        $undeferred ||= undefer_sub($deferred_info->[3]);
        goto &$undeferred;
      };
      _install_coderef($target, $deferred)
        if $target;
    }
    weaken($deferred_info->[3] = $deferred);
    weaken($DEFERRED{$deferred} = $deferred_info);
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ && $_->[3] ? ($_->[3] => $_) : () } values %DEFERRED;
    foreach my $info (values %DEFERRED) {
      weaken($info)
        unless $info->[0] && ${$info->[2]};
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - Defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  Exported by default.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  Exported by default.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all deferred subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.  Note this may bake the behavior of some subs that were intended to
  calculate their behavior later, so it shouldn't be used midway through a
  module load or class definition.
  
  Exported by default.
  
  =head2 undefer_package
  
    undefer_package($package);
  
  This undefers all deferred subs in a package.
  
  Not exported by default.
  
  =head1 SUPPORT
  
  See L<Sub::Quote> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Sub::Quote> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Sub::Quote> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari MannsÃ¥ker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  sub _clean_eval { eval $_[0] }
  
  use strict;
  use warnings;
  
  use Sub::Defer qw(defer_sub);
  use Scalar::Util qw(weaken);
  use Exporter qw(import);
  use Carp qw(croak);
  BEGIN { our @CARP_NOT = qw(Sub::Defer) }
  use B ();
  BEGIN {
    *_HAVE_PERLSTRING = defined &B::perlstring ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.004000';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub qsub);
  our @EXPORT_OK = qw(quotify capture_unroll inlinify sanitize_identifier);
  
  our %QUOTED;
  
  sub quotify {
    my $value = $_[0];
    no warnings 'numeric';
    ! defined $value     ? 'undef()'
    # numeric detection
    : (length( (my $dummy = '') & $value )
      && 0 + $value eq $value
      && $value * 0 == 0
    ) ? $value
    : _HAVE_PERLSTRING  ? B::perlstring($value)
    : qq["\Q$value\E"];
  }
  
  sub sanitize_identifier {
    my $name = shift;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or croak "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\quotify $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    if ($code =~ s{
      \A((?:\#\ BEGIN\ quote_sub\ PRELUDE\n.*?\#\ END\ quote_sub\ PRELUDE\n)?\s*)
      (^\s*) my \s* \(([^)]+)\) \s* = \s* \@_;
    }{}xms) {
      my ($pre, $indent, $code_args) = ($1, $2, $3);
      $do .= $pre;
      if ($code_args ne $args) {
        $do .= $indent . 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $do .= ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    if ($name) {
      my $subname = $name;
      my $package = $subname =~ s/(.*)::// ? $1 : caller;
      $name = join '::', $package, $subname;
      croak qq{package name "$package" too long!}
        if length $package > 252;
      croak qq{package name "$package" is not valid!}
        unless $package =~ /^[^\d\W]\w*(?:::\w+)*$/;
      croak qq{sub name "$subname" too long!}
        if length $subname > 252;
      croak qq{sub name "$subname" is not valid!}
        unless $subname =~ /^[^\d\W]\w*$/;
    }
    my @caller = caller(0);
    my $attributes = $options->{attributes};
    if ($attributes) {
      /\A\w+(?:\(.*\))?\z/s || croak "invalid attribute $_"
        for @$attributes;
    }
    my $quoted_info = {
      name     => $name,
      code     => $code,
      captures => $captures,
      package      => (exists $options->{package}      ? $options->{package}      : $caller[0]),
      hints        => (exists $options->{hints}        ? $options->{hints}        : $caller[8]),
      warning_bits => (exists $options->{warning_bits} ? $options->{warning_bits} : $caller[9]),
      hintshash    => (exists $options->{hintshash}    ? $options->{hintshash}    : $caller[10]),
      ($attributes ? (attributes => $attributes) : ()),
    };
    my $unquoted;
    weaken($quoted_info->{unquoted} = \$unquoted);
    if ($options->{no_defer}) {
      my $fake = \my $var;
      local $QUOTED{$fake} = $quoted_info;
      my $sub = unquote_sub($fake);
      Sub::Defer::_install_coderef($name, $sub) if $name && !$options->{no_install};
      return $sub;
    }
    else {
      my $deferred = defer_sub(
        ($options->{no_install} ? undef : $name),
        sub {
          $unquoted if 0;
          unquote_sub($quoted_info->{deferred});
        },
        {
          ($attributes ? ( attributes => $attributes ) : ()),
          ($name ? () : ( package => $quoted_info->{package} )),
        },
      );
      weaken($quoted_info->{deferred} = $deferred);
      weaken($QUOTED{$deferred} = $quoted_info);
      return $deferred;
    }
  }
  
  sub _context {
    my $info = shift;
    $info->{context} ||= do {
      my ($package, $hints, $warning_bits, $hintshash)
        = @{$info}{qw(package hints warning_bits hintshash)};
  
      $info->{context}
        ="# BEGIN quote_sub PRELUDE\n"
        ."package $package;\n"
        ."BEGIN {\n"
        ."  \$^H = ".quotify($hints).";\n"
        ."  \${^WARNING_BITS} = ".quotify($warning_bits).";\n"
        ."  \%^H = (\n"
        . join('', map
        "    ".quotify($_)." => ".quotify($hintshash->{$_}).",\n",
          keys %$hintshash)
        ."  );\n"
        ."}\n"
        ."# END quote_sub PRELUDE\n";
    };
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub||''} or return undef;
    my ($name, $code, $captures, $unquoted, $deferred)
      = @{$quoted_info}{qw(name code captures unquoted deferred)};
    $code = _context($quoted_info) . $code;
    $unquoted &&= $$unquoted;
    if (($deferred && $deferred eq $sub)
        || ($unquoted && $unquoted eq $sub)) {
      return [ $name, $code, $captures, $unquoted, $deferred ];
    }
    return undef;
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    my $quoted_info = $QUOTED{$sub} or return undef;
    my $unquoted = $quoted_info->{unquoted};
    unless ($unquoted && $$unquoted) {
      my ($name, $code, $captures, $package, $attributes)
        = @{$quoted_info}{qw(name code captures package attributes)};
  
      ($package, $name) = $name =~ /(.*)::(.*)/
        if $name;
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_UNQUOTED'} = \$unquoted;
      $captures{'$_QUOTED'} = \$quoted_info;
  
      my $make_sub
        = "{\n"
        . capture_unroll("\$_[1]", \%captures, 2)
        . "  package ${package};\n"
        . (
          $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
            ? "  no warnings 'closure';\n  sub ${name} "
            : "  \$\$_UNQUOTED = sub "
        )
        . ($attributes ? join('', map ":$_ ", @$attributes) : '') . "{\n"
        . "  (\$_QUOTED,\$_UNQUOTED) if 0;\n"
        . _context($quoted_info)
        . $code
        . "  }".($name ? "\n  \$\$_UNQUOTED = \\&${name}" : '') . ";\n"
        . "}\n"
        . "1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{"${package}::${name}"} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          my $space = length($make_sub =~ tr/\n//);
          my $line = 0;
          $make_sub =~ s/^/sprintf "%${space}d: ", ++$line/emg;
          croak "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
        weaken($QUOTED{$$unquoted} = $quoted_info);
      }
    }
    $$unquoted;
  }
  
  sub qsub ($) {
    goto &quote_sub;
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? (
      $_->{unquoted} && ${$_->{unquoted}} ? (${ $_->{unquoted} } => $_) : (),
      $_->{deferred} ? ($_->{deferred} => $_) : (),
    ) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Sub::Quote - Efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  Exported by default.
  
  =head3 options
  
  =over 2
  
  =item C<no_install>
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =item C<no_defer>
  
  B<Boolean>.  Prevents a Sub::Defer wrapper from being generated for the quoted
  sub.  If the sub will most likely be called at some point, setting this is a
  good idea.  For a sub that will most likely be inlined, it is not recommended.
  
  =item C<package>
  
  The package that the quoted sub will be evaluated in.  If not specified, the
  sub calling C<quote_sub> will be used.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  Exported by default.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  Exported by default.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 quotify
  
   my $quoted_value = quotify $value;
  
  Quotes a single (non-reference) scalar value for use in a code string.  Numbers
  aren't treated specially and will be quoted as strings, but undef will quoted as
  C<undef()>.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head2 qsub
  
   my $hash = {
    coderef => qsub q{ print "hello"; },
    other   => 5,
   };
  
  Arguments: $code
  
  Works exactly like L</quote_sub>, but includes a prototype to only accept a
  single parameter.  This makes it easier to include in hash structures or lists.
  
  Exported by default.
  
  =head2 sanitize_identifier
  
   my $var_name = '$variable_for_' . sanitize_identifier('@name');
   quote_sub qq{ print \$${var_name} }, { $var_name => \$value };
  
  Arguments: $identifier
  
  Sanitizes a value so that it can be used in an identifier.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few
  caveats apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#moose@irc.perl.org>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for :html
  L<(click for instant chatroom login)|http://chat.mibbit.com/#web-simple@irc.perl.org>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Sub-Quote>
  
  Git repository: L<git://github.com/moose/Sub-Quote.git>
  
  Git browser: L<https://github.com/moose/Sub-Quote>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  dolmen - Olivier MenguÃ© (cpan:DOLMEN) <dolmen@cpan.org>
  
  alexbio - Alessandro Ghedini (cpan:ALEXBIO) <alexbio@cpan.org>
  
  getty - Torsten Raudssus (cpan:GETTY) <torsten@raudss.us>
  
  arcanez - Justin Hunter (cpan:ARCANEZ) <justin.d.hunter@gmail.com>
  
  kanashiro - Lucas Kanashiro (cpan:KANASHIRO) <kanashiro.duarte@gmail.com>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cfa.harvard.edu>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2016 the Sub::Quote L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
SUB_QUOTE

$fatpacked{"YAML/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP';
  # ABSTRACT: YAML Framework
  use strict;
  use warnings;
  package YAML::PP;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Schema;
  use YAML::PP::Schema::JSON;
  use YAML::PP::Loader;
  use YAML::PP::Dumper;
  use Scalar::Util qw/ blessed /;
  
  use base 'Exporter';
  our @EXPORT_OK = qw/ Load LoadFile Dump DumpFile /;
  
  sub new {
      my ($class, %args) = @_;
  
      my $bool = delete $args{boolean};
      $bool = 'perl' unless defined $bool;
      my $schemas = delete $args{schema} || ['JSON'];
      my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
      my $indent = delete $args{indent};
      my $writer = delete $args{writer};
      my $header = delete $args{header};
      my $footer = delete $args{footer};
      my $parser = delete $args{parser};
      my $emitter = delete $args{emitter} || {
          indent => $indent,
          writer => $writer,
      };
  
      my $schema;
      if (blessed($schemas) and $schemas->isa('YAML::PP::Schema')) {
          $schema = $schemas;
      }
      else {
          $schema = YAML::PP::Schema->new(
              boolean => $bool,
          );
          $schema->load_subschemas(@$schemas);
      }
  
      my $loader = YAML::PP::Loader->new(
          schema => $schema,
          cyclic_refs => $cyclic_refs,
          parser => $parser,
      );
      my $dumper = YAML::PP::Dumper->new(
          schema => $schema,
          emitter => $emitter,
          header => $header,
          footer => $footer,
      );
  
      my $self = bless {
          schema => $schema,
          loader => $loader,
          dumper => $dumper,
      }, $class;
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          schema => $self->schema,
          loader => $self->loader->clone,
          dumper => $self->dumper->clone,
      };
      return bless $clone, ref $self;
  }
  
  sub loader {
      if (@_ > 1) {
          $_[0]->{loader} = $_[1]
      }
      return $_[0]->{loader};
  }
  
  sub dumper {
      if (@_ > 1) {
          $_[0]->{dumper} = $_[1]
      }
      return $_[0]->{dumper};
  }
  
  sub schema {
      if (@_ > 1) { $_[0]->{schema} = $_[1] }
      return $_[0]->{schema};
  }
  
  sub default_schema {
      my ($self, %args) = @_;
      my $schema = YAML::PP::Schema->new(
          boolean => $args{boolean},
      );
      $schema->load_subschemas(qw/ JSON /);
      return $schema;
  }
  
  sub load_string {
      my ($self, $yaml) = @_;
      return $self->loader->load_string($yaml);
  }
  
  sub load_file {
      my ($self, $file) = @_;
      return $self->loader->load_file($file);
  }
  
  sub dump {
      my ($self, @data) = @_;
      return $self->dumper->dump(@data);
  }
  
  sub dump_string {
      my ($self, @data) = @_;
      return $self->dumper->dump_string(@data);
  }
  
  sub dump_file {
      my ($self, $file, @data) = @_;
      return $self->dumper->dump_file($file, @data);
  }
  
  # legagy interface
  sub Load {
      my ($yaml) = @_;
      YAML::PP->new->load_string($yaml);
  }
  
  sub LoadFile {
      my ($file) = @_;
      YAML::PP->new->load_file($file);
  }
  
  sub Dump {
      my (@data) = @_;
      YAML::PP->new->dump_string(@data);
  }
  
  sub DumpFile {
      my ($file, @data) = @_;
      YAML::PP->new->dump_file($file, @data);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP - YAML 1.2 processor
  
  =head1 SYNOPSIS
  
  WARNING: This is not yet stable.
  
  Here are a few examples of the basic load and dump methods:
  
      use YAML::PP;
      my $ypp = YAML::PP->new;
      my $yaml = <<'EOM';
      --- # Document one is a mapping
      name: Tina
      age: 29
      favourite language: Perl
  
      --- # Document two is a sequence
      - plain string
      - 'in single quotes'
      - "in double quotes we have escapes! like \t and \n"
      - | # a literal block scalar
        line1
        line2
      - > # a folded block scalar
        this is all one
        single line because the
        linebreaks will be folded
      EOM
  
      my @documents = $ypp->load_string($yaml);
      my @documents = $ypp->load_file($filename);
  
      my $yaml = $ypp->dump_string($data1, $data2);
      $ypp->dump_file($filename, $data1, $data2);
  
      # The loader offers JSON::PP::Boolean, boolean.pm or
      # perl 1/'' (currently default) for booleans
      my $ypp = YAML::PP->new(boolean => 'JSON::PP');
      my $ypp = YAML::PP->new(boolean => 'boolean');
      my $ypp = YAML::PP->new(boolean => 'perl');
  
      # Legacy interface
      use YAML::PP qw/ Load Dump LoadFile DumpFile /;
      my @documents = Load($yaml);
      my @documents = LoadFile($filename);
      my @documents = LoadFile($filehandle);
      my $yaml = = Dump(@documents);
      DumpFile($filename, @documents);
      DumpFile($filenhandle @documents);
  
      my $ypp = YAML::PP->new(schema => [qw/ JSON Perl /]);
      my $yaml = $yp->dump_string($data_with_perl_objects);
  
  
  Some utility scripts, mostly useful for debugging:
  
      # Load YAML into a data structure and dump with Data::Dumper
      yamlpp5-load < file.yaml
  
      # Load and Dump
      yamlpp5-load-dump < file.yaml
  
      # Print the events from the parser in yaml-test-suite format
      yamlpp5-events < file.yaml
  
      # Parse and emit events directly without loading
      yamlpp5-parse-emit < file.yaml
  
      # Create ANSI colored YAML. Can also be useful for invalid YAML, showing
      # you the exact location of the error
      yamlpp5-highlight < file.yaml
  
  
  =head1 DESCRIPTION
  
  YAML::PP is a modern, modular YAML processor.
  
  It aims to support C<YAML 1.2> and C<YAML 1.1>. See L<http://yaml.org/>.
  
  YAML is a serialization language. The YAML input is called "YAML Stream".
  A stream consists of one or more "Documents", seperated by a line with a
  document start marker C<--->. A document optionally ends with the document
  end marker C<...>.
  
  This allows to process continuous streams additionally to a fixed input
  file or string.
  
  The YAML::PP frontend will currently load all documents, and return only
  the last if called with scalar context.
  
  The YAML backend is implemented in a modular way that allows to add
  custom handling of YAML tags, perl objects and data types. The inner API
  is not yet stable. Suggestions welcome.
  
  You can check out all current parse and load results from the
  yaml-test-suite here:
  L<https://perlpunk.github.io/YAML-PP-p5/test-suite.html>
  
  
  =head1 PLUGINS
  
  You can alter the behaviour of YAML::PP by using the following schema
  classes:
  
  =over
  
  =item L<YAML::PP::Schema::Failsafe>
  
  One of the three YAML 1.2 official schemas
  
  =item L<YAML::PP::Schema::JSON>
  
  One of the three YAML 1.2 official schemas. Default
  
  =item L<YAML::PP::Schema::Core>
  
  One of the three YAML 1.2 official schemas
  
  =item L<YAML::PP::Schema::YAML1_1>
  
  Schema implementing the most common YAML 1.1 types
  
  =item L<YAML::PP::Schema::Perl>
  
  Serializing Perl objects and types
  
  =item L<YAML::PP::Schema::Binary>
  
  Serializing binary data
  
  =item L<YAML::PP::Schema::Tie::IxHash>
  
  In progress. Keeping hash key order.
  
  =item L<YAML::PP::Schema::Merge>
  
  YAML 1.1 merge keys for mappings
  
  =item L<YAML::PP::Schema::Include>
  
  Include other YAML files via C<!include> tags
  
  =back
  
  To make the parsing process faster, you can plugin the libyaml parser
  with L<YAML::PP::LibYAML>.
  
  =head1 IMPLEMENTATION
  
  The process of loading and dumping is split into the following steps:
  
      Load:
  
      YAML Stream        Tokens        Event List        Data Structure
                --------->    --------->        --------->
                  lex           parse           construct
  
  
      Dump:
  
      Data Structure       Event List        YAML Stream
                  --------->        --------->
                  represent           emit
  
  
  You can dump basic perl types like hashes, arrays, scalars (strings, numbers).
  For dumping blessed objects and things like coderefs have a look at
  L<YAML::PP::Perl>/L<YAML::PP::Schema::Perl>.
  
  For keeping your ordered L<Tie::IxHash> hashes, try out
  L<YAML::PP::Schema::Tie::IxHash>.
  
  =over
  
  =item L<YAML::PP::Lexer>
  
  The Lexer is reading the YAML stream into tokens. This makes it possible
  to generate syntax highlighted YAML output.
  
  Note that the API to retrieve the tokens will change.
  
  =item L<YAML::PP::Parser>
  
  The Parser retrieves the tokens from the Lexer. The main YAML content is then
  parsed with the Grammar.
  
  =item L<YAML::PP::Grammar>
  
  =item L<YAML::PP::Constructor>
  
  The Constructor creates a data structure from the Parser events.
  
  =item L<YAML::PP::Loader>
  
  The Loader combines the constructor and parser.
  
  =item L<YAML::PP::Dumper>
  
  The Dumper will delegate to the Representer
  
  =item L<YAML::PP::Representer>
  
  The Representer will create Emitter events from the given data structure.
  
  =item L<YAML::PP::Emitter>
  
  The Emitter creates a YAML stream.
  
  =back
  
  =head2 YAML::PP::Parser
  
  Still TODO:
  
  =over 4
  
  =item Implicit collection keys
  
      ---
      [ a, b, c ]: value
  
  =item Implicit mapping in flow syle sequences
  
      ---
      [ a, b, c: d ]
      # equals
      [ a, b, { c: d } ]
  
  =item Plain mapping keys ending with colons
  
      ---
      key ends with two colons::: value
  
  =item Supported Characters
  
  If you have valid YAML that's not parsed, or the other way round, please
  create an issue.
  
  =item Line and Column Numbers
  
  You will see line and column numbers in the error message. The column numbers
  might still be wrong in some cases.
  
  =item Error Messages
  
  The error messages need to be improved.
  
  =item Unicode Surrogate Pairs
  
  Currently loaded as single characters without validating
  
  =item Possibly more
  
  =back
  
  =head2 YAML::PP::Constructor
  
  The Constructor now supports all three YAML 1.2 Schemas, Failsafe, JSON and JSON.
  Additionally you can choose the schema for YAML 1.1 as C<YAML1_1>.
  
  Too see what strings are resolved as booleans, numbers, null etc. look at
  C<t/31.schema.t>.
  
  You can choose the Schema, however, the API for that is not yet fixed.
  Currently it looks like this:
  
      my $ypp = YAML::PP->new(schema => ['Core']); # default is 'JSON'
  
  The Tags C<!!seq> and C<!!map> are still ignored for now.
  
  It supports:
  
  =over 4
  
  =item Handling of Anchors/Aliases
  
  Like in modules like L<YAML>, the Constructor will use references for mappings and
  sequences, but obviously not for scalars.
  
  =item Boolean Handling
  
  You can choose between C<'perl'> (1/'', currently default), C<'JSON::PP'> and
  C<'boolean'>.pm for handling boolean types.  That allows you to dump the data
  structure with one of the JSON modules without losing information about
  booleans.
  
  =item Numbers
  
  Numbers are created as real numbers instead of strings, so that they are
  dumped correctly by modules like L<JSON::PP> or L<JSON::XS>, for example.
  
  See L<"NUMBERS"> for an example.
  
  =item Complex Keys
  
  Mapping Keys in YAML can be more than just scalars. Of course, you can't load
  that into a native perl structure. The Constructor will stringify those keys
  with L<Data::Dumper> instead of just returning something like
  C<HASH(0x55dc1b5d0178)>.
  
  Example:
  
      use YAML::PP;
      use JSON::PP;
      my $ypp = YAML::PP->new;
      my $coder = JSON::PP->new->ascii->pretty->allow_nonref->canonical;
      my $yaml = <<'EOM';
      complex:
          ?
              ?
                  a: 1
                  c: 2
              : 23
          : 42
      EOM
      my $data = $yppl->load_string($yaml);
      say $coder->encode($data);
      __END__
      {
         "complex" : {
            "{'{a => 1,c => 2}' => 23}" : 42
         }
      }
  
  =back
  
  TODO:
  
  =over 4
  
  =item Parse Tree
  
  I would like to generate a complete parse tree, that allows you to manipulate
  the data structure and also dump it, including all whitespaces and comments.
  The spec says that this is throwaway content, but I read that many people
  wish to be able to keep the comments.
  
  =back
  
  =head2 YAML::PP::Dumper, YAML::PP::Emitter
  
  The Dumper should be able to dump strings correctly, adding quotes
  whenever a plain scalar would look like a special string, like C<true>,
  or when it contains or starts with characters that are not allowed.
  
  Most strings will be dumped as plain scalars without quotes. If they
  contain special characters or have a special meaning, they will be dumped
  with single quotes. If they contain control characters, including <"\n">,
  they will be dumped with double quotes.
  
  It will recognize JSON::PP::Boolean and boolean.pm objects and dump them
  correctly.
  
  Numbers which also have a PV flag will be recognized as numbers and not
  as strings:
  
      my $int = 23;
      say "int: $int"; # $int will now also have a PV flag
  
  That means that if you accidentally use a string in numeric context, it will
  also be recognized as a number:
  
      my $string = "23";
      my $something = $string + 0;
      print $yp->dump_string($string);
      # will be emitted as an integer without quotes!
  
  The layout is like libyaml output:
  
      key:
      - a
      - b
      - c
      ---
      - key1: 1
        key2: 2
        key3: 3
      ---
      - - a1
        - a2
      - - b1
        - b2
  
  =head1 METHODS
  
  =over
  
  =item new
  
      my $ypp = YAML::PP->new;
      # load booleans via boolean.pm
      my $ypp = YAML::PP->new( boolean => 'boolean' );
      # load booleans via JSON::PP::true/false
      my $ypp = YAML::PP->new( boolean => 'JSON::PP' );
      
      # use YAML 1.2 Failsafe Schema
      my $ypp = YAML::PP->new( schema => ['Failsafe'] );
      # use YAML 1.2 JSON Schema
      my $ypp = YAML::PP->new( schema => ['JSON'] );
      # use YAML 1.2 Core Schema
      my $ypp = YAML::PP->new( schema => ['Core'] );
      
      # Die when detecting cyclic references
      my $ypp = YAML::PP->new( cyclic_refs => 'fatal' );
      # Other values:
      # warn   - Just warn about them and replace with undef
      # ignore - replace with undef
      # allow  - Default
      
      my $ypp = YAML::PP->new(
          boolean => 'JSON::PP',
          schema => ['JSON'],
          cyclic_refs => 'fatal',
          indent => 4, # use 4 spaces for dumping indentation
          header => 1, # default 1; print document header ---
          footer => 1, # default 0; print document footer ...
      );
  
  =item load_string
  
      my $doc = $ypp->load_string("foo: bar");
      my @docs = $ypp->load_string("foo: bar\n---\n- a");
  
  Input should be Unicode characters (decoded).
  
  =item load_file
  
      my $doc = $ypp->load_file("file.yaml");
      my @docs = $ypp->load_file("file.yaml");
  
  Strings will be loaded as unicode characters (decoded).
  
  =item dump_string
  
      my $yaml = $ypp->dump_string($doc);
      my $yaml = $ypp->dump_string($doc1, $doc2);
      my $yaml = $ypp->dump_string(@docs);
  
  Input strings should be Unicode characters. If not, they will be upgraded with
  C<utf8::upgrade>.
  
  Output will return Unicode characters (decoded).
  
  =item dump_file
  
      $ypp->dump_file("file.yaml", $doc);
      $ypp->dump_file("file.yaml", $doc1, $doc2);
      $ypp->dump_file("file.yaml", @docs);
  
  Input data should be UTF-8 decoded. If not, it will be upgraded with
  C<utf8::upgrade>.
  
  =item dump
  
  This will dump to a predefined writer. By default it will just use the
  L<YAML::PP::Writer> and output a string.
  
      my $writer = MyWriter->new(\my $output);
      my $yp = YAML::PP->new(
          writer => $writer,
      );
      $yp->dump($data);
  
  =item loader
  
  Returns or sets the loader object, by default L<YAML::PP::Loader>
  
  =item dumper
  
  Returns or sets the dumper object, by default L<YAML::PP::Dumper>
  
  =item schema
  
  Returns or sets the schema object
  
  =item default_schema
  
  Creates and returns the default schema
  
  =back
  
  =head1 FUNCTIONS
  
  The functions C<Load>, C<LoadFile>, C<Dump> and C<DumpFile> are provided
  as a drop-in replacement for other existing YAML processors.
  No function is exported by default.
  
  =over
  
  =item Load
  
      use YAML::PP qw/ Load /;
      my $doc = Load($yaml);
      my @docs = Load($yaml);
  
  Works like C<load_string>.
  
  =item LoadFile
  
      use YAML::PP qw/ LoadFile /;
      my $doc = LoadFile($file);
      my @docs = LoadFile($file);
      my @docs = LoadFile($filehandle);
  
  Works like C<load_file>.
  
  =item Dump
  
      use YAML::PP qw/ Dump /;
      my $yaml = Dump($doc);
      my $yaml = Dump(@docs);
  
  Works like C<dump_string>.
  
  =item DumpFile
  
      use YAML::PP qw/ DumpFile /;
      DumpFile($file, $doc);
      DumpFile($file, @docs);
      DumpFile($filehandle, @docs);
  
  Works like C<dump_file>.
  
  =back
  
  =head1 NUMBERS
  
  Compare the output of the following YAML Loaders and JSON::PP dump:
  
      use JSON::PP;
      use Devel::Peek;
  
      use YAML::XS ();
      use YAML ();
          $YAML::Numify = 1; # since version 1.23
      use YAML::Syck ();
          $YAML::Syck::ImplicitTyping = 1;
      use YAML::Tiny ();
      use YAML::PP;
  
      my $yaml = "foo: 23";
  
      my $d1 = YAML::XS::Load($yaml);
      my $d2 = YAML::Load($yaml);
      my $d3 = YAML::Syck::Load($yaml);
      my $d4 = YAML::Tiny->read_string($yaml)->[0];
      my $d5 = YAML::PP->new->load_string($yaml);
  
      Dump $d1->{foo};
      Dump $d2->{foo};
      Dump $d3->{foo};
      Dump $d4->{foo};
      Dump $d5->{foo};
  
      say encode_json($d1);
      say encode_json($d2);
      say encode_json($d3);
      say encode_json($d4);
      say encode_json($d5);
  
      SV = PVIV(0x55bbaff2bae0) at 0x55bbaff26518
        REFCNT = 1
        FLAGS = (IOK,POK,pIOK,pPOK)
        IV = 23
        PV = 0x55bbb06e67a0 "23"\0
        CUR = 2
        LEN = 10
      SV = PVMG(0x55bbb08959b0) at 0x55bbb08fc6e8
        REFCNT = 1
        FLAGS = (IOK,pIOK)
        IV = 23
        NV = 0
        PV = 0
      SV = IV(0x55bbaffcb3b0) at 0x55bbaffcb3c0
        REFCNT = 1
        FLAGS = (IOK,pIOK)
        IV = 23
      SV = PVMG(0x55bbaff2f1f0) at 0x55bbb08fc8c8
        REFCNT = 1
        FLAGS = (POK,pPOK,UTF8)
        IV = 0
        NV = 0
        PV = 0x55bbb0909d00 "23"\0 [UTF8 "23"]
        CUR = 2
        LEN = 10
      SV = PVMG(0x55bbaff2f6d0) at 0x55bbb08b2c10
        REFCNT = 1
        FLAGS = (IOK,pIOK)
        IV = 23
        NV = 0
        PV = 0
  
      {"foo":"23"}
      {"foo":23}
      {"foo":23}
      {"foo":"23"}
      {"foo":23}
  
  
  
  =head1 WHY
  
  All the available parsers and loaders for Perl are behaving differently,
  and more important, aren't conforming to the spec. L<YAML::XS> is
  doing pretty well, but C<libyaml> only handles YAML 1.1 and diverges
  a bit from the spec. The pure perl loaders lack support for a number of
  features.
  
  I was going over L<YAML>.pm issues end of 216, integrating old patches
  from rt.cpan.org and creating some pull requests myself. I realized
  that it would be difficult to patch YAML.pm to parse YAML 1.1 or even 1.2,
  and it would also break existing usages relying on the current behaviour.
  
  
  In 2016 Ingy dÃ¶t Net initiated two really cool projects:
  
  =over 4
  
  =item L<"YAML TEST SUITE">
  
  =item L<"YAML EDITOR">
  
  =back
  
  These projects are a big help for any developer. So I got the idea
  to write my own parser and started on New Year's Day 2017.
  Without the test suite and the editor I would have never started this.
  
  I also started another YAML Test project which allows to get a quick
  overview of which frameworks support which YAML features:
  
  =over 4
  
  =item L<"YAML TEST MATRIX">
  
  =back
  
  =head2 YAML TEST SUITE
  
  L<https://github.com/yaml/yaml-test-suite>
  
  It contains about 230 test cases and expected parsing events and more.
  There will be more tests coming. This test suite allows to write parsers
  without turning the examples from the Specification into tests yourself.
  Also the examples aren't completely covering all cases - the test suite
  aims to do that.
  
  The suite contains .tml files, and in a seperate 'data' branch you will
  find the content in seperate files, if you can't or don't want to
  use TestML.
  
  Thanks also to Felix Krause, who is writing a YAML parser in Nim.
  He turned all the spec examples into test cases.
  
  =head2 YAML EDITOR
  
  This is a tool to play around with several YAML parsers and loaders in vim.
  
  L<https://github.com/yaml/yaml-editor>
  
  The project contains the code to build the frameworks (16 as of this
  writing) and put it into one big Docker image.
  
  It also contains the yaml-editor itself, which will start a vim in the docker
  container. It uses a lot of funky vimscript that makes playing with it easy
  and useful. You can choose which frameworks you want to test and see the
  output in a grid of vim windows.
  
  Especially when writing a parser it is extremely helpful to have all
  the test cases and be able to play around with your own examples to see
  how they are handled.
  
  =head2 YAML TEST MATRIX
  
  I was curious to see how the different frameworks handle the test cases,
  so, using the test suite and the docker image, I wrote some code that runs
  the tests, manipulates the output to compare it with the expected output,
  and created a matrix view.
  
  L<https://github.com/perlpunk/yaml-test-matrix>
  
  You can find the latest build at L<http://matrix.yaml.io>
  
  As of this writing, the test matrix only contains valid test cases.
  Invalid ones will be added.
  
  =head1 CONTRIBUTORS
  
  =over
  
  =item Ingy dÃ¶t Net
  
  Ingy is one of the creators of YAML. In 2016 he started the YAML Test Suite
  and the YAML Editor. He also made useful suggestions on the class
  hierarchy of YAML::PP.
  
  =item Felix "flyx" Krause
  
  Felix answered countless questions about the YAML Specification.
  
  =back
  
  =head1 SEE ALSO
  
  =over
  
  =item L<YAML>
  
  =item L<YAML::XS>
  
  =item L<YAML::Syck>
  
  =item L<YAML::Tiny>
  
  =back
  
  =head1 SPONSORS
  
  The Perl Foundation L<https://www.perlfoundation.org/> sponsored this project
  (and the YAML Test Suite) with a grant of 2500 USD in 2017-2018.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2018 by Tina MÃ¼ller
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
YAML_PP

$fatpacked{"YAML/PP/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_COMMON';
  use strict;
  use warnings;
  package YAML::PP::Common;
  
  our $VERSION = '0.018'; # VERSION
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw/
      YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE
      YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE
      YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      YAML_QUOTED_SCALAR_STYLE
  
      YAML_ANY_SEQUENCE_STYLE
      YAML_BLOCK_SEQUENCE_STYLE YAML_FLOW_SEQUENCE_STYLE
  
      YAML_ANY_MAPPING_STYLE
      YAML_BLOCK_MAPPING_STYLE YAML_FLOW_MAPPING_STYLE
  /;
  
  use constant {
      YAML_ANY_SCALAR_STYLE           => 0,
      YAML_PLAIN_SCALAR_STYLE         => 1,
      YAML_SINGLE_QUOTED_SCALAR_STYLE => 2,
      YAML_DOUBLE_QUOTED_SCALAR_STYLE => 3,
      YAML_LITERAL_SCALAR_STYLE       => 4,
      YAML_FOLDED_SCALAR_STYLE        => 5,
      YAML_QUOTED_SCALAR_STYLE        => 'Q', # deprecated
  
      YAML_ANY_SEQUENCE_STYLE   => 'any',
      YAML_BLOCK_SEQUENCE_STYLE => 'block',
      YAML_FLOW_SEQUENCE_STYLE  => 'flow',
  
      YAML_ANY_MAPPING_STYLE   => 'any',
      YAML_BLOCK_MAPPING_STYLE => 'block',
      YAML_FLOW_MAPPING_STYLE  => 'flow',
  };
  
  my %scalar_style_to_string = (
      YAML_PLAIN_SCALAR_STYLE() => ':',
      YAML_SINGLE_QUOTED_SCALAR_STYLE() => "'",
      YAML_DOUBLE_QUOTED_SCALAR_STYLE() => '"',
      YAML_LITERAL_SCALAR_STYLE() => '|',
      YAML_FOLDED_SCALAR_STYLE() => '>',
  );
  
  
  sub event_to_test_suite {
      my ($event) = @_;
      my $ev = $event->{name};
          my $string;
          my $content = $event->{value};
  
          my $properties = '';
          $properties .= " &$event->{anchor}" if defined $event->{anchor};
          $properties .= " <$event->{tag}>" if defined $event->{tag};
  
          if ($ev eq 'document_start_event') {
              $string = "+DOC";
              $string .= " ---" unless $event->{implicit};
          }
          elsif ($ev eq 'document_end_event') {
              $string = "-DOC";
              $string .= " ..." unless $event->{implicit};
          }
          elsif ($ev eq 'stream_start_event') {
              $string = "+STR";
          }
          elsif ($ev eq 'stream_end_event') {
              $string = "-STR";
          }
          elsif ($ev eq 'mapping_start_event') {
              $string = "+MAP";
              $string .= $properties;
              if (0) {
                  # doesn't match yaml-test-suite format
                  if ($event->{style} and $event->{style} eq YAML_FLOW_MAPPING_STYLE) {
                      $string .= " {}";
                  }
              }
          }
          elsif ($ev eq 'sequence_start_event') {
              $string = "+SEQ";
              $string .= $properties;
              if (0) {
                  # doesn't match yaml-test-suite format
                  if ($event->{style} and $event->{style} eq YAML_FLOW_SEQUENCE_STYLE) {
                      $string .= " []";
                  }
              }
          }
          elsif ($ev eq 'mapping_end_event') {
              $string = "-MAP";
          }
          elsif ($ev eq 'sequence_end_event') {
              $string = "-SEQ";
          }
          elsif ($ev eq 'scalar_event') {
              $string = '=VAL';
              $string .= $properties;
  
              $content =~ s/\\/\\\\/g;
              $content =~ s/\t/\\t/g;
              $content =~ s/\r/\\r/g;
              $content =~ s/\n/\\n/g;
              $content =~ s/[\b]/\\b/g;
  
              $string .= ' '
                  . $scalar_style_to_string{ $event->{style} }
                  . $content;
          }
          elsif ($ev eq 'alias_event') {
              $string = "=ALI *$content";
          }
          return $string;
  }
  
  sub test_suite_to_event {
      my ($str) = @_;
      my $event = {};
      if ($str =~ s/^\+STR//) {
          $event->{name} = 'stream_start_event';
      }
      elsif ($str =~ s/^\-STR//) {
          $event->{name} = 'stream_end_event';
      }
      elsif ($str =~ s/^\+DOC//) {
          $event->{name} = 'document_start_event';
          if ($str =~ s/^ ---//) {
              $event->{implicit} = 0;
          }
          else {
              $event->{implicit} = 1;
          }
      }
      elsif ($str =~ s/^\-DOC//) {
          $event->{name} = 'document_end_event';
          if ($str =~ s/^ \.\.\.//) {
              $event->{implicit} = 0;
          }
          else {
              $event->{implicit} = 1;
          }
      }
      elsif ($str =~ s/^\+SEQ//) {
          $event->{name} = 'sequence_start_event';
          if ($str =~ s/^ \&(\S+)//) {
              $event->{anchor} = $1;
          }
          if ($str =~ s/^ <(\S+)>//) {
              $event->{tag} = $1;
          }
      }
      elsif ($str =~ s/^\-SEQ//) {
          $event->{name} = 'sequence_end_event';
      }
      elsif ($str =~ s/^\+MAP//) {
          $event->{name} = 'mapping_start_event';
          if ($str =~ s/^ \&(\S+)//) {
              $event->{anchor} = $1;
          }
          if ($str =~ s/^ <(\S+)>//) {
              $event->{tag} = $1;
          }
      }
      elsif ($str =~ s/^\-MAP//) {
          $event->{name} = 'mapping_end_event';
      }
      elsif ($str =~ s/^=VAL//) {
          $event->{name} = 'scalar_event';
          if ($str =~ s/^ <(\S+)>//) {
              $event->{tag} = $1;
          }
          if ($str =~ s/^ [:'">|]//) {
              $event->{style} = $1;
          }
          if ($str =~ s/^(.*)//) {
              $event->{value} = $1;
          }
      }
      elsif ($str =~ s/^=ALI//) {
          $event->{name} = 'alias_event';
          if ($str =~ s/^ \*(.*)//) {
              $event->{value} = $1;
          }
      }
      else {
          die "Could not parse event '$str'";
      }
      return $event;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Common - Constants and common functions
  
  =head1 SYNOPSIS
  
      use YAML::PP::Common qw/
          YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE
          YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE
          YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      /;
  
  =head1 DESCRIPTION
  
  =head1 FUNCTONS
  
  =over
  
  =item event_to_test_suite
  
      my $string = YAML::PP::Common::event_to_test_suite($event_prom_parser);
  
  For examples of the returned format look into this distributions's directory
  C<yaml-test-suite> which is a copy of
  L<https://github.com/yaml/yaml-test-suite>.
  
  =item test_suite_to_event
  
      my $event = YAML::PP::Common::test_suite_to_event($str);
  
  Turns an event string in test suite format into an event hashref. Not complete
  yet.
  
  =back
  
YAML_PP_COMMON

$fatpacked{"YAML/PP/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_CONSTRUCTOR';
  # ABSTRACT: Construct data structure from Parser Events
  use strict;
  use warnings;
  package YAML::PP::Constructor;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP;
  use Scalar::Util qw/ reftype /;
  
  use constant DEBUG => ($ENV{YAML_PP_LOAD_DEBUG} or $ENV{YAML_PP_LOAD_TRACE}) ? 1 : 0;
  use constant TRACE => $ENV{YAML_PP_LOAD_TRACE} ? 1 : 0;
  
  my %cyclic_refs = qw/ allow 1 ignore 1 warn 1 fatal 1 /;
  
  sub new {
      my ($class, %args) = @_;
  
      my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
      die "Invalid value for cyclic_refs: $cyclic_refs"
          unless $cyclic_refs{ $cyclic_refs };
      my $schema = delete $args{schema};
  
      if (keys %args) {
          die "Unexpected arguments: " . join ', ', sort keys %args;
      }
  
      my $self = bless {
          schema => $schema,
          cyclic_refs => $cyclic_refs,
      }, $class;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          schema => $self->schema,
          cyclic_refs => $self->cyclic_refs,
      };
      return bless $clone, ref $self;
  }
  
  sub init {
      my ($self) = @_;
      $self->set_docs([]);
      $self->set_stack([]);
      $self->set_anchors({});
  }
  
  sub docs { return $_[0]->{docs} }
  sub stack { return $_[0]->{stack} }
  sub anchors { return $_[0]->{anchors} }
  sub set_docs { $_[0]->{docs} = $_[1] }
  sub set_stack { $_[0]->{stack} = $_[1] }
  sub set_anchors { $_[0]->{anchors} = $_[1] }
  sub schema { return $_[0]->{schema} }
  sub set_schema { $_[0]->{schema} = $_[1] }
  sub cyclic_refs { return $_[0]->{cyclic_refs} }
  sub set_cyclic_refs { $_[0]->{cyclic_refs} = $_[1] }
  
  sub document_start_event {
      my ($self, $event) = @_;
      my $stack = $self->stack;
      my $ref = [];
      push @$stack, { type => 'document', ref => $ref, data => $ref, event => $event };
  }
  
  sub document_end_event {
      my ($self, $event) = @_;
      my $stack = $self->stack;
      my $last = pop @$stack;
      $last->{type} eq 'document' or die "Expected mapping, but got $last->{type}";
      if (@$stack) {
          die "Got unexpected end of document";
      }
      my $docs = $self->docs;
      push @$docs, $last->{ref}->[0];
      $self->set_anchors({});
      $self->set_stack([]);
  }
  
  sub mapping_start_event {
      my ($self, $event) = @_;
      my ($data, $on_data) = $self->schema->create_mapping($self, $event);
      my $ref = {
          type => 'mapping',
          ref => [],
          data => $data,
          event => $event,
          on_data => $on_data,
      };
      my $stack = $self->stack;
  
      push @$stack, $ref;
      if (defined(my $anchor = $event->{anchor})) {
          $self->anchors->{ $anchor } = { data => $ref->{data} };
      }
  }
  
  sub mapping_end_event {
      my ($self, $event) = @_;
      my $stack = $self->stack;
  
      my $last = pop @$stack;
      my ($ref, $data) = @{ $last }{qw/ ref data /};
      $last->{type} eq 'mapping' or die "Expected mapping, but got $last->{type}";
  
      my @merge_keys;
      my @ref;
      for (my $i = 0; $i < @$ref; $i += 2) {
          my $key = $ref->[ $i ];
          if (ref $key eq 'YAML::PP::Type::MergeKey') {
              my $merge = $ref->[ $i + 1 ];
              if ((reftype($merge) || '') eq 'HASH') {
                  push @merge_keys, $merge;
              }
              elsif ((reftype($merge) || '') eq 'ARRAY') {
                  for my $item (@$merge) {
                      if ((reftype($item) || '') eq 'HASH') {
                          push @merge_keys, $item;
                      }
                      else {
                          die "Expected hash for merge key";
                      }
                  }
              }
              else {
                  die "Expected hash or array for merge key";
              }
          }
          else {
              push @ref, $key, $ref->[ $i + 1 ];
          }
      }
      for my $merge (@merge_keys) {
          for my $key (keys %$merge) {
              unless (exists $data->{ $key }) {
                  $data->{ $key } = $merge->{ $key };
              }
          }
      }
      my $on_data = $last->{on_data} || sub {
          my ($self, $hash, $items) = @_;
          for (my $i = 0; $i < @$items; $i += 2) {
              my ($key, $value) = @$items[ $i, $i + 1 ];
              $key = '' unless defined $key;
              if (ref $key) {
                  $key = $self->stringify_complex($key);
              }
              $$hash->{ $key } = $value;
          }
      };
      $on_data->($self, \$data, \@ref);
      push @{ $stack->[-1]->{ref} }, $data;
      if (defined(my $anchor = $last->{event}->{anchor})) {
          $self->anchors->{ $anchor }->{finished} = 1;
      }
      return;
  }
  
  sub sequence_start_event {
      my ($self, $event) = @_;
      my ($data, $on_data) = $self->schema->create_sequence($self, $event);
      my $ref = {
          type => 'sequence',
          ref => [],
          data => $data,
          event => $event,
          on_data => $on_data,
      };
      my $stack = $self->stack;
  
      push @$stack, $ref;
      if (defined(my $anchor = $event->{anchor})) {
          $self->anchors->{ $anchor } = { data => $ref->{data} };
      }
  }
  
  sub sequence_end_event {
      my ($self, $event) = @_;
      my $stack = $self->stack;
      my $last = pop @$stack;
      $last->{type} eq 'sequence' or die "Expected mapping, but got $last->{type}";
      my ($ref, $data) = @{ $last }{qw/ ref data /};
  
      my $on_data = $last->{on_data} || sub {
          my ($self, $array, $items) = @_;
          push @$$array, @$items;
      };
      $on_data->($self, \$data, $ref);
      push @{ $stack->[-1]->{ref} }, $data;
      if (defined(my $anchor = $last->{event}->{anchor})) {
          $self->anchors->{ $anchor }->{finished} = 1;
      }
      return;
  }
  
  sub stream_start_event {}
  
  sub stream_end_event {}
  
  sub scalar_event {
      my ($self, $event) = @_;
      DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";
      my $value = $self->schema->load_scalar($self, $event);
      if (defined (my $name = $event->{anchor})) {
          $self->anchors->{ $name } = { data => $value, finished => 1 };
      }
      my $last = $self->stack->[-1];
      push @{ $last->{ref} }, $value;
  }
  
  sub alias_event {
      my ($self, $event) = @_;
      my $value;
      my $name = $event->{value};
      if (my $anchor = $self->anchors->{ $name }) {
          # We know this is a cyclic ref since the node hasn't
          # been constructed completely yet
          unless ($anchor->{finished} ) {
              my $cyclic_refs = $self->cyclic_refs;
              if ($cyclic_refs ne 'allow') {
                  if ($cyclic_refs eq 'fatal') {
                      die "Found cyclic ref";
                  }
                  if ($cyclic_refs eq 'warn') {
                      $anchor = { data => undef };
                      warn "Found cyclic ref";
                  }
                  elsif ($cyclic_refs eq 'ignore') {
                      $anchor = { data => undef };
                  }
              }
          }
          $value = $anchor->{data};
      }
      my $last = $self->stack->[-1];
      push @{ $last->{ref} }, $value;
  }
  
  sub stringify_complex {
      my ($self, $data) = @_;
      require Data::Dumper;
      local $Data::Dumper::Quotekeys = 0;
      local $Data::Dumper::Terse = 1;
      local $Data::Dumper::Indent = 0;
      local $Data::Dumper::Useqq = 0;
      local $Data::Dumper::Sortkeys = 1;
      my $string = Data::Dumper->Dump([$data], ['data']);
      $string =~ s/^\$data = //;
      return $string;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Constructor - Constructing data structure from parsing events
  
  =head1 METHODS
  
  =over
  
  =item new
  
  The Constructor constructor
  
      my $constructor = YAML::PP::Constructor->new(
          schema => $schema,
          cyclic_refs => $cyclic_refs,
      );
  
  =item init
  
  Resets any data being used during construction.
  
      $constructor->init;
  
  =item document_start_event, document_end_event, mapping_start_event, mapping_end_event, sequence_start_event, sequence_end_event, scalar_event, alias_event, stream_start_event, stream_end_event
  
  These methods are called from L<YAML::PP::Parser>:
  
      $constructor->document_start_event($event);
  
  =item anchors, set_anchors
  
  Helper for storing anchors during construction
  
  =item docs, set_docs
  
  Helper for storing resulting documents during construction
  
  =item stack, set_stack
  
  Helper for storing data during construction
  
  =item cyclic_refs, set_cyclic_refs
  
  Option for controlling the behaviour when finding circular references
  
  =item schema, set_schema
  
  Holds a L<YAML::PP::Schema> object
  
  =item stringify_complex
  
  When constructing a hash and getting a non-scalar key, this method is
  used to stringify the key.
  
  It uses a terse Data::Dumper output. Other modules, like L<YAML::XS>, use
  the default stringification, C<ARRAY(0x55617c0c7398)> for example.
  
  =back
  
  =cut
YAML_PP_CONSTRUCTOR

$fatpacked{"YAML/PP/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_DUMPER';
  use strict;
  use warnings;
  package YAML::PP::Dumper;
  
  our $VERSION = '0.018'; # VERSION
  
  use Scalar::Util qw/ blessed refaddr reftype /;
  use YAML::PP;
  use YAML::PP::Emitter;
  use YAML::PP::Representer;
  use YAML::PP::Writer;
  use YAML::PP::Writer::File;
  use YAML::PP::Common qw/
      YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
      YAML_DOUBLE_QUOTED_SCALAR_STYLE
      YAML_ANY_SCALAR_STYLE
      YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
      YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE
  /;
  
  sub new {
      my ($class, %args) = @_;
  
      my $header = delete $args{header};
      $header = 1 unless defined $header;
      my $footer = delete $args{footer};
      $footer = 0 unless defined $footer;
  
      my $schema = delete $args{schema} || YAML::PP->default_schema(
          boolean => 'perl',
      );
  
      my $emitter = delete $args{emitter} || YAML::PP::Emitter->new;
      unless (blessed($emitter)) {
          $emitter = YAML::PP::Emitter->new(
              %$emitter
          );
      }
      my $self = bless {
          representer => YAML::PP::Representer->new(
              schema => $schema,
          ),
          emitter => $emitter,
          seen => {},
          anchors => {},
          anchor_num => 0,
          header => $header,
          footer => $footer,
      }, $class;
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          representer => $self->representer->clone,
          emitter => $self->emitter->clone,
          seen => {},
          anchors => {},
          anchor_num => 0,
          header => $self->header,
          footer => $self->footer,
      };
      return bless $clone, ref $self;
  }
  
  sub init {
      my ($self) = @_;
      $self->{seen} = {};
      $self->{anchors} = {};
      $self->{anchor_num} = 0;
  }
  
  sub emitter { return $_[0]->{emitter} }
  sub representer { return $_[0]->{representer} }
  sub set_representer { $_[0]->{representer} = $_[1] }
  sub header { return $_[0]->{header} }
  sub footer { return $_[0]->{footer} }
  
  sub dump {
      my ($self, @docs) = @_;
      $self->emitter->init;
  
      $self->emitter->stream_start_event({});
  
      for my $i (0 .. $#docs) {
          my $header_implicit = ($i == 0 and not $self->header);
          $self->emitter->document_start_event({ implicit => $header_implicit });
          $self->init;
          $self->check_references($docs[ $i ]);
          $self->dump_node($docs[ $i ]);
          my $footer_implicit = (not $self->footer);
          $self->emitter->document_end_event({ implicit => $footer_implicit });
      }
  
      $self->emitter->stream_end_event({});
  
      my $output = $self->emitter->writer->output;
      $self->emitter->finish;
      return $output;
  }
  
  sub dump_node {
      my ($self, $value) = @_;
      my $node = {
          value => $value,
      };
      if (ref $value) {
  
          my $seen = $self->{seen};
          my $refaddr = refaddr $value;
          if ($seen->{ $refaddr } and $seen->{ $refaddr } > 1) {
              my $anchor = $self->{anchors}->{ $refaddr };
              unless (defined $anchor) {
                  my $num = ++$self->{anchor_num};
                  $self->{anchors}->{ $refaddr } = $num;
                  $node->{anchor} = $num;
              }
              else {
                  $node->{value} = $anchor;
                  $self->emit_node([ alias => $node ]);
                  return;
              }
  
          }
      }
      $node = $self->representer->represent_node($node);
      $self->emit_node($node);
  }
  
  sub emit_node {
      my ($self, $item) = @_;
      my ($type, $node) = @$item;
      if ($type eq 'alias') {
          $self->emitter->alias_event({ value => $node->{value} });
          return;
      }
      if ($type eq 'mapping') {
          my $style = YAML_BLOCK_MAPPING_STYLE;
          $self->emitter->mapping_start_event({
              anchor => $node->{anchor},
              style => $style,
              tag => $node->{tag},
          });
          for (@{ $node->{items} }) {
              $self->dump_node($_);
          }
          $self->emitter->mapping_end_event;
          return;
      }
      if ($type eq 'sequence') {
          my $style = YAML_BLOCK_SEQUENCE_STYLE;
          $self->emitter->sequence_start_event({
              anchor => $node->{anchor},
              style => $style,
              tag => $node->{tag},
          });
          for (@{ $node->{items} }) {
              $self->dump_node($_);
          }
          $self->emitter->sequence_end_event;
          return;
      }
      $self->emitter->scalar_event({
          value => $node->{items}->[0],
          style => $node->{style},
          anchor => $node->{anchor},
          tag => $node->{tag},
      });
  }
  
  
  sub dump_string {
      my ($self, @docs) = @_;
      my $writer = YAML::PP::Writer->new;
      $self->emitter->set_writer($writer);
      my $output = $self->dump(@docs);
      return $output;
  }
  
  sub dump_file {
      my ($self, $file, @docs) = @_;
      my $writer = YAML::PP::Writer::File->new(output => $file);
      $self->emitter->set_writer($writer);
      my $output = $self->dump(@docs);
      return $output;
  }
  
  my %_reftypes = (
      HASH => 1,
      ARRAY => 1,
      Regexp => 1,
      REGEXP => 1,
      CODE => 1,
      SCALAR => 1,
      REF => 1,
  );
  
  sub check_references {
      my ($self, $doc) = @_;
      my $reftype = reftype $doc or return;
      my $seen = $self->{seen};
      # check which references are used more than once
      if (++$seen->{ refaddr $doc } > 1) {
          # seen already
          return;
      }
      unless ($_reftypes{ $reftype }) {
          die sprintf "Reference %s not implemented",
              $reftype;
      }
      if ($reftype eq 'HASH') {
          $self->check_references($doc->{ $_ }) for keys %$doc;
      }
      elsif ($reftype eq 'ARRAY') {
          $self->check_references($_) for @$doc;
      }
      elsif ($reftype eq 'REF') {
          $self->check_references($$doc);
      }
  }
  
  1;
YAML_PP_DUMPER

$fatpacked{"YAML/PP/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EMITTER';
  use strict;
  use warnings;
  package YAML::PP::Emitter;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Common qw/
      YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
      YAML_DOUBLE_QUOTED_SCALAR_STYLE
      YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
  /;
  
  use constant DEBUG => $ENV{YAML_PP_EMIT_DEBUG} ? 1 : 0;
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          indent => $args{indent} || 2,
          writer => $args{writer},
      }, $class;
      $self->init;
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          indent => $self->indent,
      };
      return bless $clone, ref $self;
  }
  
  sub event_stack { return $_[0]->{event_stack} }
  sub set_event_stack { $_[0]->{event_stack} = $_[1] }
  sub indent { return $_[0]->{indent} }
  sub set_indent { $_[0]->{indent} = $_[1] }
  sub writer { $_[0]->{writer} }
  sub set_writer { $_[0]->{writer} = $_[1] }
  sub tagmap { return $_[0]->{tagmap} }
  sub set_tagmap { $_[0]->{tagmap} = $_[1] }
  
  sub init {
      my ($self) = @_;
      unless ($self->writer) {
          $self->set_writer(YAML::PP::Writer->new);
      }
      $self->set_tagmap({
          'tag:yaml.org,2002:' => '!!',
      });
      $self->writer->init;
  }
  
  sub mapping_start_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
      my $last = $stack->[-1];
      my $indent = $last->{indent};
      my $new_indent = $indent;
  
      my $props = '';
      my $anchor = $info->{anchor};
      my $tag = $info->{tag};
      if (defined $anchor) {
          $anchor = "&$anchor";
      }
      if (defined $tag) {
          $tag = $self->emit_tag('map', $tag);
      }
      $props = join ' ', grep defined, ($anchor, $tag);
      my $append = $last->{append};
  
      my $new_append = 0;
      my $yaml = '';
      if ($last->{type} eq 'DOC') {
          if ($append and $props) {
              $yaml .= " $props";
          }
          elsif ($props) {
              $yaml .= "$props";
          }
          if ($append or $props) {
              $yaml .= "\n";
          }
      }
      elsif ($last->{type} eq 'MAPVALUE') {
          if ($props) {
              $yaml .= " $props";
          }
          $yaml .= "\n";
          $new_indent .= ' ' x $self->indent;
      }
      else {
          $new_indent .= ' ' x $self->indent;
          if ($append) {
              $yaml .= " ";
          }
          else {
              $yaml .= $indent;
          }
          if ($last->{type} eq 'SEQ') {
              $yaml .= '-';
          }
          elsif ($last->{type} eq 'MAP') {
              $yaml .= "?";
              $last->{type} = 'COMPLEX';
          }
          elsif ($last->{type} eq 'COMPLEX') {
              $yaml .= ":";
              $last->{type} = 'COMPLEXVALUE';
          }
          else {
              die "Unexpected";
          }
          if ($props) {
              $yaml .= " $props\n";
          }
          else {
              $new_append = 1;
          }
      }
      $self->writer->write($yaml);
      my $new_info = { index => 0, indent => $new_indent, info => $info, append => $new_append };
      if (($info->{style} || '') eq YAML_FLOW_MAPPING_STYLE) {
  #        $new_info->{type} = 'FLOWMAP';
          $new_info->{type} = 'MAP';
      }
      else {
          $new_info->{type} = 'MAP';
      }
      push @{ $stack }, $new_info;
      $last->{index}++;
      $last->{append} = 0;
  }
  
  sub mapping_end_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
  
      my $last = pop @{ $stack };
      if ($last->{index} == 0) {
          my $indent = $last->{indent};
          my $zero_indent = $last->{zero_indent};
          if ($last->{zero_indent}) {
              $indent .= ' ' x $self->indent;
          }
          if ($last->{append}) {
              $self->writer->write(" {}\n");
          }
          else {
              $self->writer->write("$indent\{}\n");
          }
      }
      $last = $stack->[-1];
      if ($last->{type} eq 'SEQ') {
      }
      elsif ($last->{type} eq 'MAP') {
          $last->{type} = 'MAPVALUE';
      }
      elsif ($last->{type} eq 'MAPVALUE') {
          $last->{type} = 'MAP';
      }
  }
  
  sub sequence_start_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
      my $last = $stack->[-1];
      my $indent = $last->{indent};
      my $new_indent = $indent;
      my $yaml = '';
  
      my $props = '';
      my $anchor = $info->{anchor};
      my $tag = $info->{tag};
      if (defined $anchor) {
          $anchor = "&$anchor";
      }
      if (defined $tag) {
          $tag = $self->emit_tag('seq', $tag);
      }
      $props = join ' ', grep defined, ($anchor, $tag);
  
      my $new_append = 0;
      my $zero_indent = 0;
      my $append = $last->{append};
      if ($last->{type} eq 'DOC') {
          if ($append and $props) {
              $yaml .= " $props";
          }
          elsif ($props) {
              $yaml .= "$props";
          }
          if ($append or $props) {
              $yaml .= "\n";
          }
      }
      else {
          if ($last->{type} eq 'MAPVALUE') {
              $zero_indent = 1;
          }
          else {
              if ($append) {
                  $yaml .= ' ';
              }
              else {
                  $yaml .= $indent;
              }
              $new_indent .= ' ' x $self->indent;
              unless ($props) {
                  $new_append = 1;
              }
              if ($last->{type} eq 'SEQ') {
                  $yaml .= "-";
              }
              elsif ($last->{type} eq 'MAP') {
                  $yaml .= "?";
                  $last->{type} = 'COMPLEX';
              }
              elsif ($last->{type} eq 'COMPLEXVALUE') {
                  $yaml .= ":";
              }
          }
          if ($props) {
              $yaml .= " $props";
          }
          if (not $new_append) {
              $yaml .= "\n";
          }
      }
      $self->writer->write($yaml);
      $last->{index}++;
      $last->{append} = 0;
      my $new_info = {
          index => 0,
          indent => $new_indent,
          info => $info,
          append => $new_append,
          zero_indent => $zero_indent,
      };
      if (($info->{style} || '') eq YAML_FLOW_SEQUENCE_STYLE) {
          $new_info->{type} = 'FLOWSEQ';
      }
      else {
          $new_info->{type} = 'SEQ';
      }
      push @{ $stack }, $new_info;
  }
  
  sub sequence_end_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
  
      my $last = pop @{ $stack };
      if ($last->{index} == 0) {
          my $indent = $last->{indent};
          my $zero_indent = $last->{zero_indent};
          if ($last->{zero_indent}) {
              $indent .= ' ' x $self->indent;
          }
          if ($last->{append}) {
              $self->writer->write(" []\n");
          }
          else {
              $self->writer->write("$indent\[]\n");
          }
      }
      $last = $stack->[-1];
      if ($last->{type} eq 'MAP') {
          $last->{type} = 'MAPVALUE';
      }
      elsif ($last->{type} eq 'MAPVALUE') {
          $last->{type} = 'MAP';
      }
      elsif ($last->{type} eq 'COMPLEX') {
          $last->{type} = 'COMPLEXVALUE';
      }
      elsif ($last->{type} eq 'COMPLEXVALUE') {
          $last->{type} = 'MAP';
      }
      elsif ($last->{type} eq 'SEQ') {
      }
  }
  
  my %forbidden_first = (qw/
      ! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1
  /, '#' => 1, '%' => 1, ',' => 1, " " => 1);
  my %forbidden_first_plus_space = (qw/
      ? 1 - 1 : 1
  /);
  
  my %control = (
      "\x00" => '\0',
      "\x01" => '\x01',
      "\x02" => '\x02',
      "\x03" => '\x03',
      "\x04" => '\x04',
      "\x05" => '\x05',
      "\x06" => '\x06',
      "\x07" => '\a',
      "\x08" => '\b',
      "\x0b" => '\v',
      "\x0c" => '\f',
      "\x0e" => '\x0e',
      "\x0f" => '\x0f',
      "\x10" => '\x10',
      "\x11" => '\x11',
      "\x12" => '\x12',
      "\x13" => '\x13',
      "\x14" => '\x14',
      "\x15" => '\x15',
      "\x16" => '\x16',
      "\x17" => '\x17',
      "\x18" => '\x18',
      "\x19" => '\x19',
      "\x1a" => '\x1a',
      "\x1b" => '\e',
      "\x1c" => '\x1c',
      "\x1d" => '\x1d',
      "\x1e" => '\x1e',
      "\x1f" => '\x1f',
      "\x{2029}" => '\P',
      "\x{2028}" => '\L',
      "\x85" => '\N',
      "\xa0" => '\_',
  );
  
  my $control_re = '\x00-\x08\x0b\x0c\x0e-\x1f\x{2029}\x{2028}\x85\xa0';
  my %to_escape = (
      "\n" => '\n',
      "\t" => '\t',
      "\r" => '\r',
      '\\' => '\\\\',
      '"' => '\\"',
      %control,
  );
  my $escape_re = $control_re . '\n\t\r';
  my $escape_re_without_lb = $control_re . '\t\r';
  
  
  sub scalar_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
      my $last = $stack->[-1];
      my $indent = $last->{indent};
      my $value = $info->{value};
      unless (utf8::is_utf8($value)) {
          utf8::upgrade($value);
      }
  
      my $props = '';
      my $anchor = $info->{anchor};
      my $tag = $info->{tag};
      if (defined $anchor) {
          $anchor = "&$anchor";
      }
      if (defined $tag) {
          $tag = $self->emit_tag('scalar', $tag);
      }
      $props = join ' ', grep defined, ($anchor, $tag);
  
      my $append = $last->{append};
  
      my $style = $info->{style};
      DEBUG and local $Data::Dumper::Useqq = 1;
      $value = '' unless defined $value;
      if (not $style and $value eq '') {
          $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
      }
      $style ||= YAML_PLAIN_SCALAR_STYLE;
  
      my $first = substr($value, 0, 1);
      # no control characters anywhere
      if ($style ne YAML_DOUBLE_QUOTED_SCALAR_STYLE and $value =~ m/[$control_re]/) {
          $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
      }
      elsif ($style eq YAML_SINGLE_QUOTED_SCALAR_STYLE) {
          if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/) {
              $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value eq "\n") {
              $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
          }
      }
      elsif ($style eq YAML_LITERAL_SCALAR_STYLE or $style eq YAML_FOLDED_SCALAR_STYLE) {
      }
      elsif ($style eq YAML_PLAIN_SCALAR_STYLE) {
          if ($value =~ m/[$escape_re_without_lb]/) {
              $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value eq "\n") {
              $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value =~ m/\n/) {
              $style = YAML_LITERAL_SCALAR_STYLE;
          }
          elsif ($forbidden_first{ $first }) {
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          elsif (substr($value, 0, 2) =~ m/^([:?-] )/) {
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value =~ m/: /) {
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value =~ m/ #/) {
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value =~ m/[: \t]\z/) {
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/) {
              # TODO exclude ,[]{} in flow collections
              $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
          }
          else {
              $style = YAML_PLAIN_SCALAR_STYLE;
          }
      }
  
      if ($style eq YAML_PLAIN_SCALAR_STYLE) {
          if ($forbidden_first_plus_space{ $first }) {
              if (length ($value) == 1 or substr($value, 1, 1) =~ m/^\s/) {
                  $style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
              }
          }
      }
  
      if (($style eq YAML_LITERAL_SCALAR_STYLE or $style eq YAML_FOLDED_SCALAR_STYLE) and $value eq '') {
          $style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
      }
      if ($style eq YAML_PLAIN_SCALAR_STYLE) {
          $value =~ s/\n/\n\n/g;
      }
      elsif ($style eq YAML_SINGLE_QUOTED_SCALAR_STYLE) {
          my $new_indent = $last->{indent} . (' ' x $self->indent);
          $value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;
          my @lines = split m/\n/, $value, -1;
          if (@lines > 1) {
              for my $line (@lines[1 .. $#lines]) {
                  $line = $new_indent . $line
                      if length $line;
              }
          }
          $value = join "\n", @lines;
          $value =~ s/'/''/g;
          $value = "'" . $value . "'";
      }
      elsif ($style eq YAML_LITERAL_SCALAR_STYLE) {
          DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value], ['value']);
          my $indicators = '';
          if ($value =~ m/\A\n* +/) {
              $indicators .= $self->indent;
          }
          if ($value !~ m/\n\z/) {
              $indicators .= '-';
              $value .= "\n";
          }
          elsif ($value =~ m/(\n|\A)\n\z/) {
              $indicators .= '+';
          }
          $value =~ s/^(?=.)/$indent  /gm;
          $value = "|$indicators\n$value";
      }
      elsif ($style eq YAML_FOLDED_SCALAR_STYLE) {
          DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value], ['value']);
          my @lines = split /\n/, $value, -1;
          DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines], ['lines']);
          my $eol = 0;
          my $indicators = '';
          if ($value =~ m/\A\n* +/) {
              $indicators .= $self->indent;
          }
          if ($lines[-1] eq '') {
              pop @lines;
              $eol = 1;
          }
          else {
              $indicators .= '-';
          }
          $value = ">$indicators\n";
          for my $i (0 .. $#lines) {
              my $line = $lines[ $i ];
              if (length $line) {
                  $value .= "$indent  $line\n";
              }
              if ($i != $#lines) {
                  $value .= "\n";
              }
          }
      }
      else {
          $value =~ s/([$escape_re"\\])/$to_escape{ $1 }/g;
          $value = '"' . $value . '"';
      }
  
      DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";
      my $yaml = '';
      my $pvalue = $props;
      if ($props and length $value) {
          $pvalue .= " $value";
      }
      elsif (length $value) {
          $pvalue .= $value;
      }
      my $multiline = ($style eq YAML_LITERAL_SCALAR_STYLE or $style eq YAML_FOLDED_SCALAR_STYLE);
      if ($last->{type} eq 'MAP') {
  
          if ($props and not length $value) {
              $pvalue .= ' ';
          }
          my $new_event = 'MAPVALUE';
          if ($multiline) {
              # oops, a complex key
              if (not $append) {
                  $yaml .= $indent;
              }
              else {
                  $yaml .= " ";
              }
              $yaml .= "?";
              $append = 1;
              $new_event = 'COMPLEXVALUE';
          }
          if ($append) {
              $yaml .= " ";
          }
          else {
              $yaml .= $indent;
          }
          $yaml .= $pvalue;
          if (not $multiline) {
              $yaml .= ":";
          }
          $last->{type} = $new_event;
      }
      elsif ($last->{type} eq 'COMPLEXVALUE') {
          if ($append) {
              $yaml .= " ";
          }
          else {
              $yaml .= $indent;
          }
          if (length $pvalue) {
              $yaml .= ": $pvalue";
          }
          else {
              $yaml .= ":";
          }
          if (not $multiline) {
              $yaml .= "\n";
          }
          $last->{type} = 'MAP';
      }
      else {
          if ($last->{type} eq 'MAPVALUE') {
              if (length $pvalue) {
                  $yaml .= " $pvalue";
              }
              $last->{type} = 'MAP';
          }
          elsif ($last->{type} eq 'SEQ') {
              if (not $append) {
                  $yaml .= $indent;
              }
              else {
                  $yaml .= " ";
              }
              $yaml .= "-";
              if (length $pvalue) {
                  $yaml .= " $pvalue";
              }
          }
          elsif ($last->{type} eq 'DOC') {
              if (length $pvalue) {
                  if ($append) {
                      $yaml .= " ";
                  }
                  $yaml .= $pvalue;
              }
          }
          else {
  #            warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$last], ['last']);
              die "Unexpected";
          }
          if (not $multiline) {
              $yaml .= "\n";
          }
      }
      $last->{index}++;
      $last->{append} = 0;
      $self->writer->write($yaml);
  }
  
  sub alias_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";
      my ($self, $info) = @_;
      my $stack = $self->event_stack;
      my $last = $stack->[-1];
      $last->{index}++;
      my $append = $last->{append};
      my $indent = $last->{indent};
  
      my $alias = '*' . $info->{value};
  
      if ($last->{type} eq 'MAP') {
          my $yaml = '';
          if ($append) {
              $yaml .= " ";
          }
          else {
              $yaml .= $indent;
          }
          $self->writer->write("$yaml$alias :");
          $last->{type} = 'MAPVALUE';
      }
      elsif ($last->{type} eq 'MAPVALUE') {
          $self->writer->write(" $alias\n");
          $last->{type} = 'MAP';
      }
      elsif ($last->{type} eq 'SEQ') {
          my $yaml = '';
          if (not $append) {
              $yaml .= $indent;
          }
          else {
              $yaml .= " ";
          }
          $yaml .= "- $alias\n";
          $self->writer->write($yaml);
      }
      elsif ($last->{type} eq 'DOC') {
          # TODO an alias at document level isn't actually valid
          $self->writer->write("$alias\n");
      }
      else {
          $self->writer->write("$indent: $alias\n");
          $last->{type} = 'MAP';
      }
      $last->{append} = 0;
  }
  
  sub document_start_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";
      my ($self, $info) = @_;
      my $new_append = 0;
      if ($info->{implicit}) {
          $new_append = 0;
      }
      else {
          $new_append = 1;
          $self->writer->write("---");
      }
      $self->set_event_stack([
          { type => 'DOC', index => 0, indent => '', info => $info, append => $new_append }
      ]);
  }
  
  sub document_end_event {
      DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";
      my ($self, $info) = @_;
      $self->set_event_stack([]);
      unless ($info->{implicit}) {
          $self->writer->write("...\n");
      }
  }
  
  sub stream_start_event {
  }
  
  sub stream_end_event {
  }
  
  sub emit_tag {
      my ($self, $type, $tag) = @_;
      my $map = $self->tagmap;
      for my $key (sort keys %$map) {
          if ($tag =~ m/^\Q$key\E(.*)/) {
              $tag = $map->{ $key } . $1;
              return $tag;
          }
      }
      if ($tag =~ m/^(!.*)/) {
          $tag = "$1";
      }
      else {
          $tag = "!<$tag>";
      }
      return $tag;
  }
  
  sub finish {
      my ($self) = @_;
      $self->writer->finish;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Emitter - Emitting events
  
  =head1 SYNOPSIS
  
      my $emitter = YAML::PP::Emitter->new(
          indent => 4,
      );
  
      $emitter->init;
  
      $emitter->stream_start_event;
      $emitter->document_start_event({ implicit => 1 });
      $emitter->sequence_start_event;
      $emitter->scalar_event({ value => $input, style => $style });
      $emitter->sequence_end_event;
      $emitter->document_end_event({ implicit => 1 });
      $emitter->stream_end_event;
  
      my $yaml = $emitter->writer->output;
      $emitter->finish;
  
  =head1 DESCRIPTION
  
  The emitter emits events to YAML. It provides methods for each event
  type. The arguments are mostly the same as the events from L<YAML::PP::Parser>.
  
  =head1 METHODS
  
  =over
  
  =item new
  
      my $emitter = YAML::PP::Emitter->new(
          indent => 4,
      );
  
  Constructor. Currently takes these options:
  
  =over
  
  =item indent
  
  =item writer
  
  =back
  
  =item stream_start_event, stream_end_event, document_start_event, document_end_event, sequence_start_event, sequence_end_event, mapping_start_event, mapping_end_event, scalar_event, alias_event
  
  =item indent, set_indent
  
  Getter/setter for number of indentation spaces.
  
  TODO: Currently sequences are always zero-indented.
  
  =item writer, set_writer
  
  Getter/setter for the writer object. By default L<YAML::PP::Writer>.
  You can pass your own writer if you want to output the resulting YAML yorself.
  
  =item init
  
  Initialize
  
  =item finish
  
  =back
  
  =cut
YAML_PP_EMITTER

$fatpacked{"YAML/PP/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EXCEPTION';
  use strict;
  use warnings;
  package YAML::PP::Exception;
  
  our $VERSION = '0.018'; # VERSION
  
  use overload '""' => \&to_string;
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          line => $args{line},
          msg => $args{msg},
          next => $args{next},
          where => $args{where},
          yaml => $args{yaml},
          got => $args{got},
          expected => $args{expected},
          column => $args{column},
      }, $class;
      return $self;
  }
  
  sub to_string {
      my ($self) = @_;
      my $next = $self->{next};
      my $line = $self->{line};
      my $column = $self->{column};
  
      my $yaml = '';
      for my $token (@$next) {
          last if $token->{name} eq 'EOL';
          $yaml .= $token->{value};
      }
      $column = '???' unless defined $column;
  
      my $remaining_yaml = $self->{yaml};
      $remaining_yaml = '' unless defined $remaining_yaml;
      $yaml .= $remaining_yaml;
      {
          local $@; # avoid bug in old Data::Dumper
          require Data::Dumper;
          local $Data::Dumper::Useqq = 1;
          local $Data::Dumper::Terse = 1;
          $yaml = Data::Dumper->Dump([$yaml], ['yaml']);
          chomp $yaml;
      }
  
      my $lines = 5;
      my @fields;
  
      if ($self->{got} and $self->{expected}) {
          $lines = 6;
          $line = $self->{got}->{line};
          $column = $self->{got}->{column} + 1;
          @fields = (
              "Line" => $line,
              "Column" => $column,
              "Expected", join(" ", @{ $self->{expected} }),
              "Got", $self->{got}->{name},
              "Where", $self->{where},
              "YAML", $yaml,
          );
      }
      else {
          @fields = (
              "Line" => $line,
              "Column" => $column,
              "Message", $self->{msg},
              "Where", $self->{where},
              "YAML", $yaml,
          );
      }
      my $fmt = join "\n", ("%-10s: %s") x $lines;
      my $string = sprintf $fmt, @fields;
      return $string;
  }
  
  1;
YAML_PP_EXCEPTION

$fatpacked{"YAML/PP/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_GRAMMAR';
  use strict;
  use warnings;
  package YAML::PP::Grammar;
  
  our $VERSION = '0.018'; # VERSION
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw/ $GRAMMAR /;
  
  our $GRAMMAR = {};
  
  # START OF GRAMMAR INLINE
  
  # DO NOT CHANGE THIS
  # This grammar is automatically generated from etc/grammar.yaml
  
  $GRAMMAR = {
    'DIRECTIVE' => {
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_doc_start_explicit'
      },
      'EOL' => {
        'new' => 'DIRECTIVE'
      }
    },
    'DOCUMENT_END' => {
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document'
      },
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_end_doc_start_document'
      },
      'EOL' => {
        'new' => 'DOCUMENT_END'
      }
    },
    'FLOWMAP' => {
      'ALIAS' => {
        'match' => 'cb_send_alias',
        'return' => 1
      },
      'COLON' => {
        'EOL' => {
          'match' => 'cb_empty_flow_mapkey',
          'new' => 'RULE_FULLFLOWSCALAR'
        },
        'WS' => {
          'match' => 'cb_empty_flow_mapkey',
          'new' => 'RULE_FULLFLOWSCALAR'
        }
      },
      'FLOWMAP_START' => {
        'match' => 'cb_start_flowmap',
        'new' => 'NEWFLOWMAP'
      },
      'FLOWSEQ_START' => {
        'match' => 'cb_start_flowseq',
        'new' => 'NEWFLOWSEQ'
      },
      'PLAIN' => {
        'match' => 'cb_flowkey_plain',
        'return' => 1
      },
      'PLAIN_MULTI' => {
        'match' => 'cb_send_plain_multi',
        'return' => 1
      },
      'QUOTED' => {
        'match' => 'cb_flowkey_quoted',
        'return' => 1
      },
      'QUOTED_MULTILINE' => {
        'match' => 'cb_quoted_multiline',
        'return' => 1
      }
    },
    'FLOWSEQ' => {
      'ALIAS' => {
        'match' => 'cb_send_flow_alias',
        'new' => 'FLOWSEQ_NEXT'
      },
      'FLOWMAP_START' => {
        'match' => 'cb_start_flowmap',
        'new' => 'NEWFLOWMAP'
      },
      'FLOWSEQ_START' => {
        'match' => 'cb_start_flowseq',
        'new' => 'NEWFLOWSEQ'
      },
      'PLAIN' => {
        'match' => 'cb_flow_plain',
        'new' => 'FLOWSEQ_NEXT'
      },
      'PLAIN_MULTI' => {
        'match' => 'cb_send_plain_multi',
        'new' => 'FLOWSEQ_NEXT'
      },
      'QUOTED' => {
        'match' => 'cb_flowkey_quoted',
        'new' => 'FLOWSEQ_NEXT'
      },
      'QUOTED_MULTILINE' => {
        'match' => 'cb_quoted_multiline',
        'new' => 'FLOWSEQ_NEXT'
      }
    },
    'FLOWSEQ_NEXT' => {
      'EOL' => {
        'new' => 'FLOWSEQ_NEXT'
      },
      'FLOWSEQ_END' => {
        'match' => 'cb_end_flowseq',
        'return' => 1
      },
      'FLOW_COMMA' => {
        'match' => 'cb_flow_comma',
        'return' => 1
      },
      'WS' => {
        'new' => 'FLOWSEQ_NEXT'
      }
    },
    'FULLMAPVALUE_INLINE' => {
      'ANCHOR' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_ANCHOR'
        },
        'WS' => {
          'DEFAULT' => {
            'new' => 'NODETYPE_MAPVALUE_INLINE'
          },
          'TAG' => {
            'EOL' => {
              'match' => 'cb_property_eol',
              'new' => 'FULLNODE_TAG_ANCHOR'
            },
            'WS' => {
              'new' => 'NODETYPE_MAPVALUE_INLINE'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_MAPVALUE_INLINE'
      },
      'TAG' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_TAG'
        },
        'WS' => {
          'ANCHOR' => {
            'EOL' => {
              'match' => 'cb_property_eol',
              'new' => 'FULLNODE_TAG_ANCHOR'
            },
            'WS' => {
              'new' => 'NODETYPE_MAPVALUE_INLINE'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'NODETYPE_MAPVALUE_INLINE'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'FULLNODE' => {
      'ANCHOR' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_ANCHOR'
        },
        'WS' => {
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          },
          'TAG' => {
            'EOL' => {
              'match' => 'cb_property_eol',
              'new' => 'FULLNODE_TAG_ANCHOR'
            },
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_NODE'
      },
      'EOL' => {
        'new' => 'FULLNODE'
      },
      'TAG' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_TAG'
        },
        'WS' => {
          'ANCHOR' => {
            'EOL' => {
              'match' => 'cb_property_eol',
              'new' => 'FULLNODE_TAG_ANCHOR'
            },
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'FULLNODE_ANCHOR' => {
      'ANCHOR' => {
        'WS' => {
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          },
          'TAG' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_NODE'
      },
      'EOL' => {
        'new' => 'FULLNODE_ANCHOR'
      },
      'TAG' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_TAG_ANCHOR'
        },
        'WS' => {
          'ANCHOR' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'FULLNODE_TAG' => {
      'ANCHOR' => {
        'EOL' => {
          'match' => 'cb_property_eol',
          'new' => 'FULLNODE_TAG_ANCHOR'
        },
        'WS' => {
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          },
          'TAG' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_NODE'
      },
      'EOL' => {
        'new' => 'FULLNODE_TAG'
      },
      'TAG' => {
        'WS' => {
          'ANCHOR' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'FULLNODE_TAG_ANCHOR' => {
      'ANCHOR' => {
        'WS' => {
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          },
          'TAG' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_NODE'
      },
      'EOL' => {
        'new' => 'FULLNODE_TAG_ANCHOR'
      },
      'TAG' => {
        'WS' => {
          'ANCHOR' => {
            'WS' => {
              'new' => 'NODETYPE_SCALAR_OR_MAP'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'NODETYPE_SCALAR_OR_MAP'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'NEWFLOWMAP' => {
      'ANCHOR' => {
        'EOL' => {
          'new' => 'NEWFLOWMAP_ANCHOR'
        },
        'WS' => {
          'new' => 'NEWFLOWMAP_ANCHOR'
        },
        'match' => 'cb_anchor'
      },
      'COLON' => {
        'EOL' => {
          'match' => 'cb_empty_flow_mapkey',
          'new' => 'RULE_FULLFLOWSCALAR'
        },
        'WS' => {
          'match' => 'cb_empty_flow_mapkey',
          'new' => 'RULE_FULLFLOWSCALAR'
        }
      },
      'DEFAULT' => {
        'new' => 'FLOWMAP'
      },
      'EOL' => {
        'new' => 'NEWFLOWMAP'
      },
      'FLOWMAP_END' => {
        'match' => 'cb_end_flowmap',
        'return' => 1
      },
      'QUESTION' => {
        'match' => 'cb_flow_question',
        'new' => 'NEWFLOWMAP'
      },
      'TAG' => {
        'EOL' => {
          'new' => 'NEWFLOWMAP_TAG'
        },
        'WS' => {
          'new' => 'NEWFLOWMAP_TAG'
        },
        'match' => 'cb_tag'
      },
      'WS' => {
        'new' => 'NEWFLOWMAP'
      }
    },
    'NEWFLOWMAP_ANCHOR' => {
      'DEFAULT' => {
        'new' => 'FLOWMAP'
      },
      'EOL' => {
        'new' => 'NEWFLOWMAP_ANCHOR'
      },
      'TAG' => {
        'EOL' => {
          'new' => 'FLOWMAP'
        },
        'WS' => {
          'new' => 'FLOWMAP'
        },
        'match' => 'cb_tag'
      },
      'WS' => {
        'new' => 'NEWFLOWMAP_ANCHOR'
      }
    },
    'NEWFLOWMAP_TAG' => {
      'ANCHOR' => {
        'EOL' => {
          'new' => 'FLOWMAP'
        },
        'WS' => {
          'new' => 'FLOWMAP'
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'FLOWMAP'
      },
      'EOL' => {
        'new' => 'NEWFLOWMAP_TAG'
      },
      'WS' => {
        'new' => 'NEWFLOWMAP_TAG'
      }
    },
    'NEWFLOWSEQ' => {
      'ANCHOR' => {
        'EOL' => {
          'new' => 'NEWFLOWSEQ_ANCHOR'
        },
        'WS' => {
          'new' => 'NEWFLOWSEQ_ANCHOR'
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'FLOWSEQ'
      },
      'EOL' => {
        'new' => 'NEWFLOWSEQ'
      },
      'FLOWSEQ_END' => {
        'match' => 'cb_end_flowseq',
        'return' => 1
      },
      'TAG' => {
        'EOL' => {
          'new' => 'NEWFLOWSEQ_TAG'
        },
        'WS' => {
          'new' => 'NEWFLOWSEQ_TAG'
        },
        'match' => 'cb_tag'
      },
      'WS' => {
        'new' => 'NEWFLOWSEQ'
      }
    },
    'NEWFLOWSEQ_ANCHOR' => {
      'DEFAULT' => {
        'new' => 'FLOWSEQ'
      },
      'EOL' => {
        'new' => 'NEWFLOWSEQ_ANCHOR'
      },
      'TAG' => {
        'EOL' => {
          'new' => 'FLOWSEQ'
        },
        'WS' => {
          'new' => 'FLOWSEQ'
        },
        'match' => 'cb_tag'
      },
      'WS' => {
        'new' => 'NEWFLOWSEQ_ANCHOR'
      }
    },
    'NEWFLOWSEQ_TAG' => {
      'ANCHOR' => {
        'EOL' => {
          'new' => 'FLOWSEQ'
        },
        'WS' => {
          'new' => 'FLOWSEQ'
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'FLOWSEQ'
      },
      'EOL' => {
        'new' => 'NEWFLOWSEQ_TAG'
      },
      'WS' => {
        'new' => 'NEWFLOWSEQ_TAG'
      }
    },
    'NODETYPE_COMPLEX' => {
      'COLON' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_complexcolon'
      },
      'DEFAULT' => {
        'match' => 'cb_empty_complexvalue',
        'new' => 'NODETYPE_MAP'
      },
      'EOL' => {
        'new' => 'NODETYPE_COMPLEX'
      }
    },
    'NODETYPE_FLOWMAP' => {
      'DEFAULT' => {
        'new' => 'NEWFLOWMAP'
      },
      'EOL' => {
        'new' => 'NODETYPE_FLOWMAP'
      },
      'FLOWMAP_END' => {
        'match' => 'cb_end_flowmap',
        'return' => 1
      },
      'FLOW_COMMA' => {
        'match' => 'cb_flow_comma',
        'new' => 'NEWFLOWMAP'
      },
      'WS' => {
        'new' => 'NODETYPE_FLOWMAP'
      }
    },
    'NODETYPE_FLOWMAPVALUE' => {
      'COLON' => {
        'DEFAULT' => {
          'new' => 'RULE_FULLFLOWSCALAR'
        },
        'EOL' => {
          'new' => 'RULE_FULLFLOWSCALAR'
        },
        'WS' => {
          'new' => 'RULE_FULLFLOWSCALAR'
        },
        'match' => 'cb_flow_colon'
      },
      'EOL' => {
        'new' => 'NODETYPE_FLOWMAPVALUE'
      },
      'FLOWMAP_END' => {
        'match' => 'cb_end_flowmap_empty',
        'return' => 1
      },
      'FLOW_COMMA' => {
        'match' => 'cb_empty_flowmap_value',
        'return' => 1
      },
      'WS' => {
        'new' => 'NODETYPE_FLOWMAPVALUE'
      }
    },
    'NODETYPE_FLOWSEQ' => {
      'DEFAULT' => {
        'new' => 'NEWFLOWSEQ'
      },
      'EOL' => {
        'new' => 'NODETYPE_FLOWSEQ'
      },
      'FLOWSEQ_END' => {
        'match' => 'cb_end_flowseq',
        'return' => 1
      },
      'WS' => {
        'new' => 'NODETYPE_FLOWSEQ'
      }
    },
    'NODETYPE_MAP' => {
      'ANCHOR' => {
        'WS' => {
          'DEFAULT' => {
            'new' => 'RULE_MAPKEY'
          },
          'TAG' => {
            'WS' => {
              'new' => 'RULE_MAPKEY'
            },
            'match' => 'cb_tag'
          }
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'RULE_MAPKEY'
      },
      'TAG' => {
        'WS' => {
          'ANCHOR' => {
            'WS' => {
              'new' => 'RULE_MAPKEY'
            },
            'match' => 'cb_anchor'
          },
          'DEFAULT' => {
            'new' => 'RULE_MAPKEY'
          }
        },
        'match' => 'cb_tag'
      }
    },
    'NODETYPE_MAPVALUE_INLINE' => {
      'ALIAS' => {
        'EOL' => {},
        'match' => 'cb_send_alias'
      },
      'BLOCK_SCALAR' => {
        'EOL' => {},
        'match' => 'cb_send_block_scalar'
      },
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document'
      },
      'FLOWMAP_START' => {
        'match' => 'cb_start_flowmap',
        'new' => 'NEWFLOWMAP'
      },
      'FLOWSEQ_START' => {
        'match' => 'cb_start_flowseq',
        'new' => 'NEWFLOWSEQ'
      },
      'PLAIN' => {
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'match' => 'cb_start_plain'
      },
      'PLAIN_MULTI' => {
        'EOL' => {},
        'match' => 'cb_send_plain_multi'
      },
      'QUOTED' => {
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'match' => 'cb_take_quoted'
      },
      'QUOTED_MULTILINE' => {
        'EOL' => {},
        'match' => 'cb_quoted_multiline'
      }
    },
    'NODETYPE_NODE' => {
      'DASH' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_seqstart'
      },
      'DEFAULT' => {
        'new' => 'NODETYPE_SCALAR_OR_MAP'
      }
    },
    'NODETYPE_SCALAR_OR_MAP' => {
      'ALIAS' => {
        'EOL' => {
          'match' => 'cb_send_alias_from_stack'
        },
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            },
            'match' => 'cb_insert_map_alias'
          }
        },
        'match' => 'cb_alias'
      },
      'BLOCK_SCALAR' => {
        'EOL' => {},
        'match' => 'cb_send_block_scalar'
      },
      'COLON' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLMAPVALUE_INLINE'
        },
        'match' => 'cb_insert_empty_map'
      },
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document'
      },
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_end_doc_start_document'
      },
      'EOL' => {
        'new' => 'NODETYPE_SCALAR_OR_MAP'
      },
      'FLOWMAP_START' => {
        'match' => 'cb_start_flowmap',
        'new' => 'NEWFLOWMAP'
      },
      'FLOWSEQ_START' => {
        'match' => 'cb_start_flowseq',
        'new' => 'NEWFLOWSEQ'
      },
      'PLAIN' => {
        'COLON' => {
          'EOL' => {
            'new' => 'FULLNODE'
          },
          'WS' => {
            'new' => 'FULLMAPVALUE_INLINE'
          },
          'match' => 'cb_insert_map'
        },
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            },
            'match' => 'cb_insert_map'
          }
        },
        'match' => 'cb_start_plain'
      },
      'PLAIN_MULTI' => {
        'EOL' => {},
        'match' => 'cb_send_plain_multi'
      },
      'QUESTION' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_questionstart'
      },
      'QUOTED' => {
        'COLON' => {
          'EOL' => {
            'new' => 'FULLNODE'
          },
          'WS' => {
            'new' => 'FULLMAPVALUE_INLINE'
          },
          'match' => 'cb_insert_map'
        },
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            },
            'match' => 'cb_insert_map'
          }
        },
        'match' => 'cb_take_quoted'
      },
      'QUOTED_MULTILINE' => {
        'EOL' => {},
        'match' => 'cb_quoted_multiline'
      },
      'WS' => {
        'new' => 'FULLMAPVALUE_INLINE'
      }
    },
    'NODETYPE_SEQ' => {
      'DASH' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_seqitem'
      },
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document'
      },
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_end_doc_start_document'
      },
      'EOL' => {
        'new' => 'NODETYPE_SEQ'
      }
    },
    'RULE_FLOWSCALAR' => {
      'ALIAS' => {
        'match' => 'cb_send_alias',
        'return' => 1
      },
      'FLOWMAP_END' => {
        'match' => 'cb_end_flowmap_empty',
        'return' => 1
      },
      'FLOWMAP_START' => {
        'match' => 'cb_start_flowmap',
        'new' => 'NEWFLOWMAP'
      },
      'FLOWSEQ_START' => {
        'match' => 'cb_start_flowseq',
        'new' => 'NEWFLOWSEQ'
      },
      'FLOW_COMMA' => {
        'match' => 'cb_empty_flow_mapkey',
        'return' => 1
      },
      'PLAIN' => {
        'DEFAULT' => {
          'match' => 'cb_send_scalar',
          'return' => 1
        },
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'match' => 'cb_start_plain'
      },
      'PLAIN_MULTI' => {
        'match' => 'cb_send_plain_multi',
        'return' => 1
      },
      'QUOTED' => {
        'DEFAULT' => {
          'match' => 'cb_send_scalar',
          'return' => 1
        },
        'EOL' => {
          'match' => 'cb_send_scalar'
        },
        'WS' => {
          'match' => 'cb_send_scalar',
          'return' => 1
        },
        'match' => 'cb_take_quoted'
      },
      'QUOTED_MULTILINE' => {
        'match' => 'cb_quoted_multiline',
        'return' => 1
      }
    },
    'RULE_FULLFLOWSCALAR' => {
      'ANCHOR' => {
        'DEFAULT' => {
          'new' => 'RULE_FULLFLOWSCALAR_ANCHOR'
        },
        'EOL' => {
          'new' => 'RULE_FULLFLOWSCALAR_ANCHOR'
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'RULE_FLOWSCALAR'
      },
      'TAG' => {
        'DEFAULT' => {
          'new' => 'RULE_FULLFLOWSCALAR_TAG'
        },
        'EOL' => {
          'new' => 'RULE_FULLFLOWSCALAR_TAG'
        },
        'match' => 'cb_tag'
      }
    },
    'RULE_FULLFLOWSCALAR_ANCHOR' => {
      'DEFAULT' => {
        'new' => 'RULE_FLOWSCALAR'
      },
      'TAG' => {
        'EOL' => {
          'new' => 'RULE_FLOWSCALAR'
        },
        'WS' => {
          'new' => 'RULE_FLOWSCALAR'
        },
        'match' => 'cb_tag'
      },
      'WS' => {
        'new' => 'RULE_FULLFLOWSCALAR_ANCHOR'
      }
    },
    'RULE_FULLFLOWSCALAR_TAG' => {
      'ANCHOR' => {
        'EOL' => {
          'new' => 'RULE_FLOWSCALAR'
        },
        'WS' => {
          'new' => 'RULE_FLOWSCALAR'
        },
        'match' => 'cb_anchor'
      },
      'DEFAULT' => {
        'new' => 'RULE_FLOWSCALAR'
      },
      'WS' => {
        'new' => 'RULE_FULLFLOWSCALAR_TAG'
      }
    },
    'RULE_MAPKEY' => {
      'ALIAS' => {
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            }
          }
        },
        'match' => 'cb_send_alias'
      },
      'COLON' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLMAPVALUE_INLINE'
        },
        'match' => 'cb_empty_mapkey'
      },
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document'
      },
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_end_doc_start_document'
      },
      'EOL' => {
        'new' => 'RULE_MAPKEY'
      },
      'PLAIN' => {
        'COLON' => {
          'EOL' => {
            'new' => 'FULLNODE'
          },
          'WS' => {
            'new' => 'FULLMAPVALUE_INLINE'
          },
          'match' => 'cb_send_mapkey'
        },
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            },
            'match' => 'cb_send_mapkey'
          }
        },
        'match' => 'cb_mapkey'
      },
      'QUESTION' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_question'
      },
      'QUOTED' => {
        'COLON' => {
          'EOL' => {
            'new' => 'FULLNODE'
          },
          'WS' => {
            'new' => 'FULLMAPVALUE_INLINE'
          }
        },
        'WS' => {
          'COLON' => {
            'EOL' => {
              'new' => 'FULLNODE'
            },
            'WS' => {
              'new' => 'FULLMAPVALUE_INLINE'
            }
          }
        },
        'match' => 'cb_take_quoted_key'
      }
    },
    'STREAM' => {
      'DEFAULT' => {
        'match' => 'cb_doc_start_implicit',
        'new' => 'FULLNODE'
      },
      'DOC_END' => {
        'EOL' => {},
        'match' => 'cb_end_document_empty'
      },
      'DOC_START' => {
        'EOL' => {
          'new' => 'FULLNODE'
        },
        'WS' => {
          'new' => 'FULLNODE'
        },
        'match' => 'cb_doc_start_explicit'
      },
      'EOL' => {
        'new' => 'STREAM'
      },
      'RESERVED_DIRECTIVE' => {
        'EOL' => {
          'new' => 'DIRECTIVE'
        },
        'WS' => {
          'new' => 'DIRECTIVE'
        },
        'match' => 'cb_reserved_directive'
      },
      'TAG_DIRECTIVE' => {
        'EOL' => {
          'new' => 'DIRECTIVE'
        },
        'WS' => {
          'new' => 'DIRECTIVE'
        },
        'match' => 'cb_tag_directive'
      },
      'YAML_DIRECTIVE' => {
        'EOL' => {
          'new' => 'DIRECTIVE'
        },
        'WS' => {
          'new' => 'DIRECTIVE'
        }
      }
    }
  };
  
  
  # END OF GRAMMAR INLINE
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Grammar
  
  =head1 GRAMMAR
  
  This is the Grammar in YAML
  
      # START OF YAML INLINE
  
      # DO NOT CHANGE THIS
      # This grammar is automatically generated from etc/grammar.yaml
  
      ---
      NODETYPE_NODE:
        DASH:
          match: cb_seqstart
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
      
      NODETYPE_SCALAR_OR_MAP:
      
        # Flow nodes can follow tabs
        WS: { new: FULLMAPVALUE_INLINE }
      
        ALIAS:
          match: cb_alias
          EOL: { match: cb_send_alias_from_stack }
          WS:
            COLON:
              match: cb_insert_map_alias
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
      
        QUESTION:
          match: cb_questionstart
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        QUOTED:
          match: cb_take_quoted
          EOL: { match: cb_send_scalar }
          WS:
            COLON:
              match: cb_insert_map
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
          COLON:
            match: cb_insert_map
            EOL: { new: FULLNODE }
            WS: { new: FULLMAPVALUE_INLINE }
      
        QUOTED_MULTILINE:
          match: cb_quoted_multiline
          EOL: {  }
      
      
        PLAIN:
          match: cb_start_plain
          EOL:
            match: cb_send_scalar
          WS:
            COLON:
              match: cb_insert_map
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
          COLON:
            match: cb_insert_map
            EOL: { new: FULLNODE }
            WS: { new: FULLMAPVALUE_INLINE }
      
        PLAIN_MULTI:
          match: cb_send_plain_multi
          EOL: { }
      
        COLON:
          match: cb_insert_empty_map
          EOL: { new: FULLNODE }
          WS: { new: FULLMAPVALUE_INLINE }
      
        BLOCK_SCALAR:
          match: cb_send_block_scalar
          EOL: { }
      
        FLOWSEQ_START:
          match: cb_start_flowseq
          new: NEWFLOWSEQ
      
        FLOWMAP_START:
          match: cb_start_flowmap
          new: NEWFLOWMAP
      
        DOC_END:
          match: cb_end_document
          EOL: { }
      
        DOC_START:
          match: cb_end_doc_start_document
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        EOL:
          new: NODETYPE_SCALAR_OR_MAP
      
      NODETYPE_COMPLEX:
        COLON:
          match: cb_complexcolon
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
        DEFAULT:
          match: cb_empty_complexvalue
          new: NODETYPE_MAP
        EOL:
          new: NODETYPE_COMPLEX
      
      RULE_FULLFLOWSCALAR:
        ANCHOR:
          match: cb_anchor
          EOL: { new: RULE_FULLFLOWSCALAR_ANCHOR }
          DEFAULT: { new: RULE_FULLFLOWSCALAR_ANCHOR }
        TAG:
          match: cb_tag
          EOL: { new: RULE_FULLFLOWSCALAR_TAG }
          DEFAULT: { new: RULE_FULLFLOWSCALAR_TAG }
        DEFAULT: { new: RULE_FLOWSCALAR }
      
      RULE_FULLFLOWSCALAR_ANCHOR:
        WS: { new: RULE_FULLFLOWSCALAR_ANCHOR }
        TAG:
          match: cb_tag
          WS: { new: RULE_FLOWSCALAR }
          EOL: { new: RULE_FLOWSCALAR }
        DEFAULT: { new: RULE_FLOWSCALAR }
      
      RULE_FULLFLOWSCALAR_TAG:
        WS: { new: RULE_FULLFLOWSCALAR_TAG }
        ANCHOR:
          match: cb_anchor
          WS: { new: RULE_FLOWSCALAR }
          EOL: { new: RULE_FLOWSCALAR }
        DEFAULT: { new: RULE_FLOWSCALAR }
      
      RULE_FLOWSCALAR:
        FLOWSEQ_START: { match: cb_start_flowseq, new: NEWFLOWSEQ }
        FLOWMAP_START: { match: cb_start_flowmap, new: NEWFLOWMAP }
      
        ALIAS: { match: cb_send_alias, return: 1 }
      
        QUOTED:
          match: cb_take_quoted
          EOL: { match: cb_send_scalar }
          WS: { match: cb_send_scalar, return: 1 }
          DEFAULT: { match: cb_send_scalar, return: 1 }
      
        QUOTED_MULTILINE: { match: cb_quoted_multiline, return: 1 }
      
        PLAIN:
          match: cb_start_plain
          EOL: { match: cb_send_scalar }
          DEFAULT: { match: cb_send_scalar, return: 1 }
      
        PLAIN_MULTI: { match: cb_send_plain_multi, return: 1 }
      
        FLOW_COMMA: { match: cb_empty_flow_mapkey, return: 1 }
      
        FLOWMAP_END:
          match: cb_end_flowmap_empty
          return: 1
      
      FLOWSEQ:
        FLOWSEQ_START: { match: cb_start_flowseq, new: NEWFLOWSEQ }
        FLOWMAP_START: { match: cb_start_flowmap, new: NEWFLOWMAP }
      
        ALIAS: { match: cb_send_flow_alias, new: FLOWSEQ_NEXT }
      
        PLAIN: { match: cb_flow_plain, new: FLOWSEQ_NEXT }
        PLAIN_MULTI: { match: cb_send_plain_multi, new: FLOWSEQ_NEXT }
      
        QUOTED: { match: cb_flowkey_quoted, new: FLOWSEQ_NEXT }
        QUOTED_MULTILINE: { match: cb_quoted_multiline, new: FLOWSEQ_NEXT }
      
      FLOWSEQ_NEXT:
        WS: { new: FLOWSEQ_NEXT }
        EOL: { new: FLOWSEQ_NEXT }
      
        FLOW_COMMA:
          match: cb_flow_comma
          return: 1
      
        FLOWSEQ_END:
          match: cb_end_flowseq
          return: 1
      
      FLOWMAP:
        FLOWSEQ_START: { match: cb_start_flowseq, new: NEWFLOWSEQ }
        FLOWMAP_START: { match: cb_start_flowmap, new: NEWFLOWMAP }
      
        ALIAS: { match: cb_send_alias, return: 1 }
      
        PLAIN: { match: cb_flowkey_plain, return: 1 }
        PLAIN_MULTI: { match: cb_send_plain_multi, return: 1 }
      
        QUOTED: { match: cb_flowkey_quoted, return: 1 }
        QUOTED_MULTILINE: { match: cb_quoted_multiline, return: 1 }
      
        COLON:
          WS:
            match: cb_empty_flow_mapkey
            new: RULE_FULLFLOWSCALAR
          EOL:
            match: cb_empty_flow_mapkey
            new: RULE_FULLFLOWSCALAR
      
      
      NEWFLOWSEQ:
        EOL: { new: NEWFLOWSEQ }
        WS: { new: NEWFLOWSEQ }
      
        ANCHOR:
          match: cb_anchor
          WS: { new: NEWFLOWSEQ_ANCHOR }
          EOL: { new: NEWFLOWSEQ_ANCHOR }
        TAG:
          match: cb_tag
          WS: { new: NEWFLOWSEQ_TAG }
          EOL: { new: NEWFLOWSEQ_TAG }
      
        FLOWSEQ_END:
          match: cb_end_flowseq
          return: 1
      
        DEFAULT: { new: FLOWSEQ }
      
      NODETYPE_FLOWSEQ:
        EOL: { new: NODETYPE_FLOWSEQ }
        WS: { new: NODETYPE_FLOWSEQ }
        FLOWSEQ_END:
          match: cb_end_flowseq
          return: 1
        DEFAULT: { new: NEWFLOWSEQ }
      
      NODETYPE_FLOWMAPVALUE:
        WS: { new: NODETYPE_FLOWMAPVALUE }
        EOL: { new: NODETYPE_FLOWMAPVALUE }
        COLON:
          match: cb_flow_colon
          WS: { new: RULE_FULLFLOWSCALAR }
          EOL: { new: RULE_FULLFLOWSCALAR }
          DEFAULT: { new: RULE_FULLFLOWSCALAR }
        FLOW_COMMA:
          match: cb_empty_flowmap_value
          return: 1
        FLOWMAP_END:
          match: cb_end_flowmap_empty
          return: 1
      
      NEWFLOWSEQ_ANCHOR:
        WS: { new: NEWFLOWSEQ_ANCHOR }
        EOL: { new: NEWFLOWSEQ_ANCHOR }
        TAG:
          match: cb_tag
          WS: { new: FLOWSEQ }
          EOL: { new: FLOWSEQ }
        DEFAULT: { new: FLOWSEQ }
      
      NEWFLOWSEQ_TAG:
        WS: { new: NEWFLOWSEQ_TAG }
        EOL: { new: NEWFLOWSEQ_TAG }
        ANCHOR:
          match: cb_anchor
          WS: { new: FLOWSEQ }
          EOL: { new: FLOWSEQ }
        DEFAULT: { new: FLOWSEQ }
      
      
      NEWFLOWMAP_ANCHOR:
        WS: { new: NEWFLOWMAP_ANCHOR }
        EOL: { new: NEWFLOWMAP_ANCHOR }
        TAG:
          match: cb_tag
          WS: { new: FLOWMAP }
          EOL: { new: FLOWMAP }
        DEFAULT: { new: FLOWMAP }
      
      NEWFLOWMAP_TAG:
        WS: { new: NEWFLOWMAP_TAG }
        EOL: { new: NEWFLOWMAP_TAG }
        ANCHOR:
          match: cb_anchor
          WS: { new: FLOWMAP }
          EOL: { new: FLOWMAP }
        DEFAULT: { new: FLOWMAP }
      
      NEWFLOWMAP:
        EOL: { new: NEWFLOWMAP }
        WS: { new: NEWFLOWMAP }
        # TODO
        QUESTION: { match: cb_flow_question, new: NEWFLOWMAP }
      
        ANCHOR:
          match: cb_anchor
          WS: { new: NEWFLOWMAP_ANCHOR }
          EOL: { new: NEWFLOWMAP_ANCHOR }
        TAG:
          match: cb_tag
          WS: { new: NEWFLOWMAP_TAG }
          EOL: { new: NEWFLOWMAP_TAG }
      
        FLOWMAP_END:
          match: cb_end_flowmap
          return: 1
      
        COLON:
          WS:
            match: cb_empty_flow_mapkey
            new: RULE_FULLFLOWSCALAR
          EOL:
            match: cb_empty_flow_mapkey
            new: RULE_FULLFLOWSCALAR
      
        DEFAULT: { new: FLOWMAP }
      
      NODETYPE_FLOWMAP:
        EOL: { new: NODETYPE_FLOWMAP }
        WS: { new: NODETYPE_FLOWMAP }
        FLOWMAP_END:
          match: cb_end_flowmap
          return: 1
        FLOW_COMMA: { match: cb_flow_comma, new: NEWFLOWMAP }
        DEFAULT: { new: NEWFLOWMAP }
      
      
      RULE_MAPKEY:
        QUESTION:
          match: cb_question
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
        ALIAS:
          match: cb_send_alias
          WS:
            COLON:
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
      
        QUOTED:
          match: cb_take_quoted_key
          WS:
            COLON:
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
          COLON:
            EOL: { new: FULLNODE }
            WS: { new: FULLMAPVALUE_INLINE }
      
        PLAIN:
          match: cb_mapkey
          WS:
            COLON:
              match: cb_send_mapkey
              EOL: { new: FULLNODE }
              WS: { new: FULLMAPVALUE_INLINE }
          COLON:
            match: cb_send_mapkey
            EOL: { new: FULLNODE }
            WS: { new: FULLMAPVALUE_INLINE }
      
        COLON:
          match: cb_empty_mapkey
          EOL: { new: FULLNODE }
          WS: { new: FULLMAPVALUE_INLINE }
      
        DOC_END:
          match: cb_end_document
          EOL: { }
      
        DOC_START:
          match: cb_end_doc_start_document
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        EOL:
          new: RULE_MAPKEY
      
      
      NODETYPE_SEQ:
        DASH:
          match: cb_seqitem
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
        DOC_END:
          match: cb_end_document
          EOL: { }
        DOC_START:
          match: cb_end_doc_start_document
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        EOL:
          new: NODETYPE_SEQ
      
      NODETYPE_MAP:
        ANCHOR:
          match: cb_anchor
          WS:
            TAG:
              match: cb_tag
              WS: { new: RULE_MAPKEY  }
            DEFAULT: { new: RULE_MAPKEY }
        TAG:
          match: cb_tag
          WS:
            ANCHOR:
              match: cb_anchor
              WS: { new: RULE_MAPKEY  }
            DEFAULT: { new: RULE_MAPKEY }
        DEFAULT: { new: RULE_MAPKEY }
      
      FULLNODE_ANCHOR:
        TAG:
          match: cb_tag
          EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
          WS:
            ANCHOR:
              match: cb_anchor
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        ANCHOR:
          match: cb_anchor
          WS:
            TAG:
              match: cb_tag
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        EOL: { new: FULLNODE_ANCHOR }
        DEFAULT: { new: NODETYPE_NODE }
      
      FULLNODE_TAG:
        ANCHOR:
          match: cb_anchor
          EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
          WS:
            TAG:
              match: cb_tag
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP, }
        TAG:
          match: cb_tag
          WS:
            ANCHOR:
              match: cb_anchor
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        EOL: { new: FULLNODE_TAG }
        DEFAULT: { new: NODETYPE_NODE }
      
      FULLNODE_TAG_ANCHOR:
        ANCHOR:
          match: cb_anchor
          WS:
            TAG:
              match: cb_tag
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        TAG:
          match: cb_tag
          WS:
            ANCHOR:
              match: cb_anchor
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        EOL: { new: FULLNODE_TAG_ANCHOR }
        DEFAULT: { new: NODETYPE_NODE }
      
      FULLNODE:
        ANCHOR:
          match: cb_anchor
          EOL: { match: cb_property_eol, new: FULLNODE_ANCHOR }
          WS:
            TAG:
              match: cb_tag
              EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        TAG:
          match: cb_tag
          EOL: { match: cb_property_eol, new: FULLNODE_TAG }
          WS:
            ANCHOR:
              match: cb_anchor
              EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
              WS: { new: NODETYPE_SCALAR_OR_MAP  }
            DEFAULT: { new: NODETYPE_SCALAR_OR_MAP }
        EOL: { new: FULLNODE }
        DEFAULT: { new: NODETYPE_NODE }
      
      FULLMAPVALUE_INLINE:
        ANCHOR:
          match: cb_anchor
          EOL: { match: cb_property_eol, new: FULLNODE_ANCHOR }
          WS:
            TAG:
              match: cb_tag
              EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
              WS: { new: NODETYPE_MAPVALUE_INLINE  }
            DEFAULT: { new: NODETYPE_MAPVALUE_INLINE }
        TAG:
          match: cb_tag
          EOL: { match: cb_property_eol, new: FULLNODE_TAG }
          WS:
            ANCHOR:
              match: cb_anchor
              EOL: { match: cb_property_eol, new: FULLNODE_TAG_ANCHOR }
              WS: { new: NODETYPE_MAPVALUE_INLINE  }
            DEFAULT: { new: NODETYPE_MAPVALUE_INLINE }
        DEFAULT: { new: NODETYPE_MAPVALUE_INLINE }
      
      
      NODETYPE_MAPVALUE_INLINE:
        ALIAS:
          match: cb_send_alias
          EOL: { }
      
        QUOTED:
          match: cb_take_quoted
          EOL: { match: cb_send_scalar }
      
        QUOTED_MULTILINE:
          match: cb_quoted_multiline
          EOL: { }
      
        PLAIN:
          match: cb_start_plain
          EOL:
            match: cb_send_scalar
      
        PLAIN_MULTI:
          match: cb_send_plain_multi
          EOL: { }
      
        BLOCK_SCALAR:
          match: cb_send_block_scalar
          EOL: { }
      
        FLOWSEQ_START:
          match: cb_start_flowseq
          new: NEWFLOWSEQ
      
        FLOWMAP_START:
          match: cb_start_flowmap
          new: NEWFLOWMAP
      
        DOC_END:
          match: cb_end_document
          EOL: { }
      
      
      DOCUMENT_END:
        DOC_END:
          match: cb_end_document
          EOL: { }
        DOC_START:
          match: cb_end_doc_start_document
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        EOL:
          new: DOCUMENT_END
      
      
      STREAM:
      
        DOC_END:
          match: cb_end_document_empty
          EOL: {  }
        DOC_START:
          match: cb_doc_start_explicit
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
        YAML_DIRECTIVE:
          EOL: { new: DIRECTIVE }
          WS: { new: DIRECTIVE }
        RESERVED_DIRECTIVE:
          match: cb_reserved_directive
          EOL: { new: DIRECTIVE }
          WS: { new: DIRECTIVE }
        TAG_DIRECTIVE:
          match: cb_tag_directive
          EOL: { new: DIRECTIVE }
          WS: { new: DIRECTIVE }
      
        EOL:
          new: STREAM
      
        DEFAULT:
          match: cb_doc_start_implicit
          new: FULLNODE
      
      DIRECTIVE:
        DOC_START:
          match: cb_doc_start_explicit
          EOL: { new: FULLNODE }
          WS: { new: FULLNODE }
      
        EOL:
          new: DIRECTIVE
  
  
      # END OF YAML INLINE
  
  =cut
YAML_PP_GRAMMAR

$fatpacked{"YAML/PP/Highlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_HIGHLIGHT';
  use strict;
  use warnings;
  package YAML::PP::Highlight;
  
  our $VERSION = '0.018'; # VERSION
  
  our @EXPORT_OK = qw/ Dump /;
  
  use base 'Exporter';
  use YAML::PP;
  use YAML::PP::Parser;
  use Encode;
  
  sub Dump {
      my (@docs) = @_;
      # Dumping objects is safe, so we enable the Perl schema here
      require YAML::PP::Schema::Perl;
      my $yp = YAML::PP->new( schema => [qw/ JSON Perl /] );
      my $yaml = $yp->dump_string(@docs);
  
      my ($error, $tokens) = YAML::PP::Parser->yaml_to_tokens(string => $yaml);
      my $highlighted = YAML::PP::Highlight->ansicolored($tokens);
      encode_utf8 $highlighted;
  }
  
  
  my %ansicolors = (
      ANCHOR => [qw/ green /],
      ALIAS => [qw/ bold green /],
      TAG => [qw/ bold blue /],
      INDENT => [qw/ white on_grey3 /],
      COMMENT => [qw/ grey12 /],
      COLON => [qw/ bold magenta /],
      DASH => [qw/ bold magenta /],
      QUESTION => [qw/ bold magenta /],
      YAML_DIRECTIVE => [qw/ cyan /],
      TAG_DIRECTIVE => [qw/ bold cyan /],
      SINGLEQUOTE => [qw/ bold green /],
      SINGLEQUOTED => [qw/ green /],
      SINGLEQUOTED_LINE => [qw/ green /],
      DOUBLEQUOTE => [qw/ bold green /],
      DOUBLEQUOTED => [qw/ green /],
      DOUBLEQUOTED_LINE => [qw/ green /],
      LITERAL => [qw/ bold yellow /],
      FOLDED => [qw/ bold yellow /],
      DOC_START => [qw/ bold /],
      DOC_END => [qw/ bold /],
      BLOCK_SCALAR_CONTENT => [qw/ yellow /],
      TAB => [qw/ on_blue /],
      ERROR => [qw/ bold red /],
      EOL => [qw/ grey12 /],
      TRAILING_SPACE => [qw/ on_grey6 /],
      FLOWSEQ_START => [qw/ bold magenta /],
      FLOWSEQ_END => [qw/ bold magenta /],
      FLOWMAP_START => [qw/ bold magenta /],
      FLOWMAP_END => [qw/ bold magenta /],
      FLOW_COMMA => [qw/ bold magenta /],
  );
  
  sub ansicolored {
      my ($class, $tokens) = @_;
      require Term::ANSIColor;
  
      local $Term::ANSIColor::EACHLINE = "\n";
      my $ansi = '';
      my $highlighted = '';
  
      my @list = $class->transform($tokens);
  
  
      for my $token (@list) {
          my $name = $token->{name};
          my $str = $token->{value};
  
          my $color = $ansicolors{ $name };
          if ($color) {
              $str = Term::ANSIColor::colored($color, $str);
          }
          $highlighted .= $str;
      }
  
      $ansi .= "$highlighted\n";
      return $ansi;
  }
  
  my %htmlcolors = (
      ANCHOR => 'anchor',
      ALIAS => 'alias',
      SINGLEQUOTE => 'singlequote',
      DOUBLEQUOTE => 'doublequote',
      SINGLEQUOTED => 'singlequoted',
      DOUBLEQUOTED => 'doublequoted',
      SINGLEQUOTED_LINE => 'singlequoted',
      DOUBLEQUOTED_LINE => 'doublequoted',
      INDENT => 'indent',
      DASH => 'dash',
      COLON => 'colon',
      QUESTION => 'question',
      YAML_DIRECTIVE => 'yaml_directive',
      TAG_DIRECTIVE => 'tag_directive',
      TAG => 'tag',
      COMMENT => 'comment',
      LITERAL => 'literal',
      FOLDED => 'folded',
      DOC_START => 'doc_start',
      DOC_END => 'doc_end',
      BLOCK_SCALAR_CONTENT => 'block_scalar_content',
      TAB => 'tab',
      ERROR => 'error',
      EOL => 'eol',
      TRAILING_SPACE => 'trailing_space',
      FLOWSEQ_START => 'flowseq_start',
      FLOWSEQ_END => 'flowseq_end',
      FLOWMAP_START => 'flowmap_start',
      FLOWMAP_END => 'flowmap_end',
      FLOW_COMMA => 'flow_comma',
  );
  sub htmlcolored {
      require HTML::Entities;
      my ($class, $tokens) = @_;
      my $html = '';
      my @list = $class->transform($tokens);
      for my $token (@list) {
          my $name = $token->{name};
          my $str = $token->{value};
          my $colorclass = $htmlcolors{ $name } || 'default';
          $str = HTML::Entities::encode_entities($str);
          $html .= qq{<span class="$colorclass">$str</span>};
      }
      return $html;
  }
  
  sub transform {
      my ($class, $tokens) = @_;
      my @list;
      for my $token (@$tokens) {
          my @values;
          my $value = $token->{value};
          my $subtokens = $token->{subtokens};
          if ($subtokens) {
              @values = @$subtokens;
          }
          else {
              @values = $token;
          }
          for my $token (@values) {
              my $value = defined $token->{orig} ? $token->{orig} : $token->{value};
              push @list, map {
                      $_ =~ tr/\t/\t/
                      ? { name => 'TAB', value => $_ }
                      : { name => $token->{name}, value => $_ }
                  } split m/(\t+)/, $value;
          }
      }
      for my $i (0 .. $#list) {
          my $token = $list[ $i ];
          my $name = $token->{name};
          my $str = $token->{value};
          my $trailing_space = 0;
          if ($token->{name} eq 'EOL') {
              if ($str =~ m/ +([\r\n]|\z)/) {
                  $token->{name} = "TRAILING_SPACE";
              }
          }
          elsif ($i < $#list) {
              my $next = $list[ $i + 1];
              if ($next->{name} eq 'EOL') {
                  if ($str =~ m/ \z/ and $name =~ m/^(BLOCK_SCALAR_CONTENT|WS)$/) {
                      $token->{name} = "TRAILING_SPACE";
                  }
              }
          }
      }
      return @list;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Highlight - Syntax highlighting utilities
  
  =head1 SYNOPSIS
  
  
      use YAML::PP::Highlight qw/ Dump /;
  
      my $highlighted = Dump $data;
  
  =head1 FUNCTIONS
  
  =over
  
  =item Dump
  
  =back
  
      use YAML::PP::Highlight qw/ Dump /;
  
      my $highlighted = Dump $data;
      my $highlighted = Dump @docs;
  
  It will dump the given data, and then parse it again to create tokens, which
  are then highlighted with ansi colors.
  
  The return value is ansi colored YAML.
YAML_PP_HIGHLIGHT

$fatpacked{"YAML/PP/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LEXER';
  use strict;
  use warnings;
  package YAML::PP::Lexer;
  
  our $VERSION = '0.018'; # VERSION
  
  use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
  use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
  
  use YAML::PP::Grammar qw/ $GRAMMAR /;
  use Carp qw/ croak /;
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          reader => $args{reader},
      }, $class;
      $self->init;
      return $self;
  }
  
  sub init {
      my ($self) = @_;
      $self->{next_tokens} = [];
      $self->{next_line} = undef;
      $self->{line} = 0;
      $self->{offset} = 0;
      $self->{flowcontext} = 0;
  }
  
  sub next_line { return $_[0]->{next_line} }
  sub set_next_line { $_[0]->{next_line} = $_[1] }
  sub reader { return $_[0]->{reader} }
  sub set_reader { $_[0]->{reader} = $_[1] }
  sub next_tokens { return $_[0]->{next_tokens} }
  sub line { return $_[0]->{line} }
  sub set_line { $_[0]->{line} = $_[1] }
  sub offset { return $_[0]->{offset} }
  sub set_offset { $_[0]->{offset} = $_[1] }
  sub inc_line { return $_[0]->{line}++ }
  sub context { return $_[0]->{context} }
  sub set_context { $_[0]->{context} = $_[1] }
  sub flowcontext { return $_[0]->{flowcontext} }
  sub set_flowcontext { $_[0]->{flowcontext} = $_[1] }
  
  my $RE_WS = '[\t ]';
  my $RE_LB = '[\r\n]';
  my $RE_DOC_END = qr/\A(\.\.\.)(?=$RE_WS|$)/m;
  my $RE_DOC_START = qr/\A(---)(?=$RE_WS|$)/m;
  my $RE_EOL = qr/\A($RE_WS+#.*|$RE_WS+)\z/;
  #my $RE_COMMENT_EOL = qr/\A(#.*)?(?:$RE_LB|\z)/;
  
  #ns-word-char    ::= ns-dec-digit | ns-ascii-letter | â€œ-â€
  my $RE_NS_WORD_CHAR = '[0-9A-Za-z-]';
  my $RE_URI_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} . ')';
  my $RE_NS_TAG_CHAR = '(?:' . '%[0-9a-fA-F]{2}' .'|'.  q{[0-9A-Za-z#;/?:@&=+$_.*'\(\)-]} . ')';
  
  #  [#x21-#x7E]          /* 8 bit */
  # | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD] /* 16 bit */
  # | [#x10000-#x10FFFF]                     /* 32 bit */
  
  #nb-char ::= c-printable - b-char - c-byte-order-mark
  #my $RE_NB_CHAR = '[\x21-\x7E]';
  my $RE_ANCHOR_CAR = '[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
  
  my $RE_PLAIN_START = '[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
  my $RE_PLAIN_END = '[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
  my $RE_PLAIN_FIRST = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
  
  my $RE_PLAIN_START_FLOW = '[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
  my $RE_PLAIN_END_FLOW = '[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';
  my $RE_PLAIN_FIRST_FLOW = '[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';
  # c-indicators
  #! 21
  #" 22
  ## 23
  #% 25
  #& 26
  #' 27
  #* 2A
  #, 2C FLOW
  #- 2D XX
  #: 3A XX
  #> 3E
  #? 3F XX
  #@ 40
  #[ 5B FLOW
  #] 5D FLOW
  #` 60
  #{ 7B FLOW
  #| 7C
  #} 7D FLOW
  
  
  my $RE_PLAIN_WORD = "(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
  my $RE_PLAIN_FIRST_WORD = "(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";
  my $RE_PLAIN_WORDS = "(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
  my $RE_PLAIN_WORDS2 = "(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";
  
  my $RE_PLAIN_WORD_FLOW = "(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
  my $RE_PLAIN_FIRST_WORD_FLOW = "(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";
  my $RE_PLAIN_WORDS_FLOW = "(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
  my $RE_PLAIN_WORDS_FLOW2 = "(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";
  
  
  #c-secondary-tag-handle  ::= â€œ!â€ â€œ!â€
  #c-named-tag-handle  ::= â€œ!â€ ns-word-char+ â€œ!â€
  #ns-tag-char ::= ns-uri-char - â€œ!â€ - c-flow-indicator
  #ns-global-tag-prefix    ::= ns-tag-char ns-uri-char*
  #c-ns-local-tag-prefix   ::= â€œ!â€ ns-uri-char*
  my $RE_TAG = "!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";
  
  #c-ns-anchor-property    ::= â€œ&â€ ns-anchor-name
  #ns-char ::= nb-char - s-white
  #ns-anchor-char  ::= ns-char - c-flow-indicator
  #ns-anchor-name  ::= ns-anchor-char+
  
  my $RE_SEQSTART = qr/\A(-)(?=$RE_WS|$)/m;
  my $RE_COMPLEX = qr/(\?)(?=$RE_WS|$)/m;
  my $RE_COMPLEXCOLON = qr/\A(:)(?=$RE_WS|$)/m;
  my $RE_ANCHOR = "&$RE_ANCHOR_CAR+";
  my $RE_ALIAS = "\\*$RE_ANCHOR_CAR+";
  
  
  my %REGEXES = (
      ANCHOR => qr{($RE_ANCHOR)},
      TAG => qr{($RE_TAG)},
      ALIAS => qr{($RE_ALIAS)},
      SINGLEQUOTED => qr{(?:''|[^'\r\n]+)*},
  );
  
  sub fetch_next_line {
      my ($self) = @_;
      my $next_line = $self->next_line;
      if (defined $next_line ) {
          return $next_line;
      }
  
      my $line = $self->reader->readline;
      unless (defined $line) {
          $self->set_next_line(undef);
          return;
      }
      $self->inc_line;
      $line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";
      $next_line = [ $1,  $2, $3 ];
      $self->set_next_line($next_line);
      # $ESCAPE_CHAR from YAML.pm
      if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//) {
          $self->exception("Control characters are not allowed");
      }
  
      return $next_line;
  }
  
  my %TOKEN_NAMES = (
      '"' => 'DOUBLEQUOTE',
      "'" => 'SINGLEQUOTE',
      '|' => 'LITERAL',
      '>' => 'FOLDED',
      '!' => 'TAG',
      '*' => 'ALIAS',
      '&' => 'ANCHOR',
      ':' => 'COLON',
      '-' => 'DASH',
      '?' => 'QUESTION',
      '[' => 'FLOWSEQ_START',
      ']' => 'FLOWSEQ_END',
      '{' => 'FLOWMAP_START',
      '}' => 'FLOWMAP_END',
      ',' => 'FLOW_COMMA',
      '---' => 'DOC_START',
      '...' => 'DOC_END',
  );
  
  
  sub fetch_next_tokens {
      my ($self) = @_;
      my $next = $self->next_tokens;
      return $next if @$next;
  
      my $next_line = $self->fetch_next_line;
      if (not $next_line) {
          return [];
      }
  
      my $spaces = $next_line->[0];
      my $yaml = \$next_line->[1];
      if (not length $$yaml) {
          $self->push_tokens([ EOL => join('', @$next_line), $self->line ]);
          $self->set_next_line(undef);
          return $next;
      }
      if (substr($$yaml, 0, 1) eq '#') {
          $self->push_tokens([ EOL => join('', @$next_line), $self->line ]);
          $self->set_next_line(undef);
          return $next;
      }
      if (not $spaces and substr($$yaml, 0, 1) eq "%") {
          $self->_fetch_next_tokens_directive($yaml, $next_line->[2]);
          $self->set_context(0);
          $self->set_next_line(undef);
          return $next;
      }
      if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
          $self->push_tokens([ $TOKEN_NAMES{ $1 } => $1, $self->line ]);
      }
      else {
          $self->push_tokens([ SPACE => $spaces, $self->line ]);
      }
  
      my $partial = $self->_fetch_next_tokens($next_line);
      unless ($partial) {
          $self->set_next_line(undef);
      }
      return $next;
  }
  
  my %ANCHOR_ALIAS_TAG =    ( '&' => 1, '*' => 1, '!' => 1 );
  my %BLOCK_SCALAR =        ( '|' => 1, '>' => 1 );
  my %COLON_DASH_QUESTION = ( ':' => 1, '-' => 1, '?' => 1 );
  my %QUOTED =              ( '"' => 1, "'" => 1 );
  my %FLOW =                ( '{' => 1, '[' => 1, '}' => 1, ']' => 1, ',' => 1 );
  my %CONTEXT =             ( '"' => 1, "'" => 1, '>' => 1, '|' => 1 );
  
  my $RE_ESCAPES = qr{(?:
      \\([ \\\/_0abefnrtvLNP"]) | \\x([0-9a-fA-F]{2})
      | \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
  )}x;
  my %CONTROL = (
      '\\' => '\\', '/' => '/', n => "\n", t => "\t", r => "\r", b => "\b",
      'a' => "\a", 'b' => "\b", 'e' => "\e", 'f' => "\f", 'v' => "\x0b",
      'P' => "\x{2029}", L => "\x{2028}", 'N' => "\x85",
      '0' => "\0", '_' => "\xa0", ' ' => ' ', q/"/ => q/"/,
  );
  
  sub _fetch_next_tokens {
      TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";
      my ($self, $next_line) = @_;
  
      my $yaml = \$next_line->[1];
      my $eol = $next_line->[2];
  
      my @tokens;
  
      while (1) {
          unless (length $$yaml) {
              push @tokens, ( EOL => $eol, $self->line );
              $self->push_tokens(\@tokens);
              return;
          }
          my $first = substr($$yaml, 0, 1);
          my $plain = 0;
  
          if ($self->context) {
              if ($$yaml =~ s/\A($RE_WS*)://) {
                  push @tokens, ( WS => $1, $self->line ) if $1;
                  push @tokens, ( COLON => ':', $self->line );
                  $self->set_context(0);
                  next;
              }
              if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//) {
                  push @tokens, ( EOL => $1 . $eol, $self->line );
                  $self->push_tokens(\@tokens);
                  return;
              }
              $self->set_context(0);
          }
          if ($CONTEXT{ $first }) {
              push @tokens, ( CONTEXT => $first, $self->line );
              $self->push_tokens(\@tokens);
              return 1;
          }
          elsif ($COLON_DASH_QUESTION{ $first }) {
              my $token_name = $TOKEN_NAMES{ $first };
              if ($$yaml =~ s/\A\Q$first\E(?:($RE_WS+)|\z)//) {
                  my $token_name = $TOKEN_NAMES{ $first };
                  push @tokens, ( $token_name => $first, $self->line );
                  if (not defined $1) {
                      push @tokens, ( EOL => $eol, $self->line );
                      $self->push_tokens(\@tokens);
                      return;
                  }
                  my $ws = $1;
                  if ($$yaml =~ s/\A(#.*|)\z//) {
                      push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
                      $self->push_tokens(\@tokens);
                      return;
                  }
                  push @tokens, ( WS => $ws, $self->line );
                  next;
              }
              elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//) {
                  push @tokens, ( $token_name => $first, $self->line );
                  next;
              }
              $plain = 1;
          }
          elsif ($ANCHOR_ALIAS_TAG{ $first }) {
              my $token_name = $TOKEN_NAMES{ $first };
              my $REGEX = $REGEXES{ $token_name };
              if ($$yaml =~ s/\A$REGEX//) {
                  push @tokens, ( $token_name => $1, $self->line );
              }
              else {
                  push @tokens, ( "Invalid $token_name" => $$yaml, $self->line );
                  $self->push_tokens(\@tokens);
                  return;
              }
          }
          elsif ($first eq ' ' or $first eq "\t") {
              if ($$yaml =~ s/\A($RE_WS+)//) {
                  my $ws = $1;
                  if ($$yaml =~ s/\A((?:#.*)?\z)//) {
                      push @tokens, ( EOL => $ws . $1 . $eol, $self->line );
                      $self->push_tokens(\@tokens);
                      return;
                  }
                  push @tokens, ( WS => $ws, $self->line );
              }
          }
          elsif ($FLOW{ $first }) {
              push @tokens, ( $TOKEN_NAMES{ $first } => $first, $self->line );
              substr($$yaml, 0, 1, '');
              my $flowcontext = $self->flowcontext;
              if ($first eq '{' or $first eq '[') {
                  $self->set_flowcontext(++$flowcontext);
              }
              elsif ($first eq '}' or $first eq ']') {
                  $self->set_flowcontext(--$flowcontext);
              }
          }
          else {
              $plain = 1;
          }
  
          if ($plain) {
              push @tokens, ( CONTEXT => '', $self->line );
              $self->push_tokens(\@tokens);
              return 1;
          }
  
      }
  
      return;
  }
  
  sub fetch_plain {
      my ($self, $indent, $context) = @_;
      my $next_line = $self->next_line;
      my $yaml = \$next_line->[1];
      my $eol = $next_line->[2];
      my $REGEX = $RE_PLAIN_WORDS;
      if ($self->flowcontext) {
          $REGEX = $RE_PLAIN_WORDS_FLOW;
      }
  
      my @tokens;
      unless ($$yaml =~ s/\A($REGEX)//) {
          $self->push_tokens(\@tokens);
          $self->exception("Invalid plain scalar");
      }
      my $plain = $1;
      push @tokens, ( PLAIN => $plain, $self->line );
  
      if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//) {
          if (defined $1) {
              push @tokens, ( EOL => $1 . $eol, $self->line );
              $self->push_tokens(\@tokens);
              $self->set_next_line(undef);
              return;
          }
          else {
              push @tokens, ( EOL => $2. $eol, $self->line );
              $self->set_next_line(undef);
          }
      }
      else {
          $self->push_tokens(\@tokens);
          my $partial = $self->_fetch_next_tokens($next_line);
          if (not $partial) {
              $self->set_next_line(undef);
          }
          return;
      }
  
      my $RE2 = $RE_PLAIN_WORDS2;
      if ($self->flowcontext) {
          $RE2 = $RE_PLAIN_WORDS_FLOW2;
      }
      my $fetch_next = 0;
      my @lines = ($plain);
      my @next;
      LOOP: while (1) {
          $next_line = $self->fetch_next_line;
          if (not $next_line) {
              last LOOP;
          }
          my $spaces = $next_line->[0];
          my $yaml = \$next_line->[1];
          my $eol = $next_line->[2];
  
          if (not length $$yaml) {
              push @tokens, ( EOL => $spaces . $eol, $self->line );
              $self->set_next_line(undef);
              push @lines, '';
              next LOOP;
          }
  
          if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//) {
              push @next, $TOKEN_NAMES{ $1 } => $1, $self->line;
              $fetch_next = 1;
              last LOOP;
          }
          if ((length $spaces) < $indent) {
              last LOOP;
          }
  
          my $ws = '';
          if ($$yaml =~ s/\A($RE_WS+)//) {
              $ws = $1;
          }
          if (not length $$yaml) {
              push @tokens, ( EOL => $spaces . $ws . $eol, $self->line );
              $self->set_next_line(undef);
              push @lines, '';
              next LOOP;
          }
          if ($$yaml =~ s/\A(#.*)\z//) {
              push @tokens, ( EOL => $spaces . $ws . $1 . $eol, $self->line );
              $self->set_next_line(undef);
              last LOOP;
          }
  
          if ($$yaml =~ s/\A($RE2)//) {
              push @tokens, INDENT => $spaces, $self->line;
              push @tokens, WS => $ws, $self->line;
              push @tokens, PLAIN => $1, $self->line;
              push @lines, $1;
              my $ws = '';
              if ($$yaml =~ s/\A($RE_WS+)//) {
                  $ws = $1;
              }
              if (not length $$yaml) {
                  push @tokens, EOL => $ws . $eol, $self->line;
                  $self->set_next_line(undef);
                  next LOOP;
              }
  
              if ($$yaml =~ s/\A(#.*)\z//) {
                  push @tokens, EOL => $ws . $1 . $eol, $self->line;
                  $self->set_next_line(undef);
                  last LOOP;
              }
              else {
                  push @tokens, WS => $ws, $self->line if $ws;
                  $fetch_next = 1;
              }
          }
          else {
              push @tokens, SPACE => $spaces, $self->line;
              push @tokens, WS => $ws, $self->line;
              if ($self->flowcontext) {
                  $fetch_next = 1;
              }
              else {
                  push @tokens, ERROR => $$yaml, $self->line;
              }
          }
  
          last LOOP;
  
      }
      # remove empty lines at the end
      while (@lines > 1 and $lines[-1] eq '') {
          pop @lines;
      }
      if (@lines > 1) {
          my $value = YAML::PP::Render->render_multi_val(\@lines);
          my @eol;
          if ($tokens[-3] eq 'EOL') {
              @eol = splice @tokens, -3;
          }
          $self->push_subtokens( { name => 'PLAIN_MULTI', value => $value }, \@tokens);
          $self->push_tokens([ @eol, @next ]);
      }
      else {
          $self->push_tokens([ @tokens, @next ]);
      }
      @tokens = ();
      if ($fetch_next) {
          my $partial = $self->_fetch_next_tokens($next_line);
          if (not $partial) {
              $self->set_next_line(undef);
          }
      }
      return;
  }
  
  sub fetch_block {
      my ($self, $indent, $context) = @_;
      my $next_line = $self->next_line;
      my $yaml = \$next_line->[1];
      my $eol = $next_line->[2];
  
      my @tokens;
      my $token_name = $TOKEN_NAMES{ $context };
      $$yaml =~ s/\A\Q$context\E// or die "Unexpected";
      push @tokens, ( $token_name => $context, $self->line );
      my $current_indent = $indent;
      my $started = 0;
      my $set_indent = 0;
      my $chomp = '';
      if ($$yaml =~ s/\A([1-9]\d*)([+-]?)//) {
          push @tokens, ( BLOCK_SCALAR_INDENT => $1, $self->line );
          $set_indent = $1;
          $chomp = $2 if $2;
          push @tokens, ( BLOCK_SCALAR_CHOMP => $2, $self->line ) if $2;
      }
      elsif ($$yaml =~ s/\A([+-])([1-9]\d*)?//) {
          push @tokens, ( BLOCK_SCALAR_CHOMP => $1, $self->line );
          $chomp = $1;
          push @tokens, ( BLOCK_SCALAR_INDENT => $2, $self->line ) if $2;
          $set_indent = $2 if $2;
      }
      if ($set_indent) {
          $started = 1;
          $current_indent = $set_indent;
      }
      if (not length $$yaml) {
          push @tokens, ( EOL => $eol, $self->line );
      }
      elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//) {
          push @tokens, ( EOL => $1 . $eol, $self->line );
      }
      else {
          $self->push_tokens(\@tokens);
          $self->exception("Invalid block scalar");
      }
  
      my @lines;
      while (1) {
          $self->set_next_line(undef);
          $next_line = $self->fetch_next_line;
          if (not $next_line) {
              last;
          }
          my $spaces = $next_line->[0];
          my $content = $next_line->[1];
          my $eol = $next_line->[2];
          if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
              last;
          }
          if ((length $spaces) < $current_indent) {
              if (length $content) {
                  last;
              }
              else {
                  push @lines, '';
                  push @tokens, ( EOL => $spaces . $eol, $self->line );
                  next;
              }
          }
          if ((length $spaces) > $current_indent) {
              if ($started) {
                  ($spaces, my $more_spaces) = unpack "a${current_indent}a*", $spaces;
                  $content = $more_spaces . $content;
              }
          }
          unless (length $content) {
              push @lines, '';
              push @tokens, ( INDENT => $spaces, $self->line, EOL => $eol, $self->line );
              unless ($started) {
                  $current_indent = length $spaces;
              }
              next;
          }
          unless ($started) {
              $started = 1;
              $current_indent = length $spaces;
          }
          push @lines, $content;
          push @tokens, (
              INDENT => $spaces, $self->line,
              BLOCK_SCALAR_CONTENT => $content, $self->line,
              EOL => $eol, $self->line,
          );
      }
      my $value = YAML::PP::Render->render_block_scalar($context, $chomp, \@lines);
      my @eol = splice @tokens, -3;
      $self->push_subtokens( { name => 'BLOCK_SCALAR', value => $value }, \@tokens );
      $self->push_tokens([ @eol ]);
      return 0;
  }
  
  sub fetch_quoted {
      my ($self, $indent, $context) = @_;
      my $next_line = $self->next_line;
      my $yaml = \$next_line->[1];
      my $spaces = $next_line->[0];
  
      my $token_name = $TOKEN_NAMES{ $context };
      $$yaml =~ s/\A\Q$context// or die "Unexpected";;
      my @tokens = ( $token_name => $context, $self->line );
  
      my $start = 1;
      my @values;
      while (1) {
  
          unless ($start) {
              $next_line = $self->fetch_next_line or do {
                      $self->push_tokens(\@tokens);
                      $self->exception("Missing closing quote <$context> at EOF");
                  };
              $start = 0;
              $spaces = $next_line->[0];
              $yaml = \$next_line->[1];
  
              if (not length $$yaml) {
                  push @tokens, ( EOL => $spaces . $next_line->[2], $self->line );
                  $self->set_next_line(undef);
                  push @values, { value => '', orig => '' };
                  next;
              }
              elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/) {
                  $self->push_tokens(\@tokens);
                  $self->exception("Missing closing quote <$context> or invalid document marker");
              }
              elsif ((length $spaces) < $indent) {
                  $self->push_tokens(\@tokens);
                  $self->exception("Wrong indendation or missing closing quote <$context>");
              }
  
              if ($$yaml =~ s/\A($RE_WS+)//) {
                  $spaces .= $1;
              }
              push @tokens, ( WS => $spaces, $self->line );
          }
  
          my $v = $self->_read_quoted_tokens($start, $context, $yaml, \@tokens);
          push @values, $v;
          if ($tokens[-3] eq $token_name) {
              if ($start) {
                  $self->push_subtokens(
                      { name => 'QUOTED', value => $v->{value} }, \@tokens
                  );
              }
              else {
                  my $value = YAML::PP::Render->render_quoted($context, \@values);
                  $self->push_subtokens(
                      { name => 'QUOTED_MULTILINE', value => $value }, \@tokens
                  );
              }
              $self->set_context(1) if $self->flowcontext;
              if (length $$yaml) {
                  my $partial = $self->_fetch_next_tokens($next_line);
                  if (not $partial) {
                      $self->set_next_line(undef);
                  }
                  return 0;
              }
              else {
                  @tokens = ();
                  push @tokens, ( EOL => $next_line->[2], $self->line );
                  $self->push_tokens(\@tokens);
                  $self->set_next_line(undef);
                  return;
              }
          }
          $tokens[-2] .= $next_line->[2];
          $self->set_next_line(undef);
          $start = 0;
      }
  }
  
  sub _read_quoted_tokens {
      my ($self, $start, $first, $yaml, $tokens) = @_;
      my $quoted = '';
      my $decoded = '';
      my $token_name = $TOKEN_NAMES{ $first };
      if ($first eq "'") {
          my $regex = $REGEXES{SINGLEQUOTED};
          if ($$yaml =~ s/\A($regex)//) {
              $quoted .= $1;
              $decoded .= $1;
              $decoded =~ s/''/'/g;
          }
      }
      else {
          ($quoted, $decoded) = $self->_read_doublequoted($yaml);
      }
      my $eol = '';
      unless (length $$yaml) {
          if ($quoted =~ s/($RE_WS+)\z//) {
              $eol = $1;
              $decoded =~ s/($eol)\z//;
          }
      }
      my $value = { value => $decoded, orig => $quoted };
  
      if ($$yaml =~ s/\A$first//) {
          if ($start) {
              push @$tokens, ( $token_name . 'D' => $value, $self->line );
          }
          else {
              push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
          }
          push @$tokens, ( $token_name => $first, $self->line );
          return $value;
      }
      if (length $$yaml) {
          push @$tokens, ( $token_name . 'D' => $value, $self->line );
          $self->push_tokens($tokens);
          $self->exception("Invalid quoted <$first> string");
      }
  
      push @$tokens, ( $token_name . 'D_LINE' => $value, $self->line );
      push @$tokens, ( EOL => $eol, $self->line );
  
      return $value;
  }
  
  sub _read_doublequoted {
      my ($self, $yaml) = @_;
      my $quoted = '';
      my $decoded = '';
      while (1) {
          my $last = 1;
          if ($$yaml =~ s/\A([^"\\]+)//) {
              $quoted .= $1;
              $decoded .= $1;
              $last = 0;
          }
          if ($$yaml =~ s/\A($RE_ESCAPES)//) {
              $quoted .= $1;
              my $dec = defined $2 ? $CONTROL{ $2 }
                          : defined $3 ? chr hex $3
                          : defined $4 ? chr hex $4
                          : chr hex $5;
              $decoded .= $dec;
              $last = 0;
          }
          if ($$yaml =~ s/\A(\\)\z//) {
              $quoted .= $1;
              $decoded .= $1;
              last;
          }
          last if $last;
      }
      return ($quoted, $decoded);
  }
  
  sub _fetch_next_tokens_directive {
      my ($self, $yaml, $eol) = @_;
      my @tokens;
  
      if ($$yaml =~ s/\A(\s*%YAML)//) {
          my $dir = $1;
          if ($$yaml =~ s/\A( )//) {
              $dir .= $1;
              if ($$yaml =~ s/\A(1\.2$RE_WS*)//) {
                  $dir .= $1;
                  push @tokens, ( YAML_DIRECTIVE => $dir, $self->line );
              }
              else {
                  $$yaml =~ s/\A(.*)//;
                  $dir .= $1;
                  my $warn = $ENV{YAML_PP_RESERVED_DIRECTIVE} || 'warn';
                  if ($warn eq 'warn') {
                      warn "Found reserved directive '$dir'";
                  }
                  elsif ($warn eq 'fatal') {
                      die "Found reserved directive '$dir'";
                  }
                  push @tokens, ( RESERVED_DIRECTIVE => "$dir", $self->line );
              }
          }
          else {
              $$yaml =~ s/\A(.*)//;
              $dir .= $1;
              push @tokens, ( 'Invalid directive' => $dir, $self->line );
              push @tokens, ( EOL => $eol, $self->line );
              $self->push_tokens(\@tokens);
              return;
          }
      }
      elsif ($$yaml =~ s/\A(\s*%TAG +(!$RE_NS_WORD_CHAR*!|!) +(tag:\S+|!$RE_URI_CHAR+)$RE_WS*)//) {
          push @tokens, ( TAG_DIRECTIVE => $1, $self->line );
          # TODO
          my $tag_alias = $2;
          my $tag_url = $3;
      }
      elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//) {
          push @tokens, ( RESERVED_DIRECTIVE => $1, $self->line );
          my $warn = $ENV{YAML_PP_RESERVED_DIRECTIVE} || 'warn';
          if ($warn eq 'warn') {
              warn "Found reserved directive '$1'";
          }
          elsif ($warn eq 'fatal') {
              die "Found reserved directive '$1'";
          }
      }
      else {
          push @tokens, ( 'Invalid directive' => $$yaml, $self->line );
          push @tokens, ( EOL => $eol, $self->line );
          $self->push_tokens(\@tokens);
          return;
      }
      if (not length $$yaml) {
          push @tokens, ( EOL => $eol, $self->line );
      }
      else {
          push @tokens, ( 'Invalid directive' => $$yaml, $self->line );
          push @tokens, ( EOL => $eol, $self->line );
      }
      $self->push_tokens(\@tokens);
      return;
  }
  
  sub push_tokens {
      my ($self, $new_tokens) = @_;
      my $next = $self->next_tokens;
      my $line = $self->line;
      my $column = $self->offset;
  
      for (my $i = 0; $i < @$new_tokens; $i += 3) {
          my $value = $new_tokens->[ $i + 1 ];
          my $name = $new_tokens->[ $i ];
          my $line = $new_tokens->[ $i + 2 ];
          my $push = {
              name => $name,
              line => $line,
              column => $column,
              value => $value,
          };
          $column += length $value unless $name eq 'CONTEXT';
          push @$next, $push;
          if ($name eq 'EOL') {
              $column = 0;
          }
      }
      $self->set_offset($column);
      return $next;
  }
  
  sub push_subtokens {
      my ($self, $token, $subtokens) = @_;
      my $next = $self->next_tokens;
      my $line = $self->line;
      my $column = $self->offset;
      $token->{column} = $column;
      $token->{subtokens} = \my @sub;
  
      for (my $i = 0; $i < @$subtokens; $i+=3) {
          my $name = $subtokens->[ $i ];
          my $value = $subtokens->[ $i + 1 ];
          my $line = $subtokens->[ $i + 2 ];
          my $push = {
              name => $subtokens->[ $i ],
              line => $line,
              column => $column,
          };
          if (ref $value eq 'HASH') {
              %$push = ( %$push, %$value );
              $column += length $value->{orig};
          }
          else {
              $push->{value} = $value;
              $column += length $value;
          }
          if ($push->{name} eq 'EOL') {
              $column = 0;
          }
          push @sub, $push;
      }
      $token->{line} = $sub[0]->{line};
      push @$next, $token;
      $self->set_offset($column);
      return $next;
  }
  
  sub exception {
      my ($self, $msg) = @_;
      my $next = $self->next_tokens;
      $next = [];
      my $line = @$next ? $next->[0]->{line} : $self->line;
      my @caller = caller(0);
      my $yaml = '';
      if (my $nl = $self->next_line) {
          $yaml = join '', @$nl;
          $yaml = $nl->[1];
      }
      my $e = YAML::PP::Exception->new(
          line => $line,
          column => $self->offset + 1,
          msg => $msg,
          next => $next,
          where => $caller[1] . ' line ' . $caller[2],
          yaml => $yaml,
      );
      croak $e;
  }
  
  1;
YAML_PP_LEXER

$fatpacked{"YAML/PP/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LOADER';
  # ABSTRACT: Load YAML into data with Parser and Constructor
  use strict;
  use warnings;
  package YAML::PP::Loader;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Parser;
  use YAML::PP::Constructor;
  use YAML::PP::Reader;
  
  sub new {
      my ($class, %args) = @_;
  
      my $cyclic_refs = delete $args{cyclic_refs} || 'allow';
      my $schema = delete $args{schema} || YAML::PP->default_schema(
          boolean => 'perl',
      );
  
      my $constructor = delete $args{constructor} || YAML::PP::Constructor->new(
          schema => $schema,
          cyclic_refs => $cyclic_refs,
      );
      my $parser = delete $args{parser};
      unless ($parser) {
          $parser = YAML::PP::Parser->new;
      }
      unless ($parser->receiver) {
          $parser->set_receiver($constructor);
      }
  
      if (keys %args) {
          die "Unexpected arguments: " . join ', ', sort keys %args;
      }
      my $self = bless {
          parser => $parser,
          constructor => $constructor,
      }, $class;
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          parser => $self->parser->clone,
          constructor => $self->constructor->clone,
      };
      bless $clone, ref $self;
      $clone->parser->set_receiver($clone->constructor);
      return $clone;
  }
  
  sub parser { return $_[0]->{parser} }
  sub constructor { return $_[0]->{constructor} }
  
  sub filename {
      my ($self) = @_;
      my $reader = $self->parser->reader;
      if ($reader->isa('YAML::PP::Reader::File')) {
          return $reader->input;
      }
      die "Reader is not a YAML::PP::Reader::File";
  }
  
  sub load_string {
      my ($self, $yaml) = @_;
      $self->parser->set_reader(YAML::PP::Reader->new( input => $yaml ));
      $self->load();
  }
  
  sub load_file {
      my ($self, $file) = @_;
      $self->parser->set_reader(YAML::PP::Reader::File->new( input => $file ));
      $self->load();
  }
  
  sub load {
      my ($self) = @_;
      my $parser = $self->parser;
      my $constructor = $self->constructor;
  
      $constructor->init;
      $parser->parse();
  
      my $docs = $constructor->docs;
      return wantarray ? @$docs : $docs->[-1];
  }
  
  
  1;
YAML_PP_LOADER

$fatpacked{"YAML/PP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PARSER';
  # ABSTRACT: YAML Parser
  use strict;
  use warnings;
  package YAML::PP::Parser;
  
  our $VERSION = '0.018'; # VERSION
  
  use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
  use constant DEBUG => ($ENV{YAML_PP_DEBUG} || $ENV{YAML_PP_TRACE}) ? 1 : 0;
  
  use YAML::PP::Common qw/
      YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
      YAML_DOUBLE_QUOTED_SCALAR_STYLE
      YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
  /;
  use YAML::PP::Render;
  use YAML::PP::Lexer;
  use YAML::PP::Grammar qw/ $GRAMMAR /;
  use YAML::PP::Exception;
  use YAML::PP::Reader;
  use Carp qw/ croak /;
  
  
  sub new {
      my ($class, %args) = @_;
      my $reader = delete $args{reader} || YAML::PP::Reader->new;
      my $self = bless {
          lexer => YAML::PP::Lexer->new(
              reader => $reader,
          ),
      }, $class;
      my $receiver = delete $args{receiver};
      if ($receiver) {
          $self->set_receiver($receiver);
      }
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          lexer => YAML::PP::Lexer->new(
          ),
      };
      return bless $clone, ref $self;
  }
  
  sub receiver { return $_[0]->{receiver} }
  sub set_receiver {
      my ($self, $receiver) = @_;
      my $callback;
      if (ref $receiver eq 'CODE') {
          $callback = $receiver;
      }
      else {
          $callback = sub {
              my ($self, $event, $info) = @_;
              return $receiver->$event($info);
          };
      }
      $self->{callback} = $callback;
      $self->{receiver} = $receiver;
  }
  sub reader { return $_[0]->lexer->{reader} }
  sub set_reader {
      my ($self, $reader) = @_;
      $self->lexer->set_reader($reader);
  }
  sub lexer { return $_[0]->{lexer} }
  sub callback { return $_[0]->{callback} }
  sub set_callback { $_[0]->{callback} = $_[1] }
  sub level { return $#{ $_[0]->{offset} } }
  sub offset { return $_[0]->{offset} }
  sub set_offset { $_[0]->{offset} = $_[1] }
  sub events { return $_[0]->{events} }
  sub set_events { $_[0]->{events} = $_[1] }
  sub new_node { return $_[0]->{new_node} }
  sub set_new_node { $_[0]->{new_node} = $_[1] }
  sub tagmap { return $_[0]->{tagmap} }
  sub set_tagmap { $_[0]->{tagmap} = $_[1] }
  sub tokens { return $_[0]->{tokens} }
  sub set_tokens { $_[0]->{tokens} = $_[1] }
  sub event_stack { return $_[0]->{event_stack} }
  sub set_event_stack { $_[0]->{event_stack} = $_[1] }
  
  sub rule { return $_[0]->{rule} }
  sub set_rule {
      my ($self, $name) = @_;
      no warnings 'uninitialized';
      DEBUG and $self->info("set_rule($name)");
      $self->{rule} = $name;
  }
  
  sub init {
      my ($self) = @_;
      $self->set_offset([]);
      $self->set_events([]);
      $self->set_new_node(0);
      $self->set_tagmap({
          '!!' => "tag:yaml.org,2002:",
      });
      $self->set_tokens([]);
      $self->set_rule(undef);
      $self->set_event_stack([]);
      $self->lexer->init;
  }
  
  sub parse_string {
      my ($self, $yaml) = @_;
      $self->set_reader(YAML::PP::Reader->new( input => $yaml ));
      $self->parse();
  }
  
  sub parse_file {
      my ($self, $file) = @_;
      $self->set_reader(YAML::PP::Reader::File->new( input => $file ));
      $self->parse();
  }
  
  my %nodetypes = (
      MAPVALUE     => 'NODETYPE_COMPLEX',
      MAP          => 'NODETYPE_MAP',
      SEQ          => 'NODETYPE_SEQ',
      SEQ0         => 'NODETYPE_SEQ',
      FLOWMAP      => 'NODETYPE_FLOWMAP',
      FLOWMAPVALUE => 'NODETYPE_FLOWMAPVALUE',
      FLOWSEQ      => 'NODETYPE_FLOWSEQ',
      FLOWSEQ_NEXT => 'FLOWSEQ_NEXT',
      DOC          => 'FULLNODE',
      DOC_END      => 'DOCUMENT_END',
      STR          => 'STREAM',
  );
  
  sub parse {
      my ($self) = @_;
      TRACE and warn "=== parse()\n";
      TRACE and $self->debug_yaml;
      $self->init;
      $self->lexer->init;
      eval {
          $self->start_stream;
          $self->set_rule( 'STREAM' );
  
          $self->parse_tokens();
  
          $self->end_stream;
      };
      if (my $error = $@) {
          if (ref $error) {
              croak "$error\n ";
          }
          croak $error;
      }
  
      DEBUG and $self->highlight_yaml;
      TRACE and $self->debug_tokens;
  }
  
  sub lex_next_tokens {
      my ($self) = @_;
  
      DEBUG and $self->info("----------------> lex_next_tokens");
      TRACE and $self->debug_events;
  
      my $indent = $self->offset->[-1];
      my $event_types = $self->events;
      my $next_tokens = $self->lexer->fetch_next_tokens($indent);
      return unless @$next_tokens;
  
      my $next = $next_tokens->[0];
  
      return 1 if ($next->{name} ne 'SPACE');
      my $flow = $event_types->[-1] =~ m/^FLOW/;
      my $space = length $next->{value};
      my $tokens = $self->tokens;
  
      if (not $space) {
          shift @$next_tokens;
      }
      else {
          push @$tokens, shift @$next_tokens;
      }
      if ($flow) {
          if ($space >= $indent) {
              return 1;
          }
          $self->exception("Bad indendation in " . $self->events->[-1]);
      }
      $next = $next_tokens->[0];
      if ($space > $indent ) {
          return 1 if $indent < 0;
          unless ($self->new_node) {
              $self->exception("Bad indendation in " . $self->events->[-1]);
          }
          return 1;
      }
      if ($self->new_node) {
          if ($space < $indent) {
              $self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
              $self->remove_nodes($space);
          }
          else {
              # unindented sequence starts
              my $exp = $self->events->[-1];
              my $seq_start = $next->{name} eq 'DASH';
              if ( $seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')) {
              }
              else {
                  $self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
              }
          }
      }
      else {
          if ($space < $indent) {
              $self->remove_nodes($space);
          }
      }
  
      my $exp = $self->events->[-1];
  
      if ($exp eq 'SEQ0' and $next->{name} ne 'DASH') {
          TRACE and $self->info("In unindented sequence");
          $self->end_sequence;
          $exp = $self->events->[-1];
      }
  
      if ($self->offset->[-1] != $space) {
          $self->exception("Expected " . $self->events->[-1]);
      }
      return 1;
  }
  
  my %next_event = (
      MAP => 'MAPVALUE',
      MAPVALUE => 'MAP',
      SEQ => 'SEQ',
      SEQ0 => 'SEQ0',
      DOC => 'DOC_END',
      STR => 'STR',
      FLOWSEQ => 'FLOWSEQ_NEXT',
      FLOWSEQ_NEXT => 'FLOWSEQ',
      FLOWMAP => 'FLOWMAPVALUE',
      FLOWMAPVALUE => 'FLOWMAP',
  );
  
  my %event_to_method = (
      MAP => 'mapping',
      FLOWMAP => 'mapping',
      SEQ => 'sequence',
      SEQ0 => 'sequence',
      FLOWSEQ => 'sequence',
      DOC => 'document',
      STR => 'stream',
      VAL => 'scalar',
      ALI => 'alias',
      MAPVALUE => 'mapping',
  );
  
  #sub process_events {
  #    my ($self, $res) = @_;
  #
  #    my $event_stack = $self->event_stack;
  #    return unless @$event_stack;
  #
  #    if (@$event_stack == 1 and $event_stack->[0]->[0] eq 'properties') {
  #        return;
  #    }
  #
  #    my $event_types = $self->events;
  #    my $properties;
  #    my @send_events;
  #    for my $event (@$event_stack) {
  #        TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$event], ['event']);
  #        my ($type, $info) = @$event;
  #        if ($type eq 'properties') {
  #            $properties = $info;
  #        }
  #        elsif ($type eq 'scalar') {
  #            $info->{name} = 'scalar_event';
  #            $event_types->[-1] = $next_event{ $event_types->[-1] };
  #            push @send_events, $info;
  #        }
  #        elsif ($type eq 'begin') {
  #            my $name = $info->{name};
  #            $info->{name} = $event_to_method{ $name } . '_start_event';
  #            push @{ $event_types }, $name;
  #            push @{ $self->offset }, $info->{offset};
  #            push @send_events, $info;
  #        }
  #        elsif ($type eq 'end') {
  #            my $name = $info->{name};
  #            $info->{name} = $event_to_method{ $name } . '_end_event';
  #            $self->$type($name, $info);
  #            push @send_events, $info;
  #            if (@$event_types) {
  #                $event_types->[-1] = $next_event{ $event_types->[-1] };
  #            }
  #        }
  #        elsif ($type eq 'alias') {
  #            if ($properties) {
  #                $self->exception("Parse error: Alias not allowed in this context");
  #            }
  #            $info->{name} = 'alias_event';
  #            $event_types->[-1] = $next_event{ $event_types->[-1] };
  #            push @send_events, $info;
  #        }
  #    }
  #    @$event_stack = ();
  #    for my $info (@send_events) {
  #        DEBUG and $self->debug_event( $info );
  #        $self->callback->($self, $info->{name}, $info);
  #    }
  #}
  
  my %fetch_method = (
      '"' => 'fetch_quoted',
      "'" => 'fetch_quoted',
      '|' => 'fetch_block',
      '>' => 'fetch_block',
      ''  => 'fetch_plain',
  );
  
  sub parse_tokens {
      my ($self) = @_;
      my $event_types = $self->events;
      my $offsets = $self->offset;
      my $tokens = $self->tokens;
      my $next_tokens = $self->lexer->next_tokens;
  
      unless ($self->lex_next_tokens) {
          $self->end_document(1);
          return 0;
      }
      unless ($self->new_node) {
          if ($self->level > 0) {
              my $new_rule = $nodetypes{ $event_types->[-1] }
                  or die "Did not find '$event_types->[-1]'";
              $self->set_rule( $new_rule );
          }
      }
  
      my $rule_name = $self->rule;
      DEBUG and $self->info("----------------> parse_tokens($rule_name)");
      my $rule = $GRAMMAR->{ $rule_name }
          or die "Could not find rule $rule_name";
  
      TRACE and $self->debug_rules($rule);
      TRACE and $self->debug_yaml;
      DEBUG and $self->debug_next_line;
  
      RULE: while ($rule_name) {
          DEBUG and $self->info("RULE: $rule_name");
          TRACE and $self->debug_tokens($next_tokens);
  
          unless (@$next_tokens) {
              $self->exception("No more tokens");
          }
          TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]], ['next_token']);
          my $got = $next_tokens->[0]->{name};
          if ($got eq 'CONTEXT') {
              my $context = shift @$next_tokens;
              my $indent = $offsets->[-1];
              $indent++ unless $self->lexer->flowcontext;
              my $method = $fetch_method{ $context->{value} };
              my $partial = $self->lexer->$method($indent, $context->{value});
              next RULE;
          }
          my $def = $rule->{ $got };
          if ($def) {
              push @$tokens, shift @$next_tokens;
          }
          elsif ($def = $rule->{DEFAULT}) {
              $got = 'DEFAULT';
          }
          else {
              $self->expected(
                  expected => [keys %$rule],
                  got => $next_tokens->[0],
              );
          }
  
          DEBUG and $self->got("---got $got");
          if (my $sub = $def->{match}) {
              DEBUG and $self->info("CALLBACK $sub");
              $self->$sub(@$tokens ? $tokens->[-1] : ());
          }
          my $eol = $got eq 'EOL';
          my $new = $def->{new};
          if ($new) {
              DEBUG and $self->got("NEW: $new");
              $rule_name = $new;
              $self->set_rule($rule_name);
          }
          elsif ($eol) {
          }
          elsif ($def->{return}) {
              $rule_name = $nodetypes{ $event_types->[-1] }
                  or die "Unexpected event type $event_types->[-1]";
              $self->set_rule($rule_name);
          }
          else {
              $rule_name .= " - $got"; # for debugging
              $rule = $def;
              next RULE;
          }
          if ($eol) {
              unless ($self->lex_next_tokens) {
                  $self->end_document(1);
                  return 0;
              }
              unless ($self->new_node) {
                  if ($self->level > 0) {
                      $rule_name = $nodetypes{ $event_types->[-1] }
                          or die "Did not find '$event_types->[-1]'";
                      $self->set_rule( $rule_name );
                  }
              }
              $rule_name = $self->rule;
          }
          $rule = $GRAMMAR->{ $rule_name }
              or die "Unexpected rule $rule_name";
  
      }
  
      die "Unexpected";
  }
  
  sub end_sequence {
      my ($self) = @_;
      my $event_types = $self->events;
      pop @{ $event_types };
      pop @{ $self->offset };
      my $info = { name => 'sequence_end_event' };
      $self->callback->($self, $info->{name} => $info );
      $event_types->[-1] = $next_event{ $event_types->[-1] };
  }
  
  sub remove_nodes {
      my ($self, $space) = @_;
      my $offset = $self->offset;
      my $event_types = $self->events;
  
      my $exp = $event_types->[-1];
      while (@$offset) {
          if ($offset->[ -1 ] <= $space) {
              last;
          }
          if ($exp eq 'MAPVALUE') {
              $self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
              $exp = 'MAP';
          }
          my $info = { name => $exp };
          $info->{name} = $event_to_method{ $exp } . '_end_event';
          pop @{ $event_types };
          pop @{ $offset };
          $self->callback->($self, $info->{name} => $info );
          $event_types->[-1] = $next_event{ $event_types->[-1] };
          $exp = $event_types->[-1];
      }
      return $exp;
  }
  
  sub start_stream {
      my ($self) = @_;
      push @{ $self->events }, 'STR';
      push @{ $self->offset }, -1;
      $self->callback->($self, 'stream_start_event', {
          name => 'stream_start_event',
      });
  }
  
  sub start_document {
      my ($self, $implicit) = @_;
      push @{ $self->events }, 'DOC';
      push @{ $self->offset }, -1;
      $self->callback->($self, 'document_start_event', {
          name => 'document_start_event',
          implicit => $implicit,
      });
      $self->set_rule( 'FULLNODE' );
      $self->set_new_node(1);
  }
  
  sub start_sequence {
      my ($self, $offset) = @_;
      my $offsets = $self->offset;
      if ($offsets->[-1] == $offset) {
          push @{ $self->events }, 'SEQ0';
      }
      else {
          push @{ $self->events }, 'SEQ';
      }
      push @{ $offsets }, $offset;
      my $event_stack = $self->event_stack;
      my $info = { name => 'sequence_start_event' };
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          my $properties = pop @$event_stack;
          $self->node_properties($properties->[1], $info);
      }
      $self->callback->($self, 'sequence_start_event', $info);
  }
  
  sub start_flow_sequence {
      my ($self, $offset) = @_;
      my $offsets = $self->offset;
      my $new_offset = $offsets->[-1];
      my $event_types = $self->events;
      if ($new_offset < 0) {
          $new_offset = 0;
      }
      elsif ($self->new_node) {
          if ($event_types->[-1] !~ m/^FLOW/) {
              $new_offset++;
          }
      }
      push @{ $self->events }, 'FLOWSEQ';
      push @{ $offsets }, $new_offset;
  
      my $event_stack = $self->event_stack;
      my $info = { style => YAML_FLOW_SEQUENCE_STYLE, name => 'sequence_start_event'  };
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($event_stack, $info);
      }
      $self->callback->($self, 'sequence_start_event', $info);
  }
  
  sub start_flow_mapping {
      my ($self, $offset) = @_;
      my $offsets = $self->offset;
      my $new_offset = $offsets->[-1];
      my $event_types = $self->events;
      if ($new_offset < 0) {
          $new_offset = 0;
      }
      elsif ($self->new_node) {
          if ($event_types->[-1] !~ m/^FLOW/) {
              $new_offset++;
          }
      }
      push @{ $self->events }, 'FLOWMAP';
      push @{ $offsets }, $new_offset;
  
      my $event_stack = $self->event_stack;
      my $info = { name => 'mapping_start_event', style => YAML_FLOW_MAPPING_STYLE };
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($event_stack, $info);
      }
      $self->callback->($self, 'mapping_start_event', $info);
  }
  
  sub end_flow_sequence {
      my ($self) = @_;
      my $event_types = $self->events;
      pop @{ $event_types };
      pop @{ $self->offset };
      my $info = { name => 'sequence_end_event' };
      $self->callback->($self, $info->{name}, $info);
      $event_types->[-1] = $next_event{ $event_types->[-1] };
  }
  
  sub end_flow_mapping {
      my ($self) = @_;
      my $event_types = $self->events;
      pop @{ $event_types };
      pop @{ $self->offset };
      my $info = { name => 'mapping_end_event' };
      $self->callback->($self, $info->{name}, $info);
      $event_types->[-1] = $next_event{ $event_types->[-1] };
  }
  
  sub start_mapping {
      my ($self, $offset) = @_;
      my $offsets = $self->offset;
      push @{ $self->events }, 'MAP';
      push @{ $offsets }, $offset;
      my $event_stack = $self->event_stack;
      my $info = { name => 'mapping_start_event' };
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          my $properties = pop @$event_stack;
          $self->node_properties($properties->[1], $info);
      }
      $self->callback->($self, 'mapping_start_event', $info);
  }
  
  sub end_document {
      my ($self, $implicit) = @_;
  
      if ($self->lexer->flowcontext) {
          die "Unexpected end of flow context";
      }
      if ($self->new_node) {
          $self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
      }
      $self->remove_nodes(-1);
  
      my $event_types = $self->events;
      if ($event_types->[-1] eq 'STR') {
          return;
      }
      my $last = pop @{ $event_types };
      if ($last ne 'DOC' and $last ne 'DOC_END') {
          $self->exception("Unexpected event type $last");
      }
      pop @{ $self->offset };
      $self->set_tagmap({ '!!' => "tag:yaml.org,2002:" });
      $self->callback->($self, 'document_end_event', {
          name => 'document_end_event',
          implicit => $implicit,
      });
      $event_types->[-1] = $next_event{ $event_types->[-1] };
      $self->set_rule('STREAM');
  }
  
  sub end_stream {
      my ($self) = @_;
      my $last = pop @{ $self->events };
      $self->exception("Unexpected event type $last") unless $last eq 'STR';
      pop @{ $self->offset };
      $self->callback->($self, 'stream_end_event', {
          name => 'stream_end_event',
      });
  }
  
  sub fetch_inline_properties {
      my ($self, $stack, $info) = @_;
      my $properties = $stack->[-1];
  
      $properties = $properties->[1];
      my $property_offset;
      if ($properties) {
          for my $p (@{ $properties->{inline} }) {
              my $type = $p->{type};
              if (exists $info->{ $type }) {
                  $self->exception("A node can only have one $type");
              }
              $info->{ $type } = $p->{value};
              unless (defined $property_offset) {
                  $property_offset = $p->{offset};
                  $info->{offset} = $p->{offset};
              }
          }
          delete $properties->{inline};
          undef $properties unless $properties->{newline};
      }
  
      unless ($properties) {
          pop @$stack;
      }
  }
  
  sub node_properties {
      my ($self, $properties, $info) = @_;
      if ($properties) {
          for my $p (@{ $properties->{newline} }) {
              my $type = $p->{type};
              if (exists $info->{ $type }) {
                  $self->exception("A node can only have one $type");
              }
              $info->{ $type } = $p->{value};
          }
          undef $properties;
      }
  }
  
  sub scalar_event {
      my ($self, $info) = @_;
      my $event_types = $self->events;
      my $event_stack = $self->event_stack;
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          my $properties = pop @$event_stack;
          $properties = $self->node_properties($properties->[1], $info);
      }
  
      $info->{name} = 'scalar_event';
      $self->callback->($self, 'scalar_event', $info);
      $self->set_new_node(0);
      $event_types->[-1] = $next_event{ $event_types->[-1] };
  }
  
  sub alias_event {
      my ($self, $info) = @_;
      my $event_stack = $self->event_stack;
      if (@$event_stack and $event_stack->[-1]->[0] eq 'properties') {
          $self->exception("Parse error: Alias not allowed in this context");
      }
      my $event_types = $self->events;
      $info->{name} = 'alias_event';
      $self->callback->($self, 'alias_event', $info);
      $self->set_new_node(0);
      $event_types->[-1] = $next_event{ $event_types->[-1] };
  }
  
  sub yaml_to_tokens {
      my ($class, $type, $input) = @_;
      my $yp = YAML::PP::Parser->new( receiver => sub {} );
      my @docs = eval {
          $type eq 'string' ? $yp->parse_string($input) : $yp->parse_file($input);
      };
      my $error = $@;
  
      my $tokens = $yp->tokens;
      if ($error) {
          my $remaining_tokens = $yp->_remaining_tokens;
          push @$tokens, map { +{ %$_, name => 'ERROR' } } @$remaining_tokens;
      }
      return $error, $tokens;
  }
  
  sub _remaining_tokens {
      my ($self) = @_;
      my @tokens;
      my $next = $self->lexer->next_tokens;
      push @tokens, @$next;
      my $next_line = $self->lexer->next_line;
      my $remaining = '';
      if ($next_line) {
          if ($self->lexer->offset > 0) {
              $remaining = $next_line->[1] . $next_line->[2];
          }
          else {
              $remaining = join '', @$next_line;
          }
      }
      $remaining .= $self->reader->read;
      $remaining = '' unless defined $remaining;
      push @tokens, { name => "ERROR", value => $remaining };
      return \@tokens;
  }
  
  sub event_to_test_suite {
      my ($self, $event) = @_;
      if (ref $event eq 'ARRAY') {
          return YAML::PP::Common::event_to_test_suite($event->[1]);
      }
      return YAML::PP::Common::event_to_test_suite($event);
  }
  
  sub debug_events {
      my ($self) = @_;
      $self->note("EVENTS: ("
          . join (' | ', @{ $_[0]->events }) . ')'
      );
      $self->debug_offset;
  }
  
  sub debug_offset {
      my ($self) = @_;
      $self->note(
          qq{OFFSET: (}
          . join (' | ', map { defined $_ ? sprintf "%-3d", $_ : '?' } @{ $_[0]->offset })
          . qq/) level=@{[ $_[0]->level ]}]}/
      );
  }
  
  sub debug_yaml {
      my ($self) = @_;
      my $line = $self->lexer->line;
      $self->note("LINE NUMBER: $line");
      my $next_tokens = $self->lexer->next_tokens;
      if (@$next_tokens) {
          $self->debug_tokens($next_tokens);
      }
  }
  
  sub debug_next_line {
      my ($self) = @_;
      my $next_line = $self->lexer->next_line || [];
      my $line = $next_line->[0];
      $line = '' unless defined $line;
      $line =~ s/( +)$/'Â·' x length $1/e;
      $line =~ s/\t/â–¸/g;
      $self->note("NEXT LINE: >>$line<<");
  }
  
  sub note {
      my ($self, $msg) = @_;
      $self->_colorize_warn(["yellow"], "============ $msg");
  }
  
  sub info {
      my ($self, $msg) = @_;
      $self->_colorize_warn(["cyan"], "============ $msg");
  }
  
  sub got {
      my ($self, $msg) = @_;
      $self->_colorize_warn(["green"], "============ $msg");
  }
  
  sub _colorize_warn {
      my ($self, $colors, $text) = @_;
      require Term::ANSIColor;
      warn Term::ANSIColor::colored($colors, $text), "\n";
  }
  
  sub debug_event {
      my ($self, $event) = @_;
      my $str = YAML::PP::Common::event_to_test_suite($event);
      require Term::ANSIColor;
      warn Term::ANSIColor::colored(["magenta"], "============ $str"), "\n";
  }
  
  sub debug_rules {
      my ($self, $rules) = @_;
      local $Data::Dumper::Maxdepth = 2;
      $self->note("RULES:");
      for my $rule ($rules) {
          if (ref $rule eq 'ARRAY') {
              my $first = $rule->[0];
              if (ref $first eq 'SCALAR') {
                  $self->info("-> $$first");
              }
              else {
                  if (ref $first eq 'ARRAY') {
                      $first = $first->[0];
                  }
                  $self->info("TYPE $first");
              }
          }
          else {
              eval {
                  my @keys = sort keys %$rule;
                  $self->info("@keys");
              };
          }
      }
  }
  
  sub debug_tokens {
      my ($self, $tokens) = @_;
      $tokens ||= $self->tokens;
      require Term::ANSIColor;
      for my $token (@$tokens) {
          my $type = Term::ANSIColor::colored(["green"],
              sprintf "%-22s L %2d C %2d ",
                  $token->{name}, $token->{line}, $token->{column} + 1
          );
          local $Data::Dumper::Useqq = 1;
          local $Data::Dumper::Terse = 1;
          require Data::Dumper;
          my $str = Data::Dumper->Dump([$token->{value}], ['str']);
          chomp $str;
          $str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge;
          warn "$type$str\n";
      }
  
  }
  
  sub highlight_yaml {
      my ($self) = @_;
      require YAML::PP::Highlight;
      my $tokens = $self->tokens;
      my $highlighted = YAML::PP::Highlight->ansicolored($tokens);
      warn $highlighted;
  }
  
  sub exception {
      my ($self, $msg, %args) = @_;
      my $next = $self->lexer->next_tokens;
      my $line = @$next ? $next->[0]->{line} : $self->lexer->line;
      my $offset = @$next ? $next->[0]->{column} : $self->lexer->offset;
      $offset++;
      my $next_line = $self->lexer->next_line;
      my $remaining = '';
      if ($next_line) {
          if ($self->lexer->offset > 0) {
              $remaining = $next_line->[1] . $next_line->[2];
          }
          else {
              $remaining = join '', @$next_line;
          }
      }
      my $caller = $args{caller} || [ caller(0) ];
      my $e = YAML::PP::Exception->new(
          got => $args{got},
          expected => $args{expected},
          line => $line,
          column => $offset,
          msg => $msg,
          next => $next,
          where => $caller->[1] . ' line ' . $caller->[2],
          yaml => $remaining,
      );
      croak $e;
  }
  
  sub expected {
      my ($self, %args) = @_;
      my $expected = $args{expected};
      @$expected = sort grep { m/^[A-Z_]+$/ } @$expected;
      my $got = $args{got}->{name};
      my @caller = caller(0);
      $self->exception("Expected (@$expected), but got $got",
          caller => \@caller,
          expected => $expected,
          got => $args{got},
      );
  }
  
  sub cb_tag {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      if (! @$stack or $stack->[-1]->[0] ne 'properties') {
          push @$stack, [ properties => {} ];
      }
      my $last = $stack->[-1]->[1];
      my $tag = $self->_read_tag($token->{value}, $self->tagmap);
      $last->{inline} ||= [];
      push @{ $last->{inline} }, {
          type => 'tag',
          value => $tag,
          offset => $token->{column},
      };
  }
  
  sub _read_tag {
      my ($self, $tag, $map) = @_;
      if ($tag eq '!') {
          return "!";
      }
      elsif ($tag =~ m/^!<(.*)>/) {
          return $1;
      }
      elsif ($tag =~ m/^(![^!]*!|!)(.+)/) {
          my $alias = $1;
          my $name = $2;
          $name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;
          if (exists $map->{ $alias }) {
              $tag = $map->{ $alias }. $name;
          }
          else {
              if ($alias ne '!' and $alias ne '!!') {
                  die "Found undefined tag handle '$alias'";
              }
              $tag = "!$name";
          }
      }
      else {
          die "Invalid tag";
      }
      return $tag;
  }
  
  sub cb_anchor {
      my ($self, $token) = @_;
      my $anchor = $token->{value};
      $anchor = substr($anchor, 1);
      my $stack = $self->event_stack;
      if (! @$stack or $stack->[-1]->[0] ne 'properties') {
          push @$stack, [ properties => {} ];
      }
      my $last = $stack->[-1]->[1];
      $last->{inline} ||= [];
      push @{ $last->{inline} }, {
          type => 'anchor',
          value => $anchor,
          offset => $token->{column},
      };
  }
  
  sub cb_property_eol {
      my ($self, $res) = @_;
      my $stack = $self->event_stack;
      my $last = $stack->[-1]->[1];
      my $inline = delete $last->{inline} or return;
      my $newline = $last->{newline} ||= [];
      push @$newline, @$inline;
  }
  
  sub cb_mapkey {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $stack }, [ scalar => $info ];
  }
  
  sub cb_send_mapkey {
      my ($self, $res) = @_;
      my $last = pop @{ $self->event_stack };
      $self->scalar_event($last->[1]);
      $self->set_new_node(1);
  }
  
  sub cb_send_scalar {
      my ($self, $res) = @_;
      my $last = pop @{ $self->event_stack };
      $self->scalar_event($last->[1]);
  }
  
  sub cb_empty_mapkey {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => '',
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
      $self->set_new_node(1);
  }
  
  sub cb_send_flow_alias {
      my ($self, $token) = @_;
      my $alias = substr($token->{value}, 1);
      $self->alias_event({ value => $alias });
  }
  
  sub cb_send_alias {
      my ($self, $token) = @_;
      my $alias = substr($token->{value}, 1);
      $self->alias_event({ value => $alias });
  }
  
  sub cb_send_alias_from_stack {
      my ($self, $token) = @_;
      my $last = pop @{ $self->event_stack };
      $self->alias_event($last->[1]);
  }
  
  sub cb_alias {
      my ($self, $token) = @_;
      my $alias = substr($token->{value}, 1);
      push @{ $self->event_stack }, [ alias => {
          value => $alias,
          offset => $token->{column},
      }];
  }
  
  sub cb_question {
      my ($self, $res) = @_;
      $self->set_new_node(1);
  }
  
  sub cb_flow_question {
      my ($self, $res) = @_;
  }
  
  sub cb_empty_complexvalue {
      my ($self, $res) = @_;
      $self->scalar_event({ style => YAML_PLAIN_SCALAR_STYLE, value => '' });
  }
  
  sub cb_questionstart {
      my ($self, $token) = @_;
      $self->start_mapping($token->{column});
  }
  
  sub cb_complexcolon {
      my ($self, $res) = @_;
      $self->set_new_node(1);
  }
  
  sub cb_seqstart {
      my ($self, $token) = @_;
      my $column = $token->{column};
      $self->start_sequence($column);
      $self->set_new_node(1);
  }
  
  sub cb_seqitem {
      my ($self, $res) = @_;
      $self->set_new_node(1);
  }
  
  sub cb_take_quoted {
      my ($self, $token) = @_;
      my $subtokens = $token->{subtokens};
      my $stack = $self->event_stack;
      my $info = {
          style => $subtokens->[0]->{value} eq '"'
              ? YAML_DOUBLE_QUOTED_SCALAR_STYLE
              : YAML_SINGLE_QUOTED_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $stack }, [ scalar => $info ];
  }
  
  sub cb_quoted_multiline {
      my ($self, $token) = @_;
      my $subtokens = $token->{subtokens};
      my $stack = $self->event_stack;
      my $info = {
          style => $subtokens->[0]->{value} eq '"'
              ? YAML_DOUBLE_QUOTED_SCALAR_STYLE
              : YAML_SINGLE_QUOTED_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $stack }, [ scalar => $info ];
      $self->cb_send_scalar;
  }
  
  sub cb_take_quoted_key {
      my ($self, $token) = @_;
      $self->cb_take_quoted($token);
      $self->cb_send_mapkey;
  }
  
  sub cb_send_plain_multi {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $stack }, [ scalar => $info ];
      $self->cb_send_scalar;
  }
  
  sub cb_start_plain {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
              style => YAML_PLAIN_SCALAR_STYLE,
              value => $token->{value},
              offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $stack }, [ scalar => $info ];
  }
  
  sub cb_start_flowseq {
      my ($self, $token) = @_;
      $self->start_flow_sequence($token->{column});
  }
  
  sub cb_start_flowmap {
      my ($self, $token) = @_;
      $self->start_flow_mapping($token->{column});
  }
  
  sub cb_end_flowseq {
      my ($self, $res) = @_;
      $self->end_flow_sequence;
      $self->set_new_node(0);
  }
  
  sub cb_flow_comma {
      my ($self) = @_;
      my $event_types = $self->events;
      $self->set_new_node(0);
      if ($event_types->[-1] =~ m/^FLOWSEQ/) {
          $event_types->[-1] = $next_event{ $event_types->[-1] };
      }
  }
  
  sub cb_flow_colon {
      my ($self) = @_;
      $self->set_new_node(1);
  }
  
  sub cb_empty_flow_mapkey {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => '',
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
  }
  
  sub cb_end_flowmap {
      my ($self, $res) = @_;
      $self->end_flow_mapping;
      $self->set_new_node(0);
  }
  
  sub cb_end_flowmap_empty {
      my ($self, $res) = @_;
      $self->cb_empty_flowmap_value;
      $self->end_flow_mapping;
      $self->set_new_node(0);
  }
  
  sub cb_flow_plain {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
  }
  
  sub cb_flowkey_plain {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
  }
  
  sub cb_flowkey_quoted {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $subtokens = $token->{subtokens};
      my $info = {
          style => $subtokens->[0]->{value} eq '"'
              ? YAML_DOUBLE_QUOTED_SCALAR_STYLE
              : YAML_SINGLE_QUOTED_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
  }
  
  sub cb_empty_flowmap_value {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => '',
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->scalar_event($info);
  }
  
  sub cb_insert_map_alias {
      my ($self, $res) = @_;
      my $stack = $self->event_stack;
      my $scalar = pop @$stack;
      my $info = $scalar->[1];
      $self->start_mapping($info->{offset});
      $self->alias_event($info);
      $self->set_new_node(1);
  }
  
  sub cb_insert_map {
      my ($self, $res) = @_;
      my $stack = $self->event_stack;
      my $scalar = pop @$stack;
      my $info = $scalar->[1];
      $self->start_mapping($info->{offset});
      $self->scalar_event($info);
      $self->set_new_node(1);
  }
  
  sub cb_insert_empty_map {
      my ($self, $token) = @_;
      my $stack = $self->event_stack;
      my $info = {
          style => YAML_PLAIN_SCALAR_STYLE,
          value => '',
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      $self->start_mapping($info->{offset});
      $self->scalar_event($info);
      $self->set_new_node(1);
  }
  
  sub cb_send_block_scalar {
      my ($self, $token) = @_;
      my $type = $token->{subtokens}->[0]->{value};
      my $stack = $self->event_stack;
      my $info = {
          style => $type eq '|'
              ? YAML_LITERAL_SCALAR_STYLE
              : YAML_FOLDED_SCALAR_STYLE,
          value => $token->{value},
          offset => $token->{column},
      };
      if (@$stack and $stack->[-1]->[0] eq 'properties') {
          $self->fetch_inline_properties($stack, $info);
      }
      push @{ $self->event_stack }, [ scalar => $info ];
      $self->cb_send_scalar;
  }
  
  sub cb_end_document {
      my ($self, $token) = @_;
      $self->end_document(0);
  }
  
  sub cb_end_document_empty {
      my ($self, $token) = @_;
      $self->end_document(0);
  }
  
  sub cb_doc_start_implicit {
      my ($self, $token) = @_;
      $self->start_document(1);
  }
  
  sub cb_doc_start_explicit {
      my ($self, $token) = @_;
      $self->start_document(0);
  }
  
  sub cb_end_doc_start_document {
      my ($self, $token) = @_;
      $self->end_document(1);
      $self->start_document(0);
  }
  
  sub cb_tag_directive {
      my ($self, $token) = @_;
      my ($name, $tag_alias, $tag_url) = split ' ', $token->{value};
      $self->tagmap->{ $tag_alias } = $tag_url;
  }
  
  sub cb_reserved_directive {
  }
  
  1;
YAML_PP_PARSER

$fatpacked{"YAML/PP/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PERL';
  use strict;
  use warnings;
  package YAML::PP::Perl;
  
  our $VERSION = '0.018'; # VERSION
  
  use base 'Exporter';
  use base 'YAML::PP';
  our @EXPORT_OK = qw/ Load Dump LoadFile DumpFile /;
  
  use YAML::PP;
  use YAML::PP::Schema::Perl;
  
  sub new {
      my ($class, %args) = @_;
      $args{schema} ||= [qw/ JSON Perl /];
      $class->SUPER::new(%args);
  }
  
  sub Load {
      my ($yaml) = @_;
      __PACKAGE__->new->load_string($yaml);
  }
  
  sub LoadFile {
      my ($file) = @_;
      __PACKAGE__->new->load_file($file);
  }
  
  sub Dump {
      my (@data) = @_;
      __PACKAGE__->new->dump_string(@data);
  }
  
  sub DumpFile {
      my ($file, @data) = @_;
      __PACKAGE__->new->dump_file($file, @data);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Perl - Convenience module for loading and dumping Perl objects
  
  =head1 SYNOPSIS
  
      use YAML::PP::Perl;
      my @docs = YAML::PP::Perl->new->load_string($yaml);
      my @docs = YAML::PP::Perl::Load($yaml);
  
      # same as
      use YAML::PP;
      my $yp = YAML::PP->new( schema => [qw/ JSON Perl /] );
      my @docs = $yp->load_string($yaml);
  
  =head1 DESCRIPTION
  
  This is just for convenience. It will create a YAML::PP object using the
  default schema (C<JSON>) and the L<YAML::PP::Schema::Perl> schema.
  
  See L<YAML::PP::Schema::Perl> for documentation.
  
  =head1 METHODS
  
  =over
  
  =item Load, Dump, LoadFile, DumpFile
  
  These work like the functions in L<YAML::PP>, just adding the C<Perl> schema.
  
  =item new
  
  Constructor, works like in L<YAML::PP>, just adds the C<Perl> schema to the
  list of arguments.
  
  =back
YAML_PP_PERL

$fatpacked{"YAML/PP/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_READER';
  # ABSTRACT: Reader class for YAML::PP representing input data
  use strict;
  use warnings;
  package YAML::PP::Reader;
  
  our $VERSION = '0.018'; # VERSION
  
  sub input { return $_[0]->{input} }
  sub set_input { $_[0]->{input} = $_[1] }
  
  sub new {
      my ($class, %args) = @_;
      my $input = delete $args{input};
      return bless {
          input => $input,
      }, $class;
  }
  
  sub read {
      my ($self) = @_;
      my $pos = pos $self->{input} || 0;
      my $yaml = substr($self->{input}, $pos);
      $self->{input} = '';
      return $yaml;
  }
  
  sub readline {
      my ($self) = @_;
      unless (length $self->{input}) {
          return;
      }
      if ( $self->{input} =~ m/\G([^\r\n]*(?:\n|\r\n|\r|\z))/g ) {
          my $line = $1;
          unless (length $line) {
              $self->{input} = '';
              return;
          }
          return $line;
      }
      return;
  }
  
  package YAML::PP::Reader::File;
  
  use Scalar::Util qw/ openhandle /;
  
  our @ISA = qw/ YAML::PP::Reader /;
  
  use Carp qw/ croak /;
  
  sub open_handle {
      if (openhandle( $_[0]->{input} )) {
          return $_[0]->{input};
      }
      open my $fh, '<:encoding(UTF-8)', $_[0]->{input}
          or croak "Could not open '$_[0]->{input}' for reading: $!";
      return $fh;
  }
  
  sub read {
      my $fh = $_[0]->{filehandle} ||= $_[0]->open_handle;
      if (wantarray) {
          my @yaml = <$fh>;
          return @yaml;
      }
      else {
          local $/;
          my $yaml = <$fh>;
          return $yaml;
      }
  }
  
  sub readline {
      my $fh = $_[0]->{filehandle} ||= $_[0]->open_handle;
      return scalar <$fh>;
  }
  
  1;
YAML_PP_READER

$fatpacked{"YAML/PP/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_RENDER';
  # ABSTRACT: YAML::PP Rendering functions
  use strict;
  use warnings;
  package YAML::PP::Render;
  
  our $VERSION = '0.018'; # VERSION
  
  use constant TRACE => $ENV{YAML_PP_TRACE} ? 1 : 0;
  
  sub render_quoted {
      my ($self, $style, $lines) = @_;
  
      my $quoted = '';
      my $addspace = 0;
  
      for my $i (0 .. $#$lines) {
          my $line = $lines->[ $i ];
          my $value = $line->{value};
          my $last = $i == $#$lines;
          my $first = $i == 0;
          if ($value eq '') {
              if ($first) {
                  $addspace = 1;
              }
              elsif ($last) {
                  $quoted .= ' ' if $addspace;
              }
              else {
                  $addspace = 0;
                  $quoted .= "\n";
              }
              next;
          }
  
          $quoted .= ' ' if $addspace;
          $addspace = 1;
          if ($style eq '"') {
              if ($line->{orig} =~ m/\\$/) {
                  $line->{value} =~ s/\\$//;
                  $value =~ s/\\$//;
                  $addspace = 0;
              }
          }
          $quoted .= $value;
      }
      return $quoted;
  }
  
  sub render_block_scalar {
      my ($self, $block_type, $chomp, $lines) = @_;
  
      my ($folded, $keep, $trim);
      if ($block_type eq '>') {
          $folded = 1;
      }
      if ($chomp eq '+') {
          $keep = 1;
      }
      elsif ($chomp eq '-') {
          $trim = 1;
      }
  
      my $string = '';
      if (not $keep) {
          # remove trailing empty lines
          while (@$lines) {
              last if $lines->[-1] ne '';
              pop @$lines;
          }
      }
      if ($folded) {
  
          my $prev = 'START';
          for my $i (0 .. $#$lines) {
              my $line = $lines->[ $i ];
  
              my $type = $line eq ''
                  ? 'EMPTY'
                  : $line =~ m/\A[ \t]/
                      ? 'MORE'
                      : 'CONTENT';
  
              if ($prev eq 'MORE' and $type eq 'EMPTY') {
                  $type = 'MORE';
              }
              elsif ($prev eq 'CONTENT') {
                  if ($type ne 'CONTENT') {
                      $string .= "\n";
                  }
                  elsif ($type eq 'CONTENT') {
                      $string .= ' ';
                  }
              }
              elsif ($prev eq 'START' and $type eq 'EMPTY') {
                  $string .= "\n";
                  $type = 'START';
              }
              elsif ($prev eq 'EMPTY' and $type ne 'CONTENT') {
                  $string .= "\n";
              }
  
              $string .= $line;
  
              if ($type eq 'MORE' and $i < $#$lines) {
                  $string .= "\n";
              }
  
              $prev = $type;
          }
          $string .= "\n" if @$lines and not $trim;
      }
      else {
          for my $i (0 .. $#$lines) {
              $string .= $lines->[ $i ];
              $string .= "\n" if ($i != $#$lines or not $trim);
          }
      }
      TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string], ['string']);
      return $string;
  }
  
  sub render_multi_val {
      my ($self, $multi) = @_;
      my $string = '';
      my $start = 1;
      for my $line (@$multi) {
          if (not $start) {
              if ($line eq '') {
                  $string .= "\n";
                  $start = 1;
              }
              else {
                  $string .= " $line";
              }
          }
          else {
              $string .= $line;
              $start = 0;
          }
      }
      return $string;
  }
  
  
  1;
YAML_PP_RENDER

$fatpacked{"YAML/PP/Representer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_REPRESENTER';
  use strict;
  use warnings;
  package YAML::PP::Representer;
  
  our $VERSION = '0.018'; # VERSION
  
  use Scalar::Util qw/ reftype blessed refaddr /;
  
  use YAML::PP::Common qw/
      YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE
      YAML_DOUBLE_QUOTED_SCALAR_STYLE
      YAML_ANY_SCALAR_STYLE
      YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE
      YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE
      YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE
  /;
  use B;
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          schema => $args{schema},
      }, $class;
      return $self;
  }
  
  sub clone {
      my ($self) = @_;
      my $clone = {
          schema => $self->schema,
      };
      return bless $clone, ref $self;
  }
  
  sub schema { return $_[0]->{schema} }
  
  sub represent_node {
      my ($self, $node) = @_;
  
      $node->{reftype} = reftype($node->{value});
  
      if (ref $node->{value}) {
          $self->represent_noderef($node);
      }
      else {
          $self->represent_node_nonref($node);
      }
      $node->{reftype} = (reftype $node->{data}) || '';
  
      if ($node->{reftype} eq 'HASH' and my $tied = tied(%{ $node->{data} })) {
          my $representers = $self->schema->representers;
          $tied = ref $tied;
          if (my $def = $representers->{tied_equals}->{ $tied }) {
              my $code = $def->{code};
              my $done = $code->($self, $node);
          }
      }
  
      if ($node->{reftype} eq 'HASH') {
          unless (defined $node->{items}) {
              # by default we sort hash keys
              for my $key (sort keys %{ $node->{data} }) {
                  push @{ $node->{items} }, $key, $node->{data}->{ $key };
              }
          }
          return [ mapping => $node ];
      }
      elsif ($node->{reftype} eq 'ARRAY') {
          unless (defined $node->{items}) {
              @{ $node->{items} } = @{ $node->{data} };
          }
          return [ sequence => $node ];
      }
      elsif ($node->{reftype}) {
          die "Reftype $node->{reftype} not implemented";
      }
      else {
          unless (defined $node->{items}) {
              $node->{items} = [$node->{data}];
          }
          return [ scalar => $node ];
      }
  
  }
  
  sub represent_node_nonref {
      my ($self, $node) = @_;
      my $representers = $self->schema->representers;
  
      if (not defined $node->{value}) {
          if (my $undef = $representers->{undef}) {
              return 1 if $undef->($self, $node);
          }
          else {
              $node->{style} = YAML_SINGLE_QUOTED_SCALAR_STYLE;
              $node->{data} = '';
              return 1;
          }
      }
      for my $rep (@{ $representers->{flags} }) {
          my $check_flags = $rep->{flags};
          my $flags = B::svref_2object(\$node->{value})->FLAGS;
          if ($flags & $check_flags) {
              return 1 if $rep->{code}->($self, $node);
          }
  
      }
      if (my $rep = $representers->{equals}->{ $node->{value} }) {
          return 1 if $rep->{code}->($self, $node);
      }
      for my $rep (@{ $representers->{regex} }) {
          if ($node->{value} =~ $rep->{regex}) {
              return 1 if $rep->{code}->($self, $node);
          }
      }
      unless (defined $node->{data}) {
          $node->{data} = $node->{value};
      }
      unless (defined $node->{style}) {
          $node->{style} = YAML_ANY_SCALAR_STYLE;
          $node->{style} = "";
      }
  }
  
  sub represent_noderef {
      my ($self, $node) = @_;
      my $representers = $self->schema->representers;
  
      if (my $classname = blessed($node->{value})) {
          if (my $def = $representers->{class_equals}->{ $classname }) {
              my $code = $def->{code};
              return 1 if $code->($self, $node);
          }
          for my $matches (@{ $representers->{class_matches} }) {
              my ($re, $code) = @$matches;
              if (ref $re and $classname =~ $re or $re) {
                  return 1 if $code->($self, $node);
              }
          }
          for my $isa (@{ $representers->{class_isa} }) {
              my ($class_name, $code) = @$isa;
              if ($node->{ value }->isa($class_name)) {
                  return 1 if $code->($self, $node);
              }
          }
      }
      if ($node->{reftype} eq 'SCALAR' and my $scalarref = $representers->{scalarref}) {
          my $code = $scalarref->{code};
          return 1 if $code->($self, $node);
      }
      if ($node->{reftype} eq 'REF' and my $refref = $representers->{refref}) {
          my $code = $refref->{code};
          return 1 if $code->($self, $node);
      }
      if ($node->{reftype} eq 'CODE' and my $coderef = $representers->{coderef}) {
          my $code = $coderef->{code};
          return 1 if $code->($self, $node);
      }
      $node->{data} = $node->{value};
  
  }
  
  1;
YAML_PP_REPRESENTER

$fatpacked{"YAML/PP/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA';
  use strict;
  use warnings;
  package YAML::PP::Schema;
  use B;
  use Module::Load qw//;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
  
  use Scalar::Util qw/ blessed /;
  
  sub new {
      my ($class, %args) = @_;
  
      my $bool = delete $args{boolean};
      $bool = 'perl' unless defined $bool;
      if (keys %args) {
          die "Unexpected arguments: " . join ', ', sort keys %args;
      }
      my $true;
      my $false;
      my $bool_class = '';
      if ($bool eq 'JSON::PP') {
          require JSON::PP;
          $true = \&bool_jsonpp_true;
          $false = \&bool_jsonpp_false;
          $bool_class = 'JSON::PP::Boolean';
      }
      elsif ($bool eq 'boolean') {
          require boolean;
          $true = \&bool_booleanpm_true;
          $false = \&bool_booleanpm_false;
          $bool_class = 'boolean';
      }
      elsif ($bool eq 'perl') {
          $true = \&bool_perl_true;
          $false = \&bool_perl_false;
      }
      else {
          die "Invalid value for 'boolean': '$bool'. Allowed: ('perl', 'boolean', 'JSON::PP')";
      }
  
      my $self = bless {
          resolvers => {},
          representers => {
              'undef' => undef,
              flags => [],
              equals => {},
              regex => [],
              class_equals => {},
              class_matches => [],
              class_isa => [],
              scalarref => undef,
              refref => undef,
              coderef => undef,
              tied_equals => {},
          },
          true => $true,
          false => $false,
          bool_class => $bool_class,
      }, $class;
      return $self;
  }
  
  sub resolvers { return $_[0]->{resolvers} }
  sub representers { return $_[0]->{representers} }
  sub true { return $_[0]->{true} }
  sub false { return $_[0]->{false} }
  sub bool_class { return $_[0]->{bool_class} }
  
  my %LOADED_SCHEMA = (
      JSON => 1,
  );
  
  sub load_subschemas {
      my ($self, @schemas) = @_;
      my $i = 0;
      while ($i < @schemas) {
          my $item = $schemas[ $i ];
          $i++;
          if (blessed($item)) {
              $item->register(
                  schema => $self,
              );
              next;
          }
          my @options;
          while ($i < @schemas
              and (
                  $schemas[ $i ] =~ m/^[^A-Za-z]/
                  or
                  $schemas[ $i ] =~ m/^[a-zA-Z0-9]+=/
                  )
              ) {
              push @options, $schemas[ $i ];
              $i++;
          }
  
          my $class;
          if ($item =~ m/^\:(.*)/) {
              $class = "$1";
              unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
                  die "Module name '$class' is invalid";
              }
              Module::Load::load $class;
          }
          else {
              $class = "YAML::PP::Schema::$item";
              unless ($class =~ m/\A[A-Za-z0-9_:]+\z/) {
                  die "Module name '$class' is invalid";
              }
              $LOADED_SCHEMA{ $item } ||= Module::Load::load $class;
          }
          $class->register(
              schema => $self,
              options => \@options,
          );
  
      }
  }
  
  sub add_resolver {
      my ($self, %args) = @_;
      my $tag = $args{tag};
      my $rule = $args{match};
      my $resolvers = $self->resolvers;
      my ($type, @rule) = @$rule;
      my $implicit = $args{implicit};
      $implicit = 1 unless defined $implicit;
      my $resolver_list = [];
      if ($tag) {
          if (ref $tag eq 'Regexp') {
              my $res = $resolvers->{tags} ||= [];
              push @$res, [ $tag, {} ];
              push @$resolver_list, $res->[-1]->[1];
          }
          else {
              my $res = $resolvers->{tag}->{ $tag } ||= {};
              push @$resolver_list, $res;
          }
      }
      if ($implicit) {
          push @$resolver_list, $resolvers->{value} ||= {};
      }
      for my $res (@$resolver_list) {
          if ($type eq 'equals') {
              my ($match, $value) = @rule;
              unless (exists $res->{equals}->{ $match }) {
                  $res->{equals}->{ $match } = $value;
              }
              next;
          }
          elsif ($type eq 'regex') {
              my ($match, $value) = @rule;
              push @{ $res->{regex} }, [ $match => $value ];
          }
          elsif ($type eq 'all') {
              my ($value) = @rule;
              $res->{all} = $value;
          }
      }
  }
  
  sub add_sequence_resolver {
      my ($self, %args) = @_;
      return $self->add_collection_resolver(sequence => %args);
  }
  
  sub add_mapping_resolver {
      my ($self, %args) = @_;
      return $self->add_collection_resolver(mapping => %args);
  }
  
  sub add_collection_resolver {
      my ($self, $type, %args) = @_;
      my $tag = $args{tag};
      my $implicit = $args{implicit};
      my $resolvers = $self->resolvers;
  
      if ($tag and ref $tag eq 'Regexp') {
          my $res = $resolvers->{ $type }->{tags} ||= [];
          push @$res, [ $tag, {
              on_create => $args{on_create},
              on_data => $args{on_data},
          } ];
      }
      elsif ($tag) {
          my $res = $resolvers->{ $type }->{tag}->{ $tag } ||= {
              on_create => $args{on_create},
              on_data => $args{on_data},
          };
      }
  }
  
  sub add_representer {
      my ($self, %args) = @_;
  
      my $representers = $self->representers;
      if (my $flags = $args{flags}) {
          my $rep = $representers->{flags};
          push @$rep, \%args;
          return;
      }
      if (my $regex = $args{regex}) {
          my $rep = $representers->{regex};
          push @$rep, \%args;
          return;
      }
      if (my $regex = $args{class_matches}) {
          my $rep = $representers->{class_matches};
          push @$rep, [ $args{class_matches}, $args{code} ];
          return;
      }
      if (my $class_equals = $args{class_equals}) {
          my $rep = $representers->{class_equals};
          $rep->{ $class_equals } = {
              code => $args{code},
          };
          return;
      }
      if (my $class_isa = $args{class_isa}) {
          my $rep = $representers->{class_isa};
          push @$rep, [ $args{class_isa}, $args{code} ];
          return;
      }
      if (my $tied_equals = $args{tied_equals}) {
          my $rep = $representers->{tied_equals};
          $rep->{ $tied_equals } = {
              code => $args{code},
          };
          return;
      }
      if (defined(my $equals = $args{equals})) {
          my $rep = $representers->{equals};
          $rep->{ $equals } = {
              code => $args{code},
          };
          return;
      }
      if (defined(my $scalarref = $args{scalarref})) {
          $representers->{scalarref} = {
              code => $args{code},
          };
          return;
      }
      if (defined(my $refref = $args{refref})) {
          $representers->{refref} = {
              code => $args{code},
          };
          return;
      }
      if (defined(my $coderef = $args{coderef})) {
          $representers->{coderef} = {
              code => $args{code},
          };
          return;
      }
      if (my $undef = $args{undefined}) {
          $representers->{undef} = $undef;
          return;
      }
  }
  
  sub load_scalar {
      my ($self, $constructor, $event) = @_;
      my $tag = $event->{tag};
      my $value = $event->{value};
  
      my $resolvers = $self->resolvers;
      my $res;
      if ($tag) {
          $res = $resolvers->{tag}->{ $tag };
          if (not $res and my $matches = $resolvers->{tags}) {
              for my $match (@$matches) {
                  my ($re, $rule) = @$match;
                  if ($tag =~ $re) {
                      $res = $rule;
                      last;
                  }
              }
          }
      }
      else {
          $res = $resolvers->{value};
          if ($event->{style} ne YAML_PLAIN_SCALAR_STYLE) {
              return $value;
          }
      }
  
      if (my $equals = $res->{equals}) {
          if (exists $equals->{ $value }) {
              my $res = $equals->{ $value };
              if (ref $res eq 'CODE') {
                  return $res->($constructor, $event);
              }
              return $res;
          }
      }
      if (my $regex = $res->{regex}) {
          for my $item (@$regex) {
              my ($re, $sub) = @$item;
              my @matches = $value =~ $re;
              if (@matches) {
                  return $sub->($constructor, $event, \@matches);
              }
          }
      }
      if (my $catch_all = $res->{all}) {
          if (ref $catch_all eq 'CODE') {
              return $catch_all->($constructor, $event);
          }
          return $catch_all;
      }
      return $value;
  }
  
  sub create_sequence {
      my ($self, $constructor, $event) = @_;
      my $tag = $event->{tag};
      my $data = [];
      my $on_data;
  
      my $resolvers = $self->resolvers->{sequence};
      if ($tag) {
          if (my $equals = $resolvers->{tag}->{ $tag }) {
              my $on_create = $equals->{on_create};
              $on_data = $equals->{on_data};
              $on_create and $data = $on_create->($constructor, $event);
              return ($data, $on_data);
          }
          if (my $matches = $resolvers->{tags}) {
              for my $match (@$matches) {
                  my ($re, $actions) = @$match;
                  my $on_create = $actions->{on_create};
                  if ($tag =~ $re) {
                      $on_data = $actions->{on_data};
                      $on_create and $data = $on_create->($constructor, $event);
                      return ($data, $on_data);
                  }
              }
          }
      }
  
      return ($data, $on_data);
  }
  
  sub create_mapping {
      my ($self, $constructor, $event) = @_;
      my $tag = $event->{tag};
      my $data = {};
      my $on_data;
  
      my $resolvers = $self->resolvers->{mapping};
      if ($tag) {
          if (my $equals = $resolvers->{tag}->{ $tag }) {
              my $on_create = $equals->{on_create};
              $on_data = $equals->{on_data};
              $on_create and $data = $on_create->($constructor, $event);
              return ($data, $on_data);
          }
          if (my $matches = $resolvers->{tags}) {
              for my $match (@$matches) {
                  my ($re, $actions) = @$match;
                  my $on_create = $actions->{on_create};
                  if ($tag =~ $re) {
                      $on_data = $actions->{on_data};
                      $on_create and $data = $on_create->($constructor, $event);
                      return ($data, $on_data);
                  }
              }
          }
      }
  
      return ($data, $on_data);
  }
  
  sub bool_jsonpp_true { JSON::PP::true() }
  
  sub bool_booleanpm_true { boolean::true() }
  
  sub bool_perl_true { 1 }
  
  sub bool_jsonpp_false { JSON::PP::false() }
  
  sub bool_booleanpm_false { boolean::false() }
  
  sub bool_perl_false { !1 }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema - Schema for YAML::PP
  
  
YAML_PP_SCHEMA

$fatpacked{"YAML/PP/Schema/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_BINARY';
  use strict;
  use warnings;
  package YAML::PP::Schema::Binary;
  
  our $VERSION = '0.018'; # VERSION
  
  use MIME::Base64 qw/ decode_base64 encode_base64 /;
  use YAML::PP::Common qw/ YAML_ANY_SCALAR_STYLE /;
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:binary',
          match => [ all => sub {
              my ($constructor, $event) = @_;
              my $base64 = $event->{value};
              my $binary = decode_base64($base64);
              return $binary;
          }],
          implicit => 0,
      );
  
      $schema->add_representer(
          regex => qr{.*},
          code => sub {
              my ($rep, $node) = @_;
              my $binary = $node->{value};
              unless ($binary =~ m/[\x{7F}-\x{10FFFF}]/) {
                  # ASCII
                  return;
              }
              if (utf8::is_utf8($binary)) {
                  # utf8
                  return;
              }
              # everything else must be base64 encoded
              my $base64 = encode_base64($binary);
              $node->{style} = YAML_ANY_SCALAR_STYLE;
              $node->{data} = $base64;
              $node->{tag} = "tag:yaml.org,2002:binary";
              return 1;
          },
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Binary - Schema for loading and binary data
  
  =head1 SYNOPSIS
  
      use YAML::PP;
      my $yp = YAML::PP->new( schema => [qw/ JSON Binary /] );
      # or
  
      my $binary = $yp->load_string(<<'EOM');
      # The binary value a tiny arrow encoded as a gif image.
      --- !!binary "\
        R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\
        OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\
        +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\
        AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs="
      EOM
  
  =head1 DESCRIPTION
  
  By prepending a base64 encoded binary string with the C<!!binary> tag, it can
  be automatically decoded when loading.
  
  If you are using this schema, any string containing C<[\x{7F}-\x{10FFFF}]>
  will be dumped as binary. That also includes encoded utf8.
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by L<YAML::PP::Schema>
  
  =back
  
  =cut
YAML_PP_SCHEMA_BINARY

$fatpacked{"YAML/PP/Schema/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_CORE';
  use strict;
  use warnings;
  package YAML::PP::Schema::Core;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Schema::JSON qw/
      represent_int represent_float represent_literal represent_bool
      represent_undef
  /;
  
  use B;
  
  use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
  
  my $RE_INT_CORE = qr{^([+-]?(?:[0-9]+))$};
  my $RE_FLOAT_CORE = qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};
  my $RE_INT_OCTAL = qr{^0o([0-7]+)$};
  my $RE_INT_HEX = qr{^0x([0-9a-fA-F]+)$};
  
  sub _from_oct { oct $_[2]->[0] }
  sub _from_hex { hex $_[2]->[0] }
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:null',
          match => [ equals => $_ => undef ],
      ) for (qw/ null NULL Null ~ /, '');
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => $_ => $schema->true ],
      ) for (qw/ true TRUE True /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => $_ => $schema->false ],
      ) for (qw/ false FALSE False /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_CORE => \&YAML::PP::Schema::JSON::_to_int ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_OCTAL => \&_from_oct ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_HEX => \&_from_hex ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ regex => $RE_FLOAT_CORE => \&YAML::PP::Schema::JSON::_to_float ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 + "inf" ],
      ) for (qw/ .inf .Inf .INF /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 - "inf" ],
      ) for (qw/ -.inf -.Inf -.INF /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 + "nan" ],
      ) for (qw/ .nan .NaN .NAN /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:str',
          match => [ all => sub { $_[1]->{value} } ],
      );
  
      my $int_flags = B::SVp_IOK;
      my $float_flags = B::SVp_NOK;
      $schema->add_representer(
          flags => $int_flags,
          code => \&represent_int,
      );
      $schema->add_representer(
          flags => $float_flags,
          code => \&represent_float,
      );
      $schema->add_representer(
          undefined => \&represent_undef,
      );
      $schema->add_representer(
          equals => $_,
          code => \&represent_literal,
      ) for ("", qw/
          true TRUE True false FALSE False null NULL Null ~
          .inf .Inf .INF -.inf -.Inf -.INF .nan .NaN .NAN
      /);
      $schema->add_representer(
          regex => qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},
          code => \&represent_literal,
      );
  
      if ($schema->bool_class) {
          $schema->add_representer(
              class_equals => $schema->bool_class,
              code => \&represent_bool,
          );
      }
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Core - YAML 1.2 Core Schema
  
  =head1 SYNOPSIS
  
      my $yp = YAML::PP->new( schema => ['Core'] );
  
  =head1 DESCRIPTION
  
  This schema loads additional values to the JSON schema as special types, for
  example C<TRUE> and C<True> additional to C<true>.
  
  L<https://yaml.org/spec/1.2/spec.html#id2804923>
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =back
  
  =cut
YAML_PP_SCHEMA_CORE

$fatpacked{"YAML/PP/Schema/Failsafe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_FAILSAFE';
  use strict;
  use warnings;
  package YAML::PP::Schema::Failsafe;
  
  our $VERSION = '0.018'; # VERSION
  
  sub register {
      my ($self, %args) = @_;
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Failsafe - YAML 1.2 Failsafe Schema
  
  =head1 SYNOPSIS
  
      my $yp = YAML::PP->new( schema => ['Failsafe'] );
  
  =head1 DESCRIPTION
  
  With this schema, everything will be treated as a string. There are no booleans,
  integers, floats or undefined values.
  
  L<https://yaml.org/spec/1.2/spec.html#id2802346>
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =back
  
  =cut
YAML_PP_SCHEMA_FAILSAFE

$fatpacked{"YAML/PP/Schema/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_INCLUDE';
  use strict;
  use warnings;
  package YAML::PP::Schema::Include;
  
  our $VERSION = '0.018'; # VERSION
  
  use Carp qw/ croak /;
  use Scalar::Util qw/ weaken /;
  use File::Basename qw/ dirname /;
  
  sub new {
      my ($class, %args) = @_;
  
      my $paths = delete $args{paths};
      if (defined $paths) {
          unless (ref $paths eq 'ARRAY') {
              $paths = [$paths];
          }
      }
      else {
          $paths = [];
      }
      my $allow_absolute = $args{allow_absolute} || 0;
      my $loader = $args{loader} || \&default_loader;
  
      my $self = bless {
          paths => $paths,
          allow_absolute => $allow_absolute,
          last_includes => [],
          cached => {},
          loader => $loader,
      }, $class;
      return $self;
  }
  
  sub init {
      my ($self) = @_;
      $self->{last_includes} = [];
      $self->{cached} = [];
  }
  
  sub paths { $_[0]->{paths} }
  sub allow_absolute { $_[0]->{allow_absolute} }
  sub yp {
      my ($self, $yp) = @_;
      if (@_ == 2) {
          $self->{yp} = $yp;
          weaken $self->{yp};
          return $yp;
      }
      return $self->{yp};
  }
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => '!include',
          match => [ all => sub { $self->include(@_) } ],
          implicit => 0,
      );
  }
  
  sub include {
      my ($self, $constructor, $event) = @_;
      my $yp = $self->yp;
      my $search_paths = $self->paths;
      my $allow_absolute = $self->allow_absolute;
  
      my $relative = not @$search_paths;
      if ($relative) {
          my $last_includes = $self->{last_includes};
          if (@$last_includes) {
              $search_paths = [ $last_includes->[-1] ];
          }
          else {
              # we are in the top-level file and need to look into
              # the original YAML::PP instance
              my $filename = $yp->loader->filename;
              $search_paths = [dirname $filename];
          }
      }
      my $filename = $event->{value};
  
      my $fullpath;
      if (File::Spec->file_name_is_absolute($filename)) {
          unless ($allow_absolute) {
              croak "Absolute filenames not allowed";
          }
          $fullpath = $filename;
      }
      else {
          my @paths = File::Spec->splitdir($filename);
          unless ($allow_absolute) {
              # if absolute paths are not allowed, we also may not use upwards ..
              @paths = File::Spec->no_upwards(@paths);
          }
          for my $candidate (@$search_paths) {
              my $test = File::Spec->catfile( $candidate, @paths );
              if (-e $test) {
                  $fullpath = $test;
                  last;
              }
          }
          croak "File '$filename' not found" unless defined $fullpath;
      }
  
      if ($self->{cached}->{ $fullpath }++) {
          croak "Circular include '$fullpath'";
      }
      if ($relative) {
          push @{ $self->{last_includes} }, dirname $fullpath;
      }
  
      # We need a new object because we are still in the parsing and
      # constructing process
      my $clone = $yp->clone;
      my ($data) = $self->loader->($clone, $fullpath);
  
      if ($relative) {
          pop @{ $self->{last_includes} };
      }
      unless (--$self->{cached}->{ $fullpath }) {
          delete $self->{cached}->{ $fullpath };
      }
      return $data;
  }
  
  sub loader {
      my ($self, $code) = @_;
      if (@_ == 2) {
          $self->{loader} = $code;
          return $code;
      }
      return $self->{loader};
  }
  sub default_loader {
      my ($yp, $filename) = @_;
      $yp->load_file($filename);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Include - Include YAML files
  
  =head1 SYNOPSIS
  
      # /path/to/file.yaml
      # ---
      # included: !include include/file2.yaml
  
      # /path/to/include/file2.yaml
      # ---
      # a: b
  
      my $include = YAML::PP::Schema::Include->new;
  
      my $yp = YAML::PP->new( schema => ['JSON', $include] );
      # we need the original YAML::PP object for getting the current filename
      # and for loading another file
      $include->yp($yp);
  
      my ($data) = $yp->load_file("/path/to/file.yaml");
  
      # The result will be:
      $data = {
          included => { a => 'b' }
      };
  
  Allow absolute filenames and upwards C<'..'>:
  
      my $include = YAML::PP::Schema::Include->new(
          allow_absolute => 1, # default: 0
      );
  
  Specify paths to search for includes:
  
      my @include_paths = ("/path/to/include/yaml/1", "/path/to/include/yaml/2");
      my $include = YAML::PP::Schema::Include->new(
          paths => \@include_paths,
      );
      my $yp = YAML::PP->new( schema => ['JSON', $include] );
      $include->yp($yp);
  
      # /path/to/include/yaml/1/file1.yaml
      # ---
      # a: b
  
      my $yaml = <<'EOM';
      - included: !include file1.yaml
      EOM
      my ($data) = $yp->load_string($yaml);
  
  
  =head1 DESCRIPTION
  
  This plugin allows you to split a large YAML file into smaller ones.
  You can then include these files with the C<!include> tag.
  
  It will search for the specified filename relative to the currently processed
  filename.
  
  You can also specify the paths where to search for files to include. It iterates
  through the paths and returns the first filename that exists.
  
  By default, only relative paths are allowed. Any C<../> in the path will be
  removed. You can change that behaviour by setting the option C<allow_absolute>
  to true.
  
  If the included file contains more than one document, only the first one
  will be included.
  
  I will probably add a possibility to return all documents as an arrayref.
  
  The included YAML file will be loaded by creating a new L<YAML::PP> object
  with the schema from the existing object. This way you can recursively include
  files.
  
  You can even reuse the same include via an alias:
  
      ---
      invoice:
          shipping address: &address !include address.yaml
          billing address: *address
  
  Circular includes will be detected, and will be fatal.
  
  It's possible to specify what to do with the included file:
  
      my $include = YAML::PP::Schema::Include->new(
          loader => sub {
              my ($yp, $filename);
              if ($filename =~ m/\.txt$/) {
                  # open file and just return text
              }
              else {
                  # default behaviour
                  return $yp->load_file($filename);
              }
          },
      );
  
  For example, RAML defines an C<!include> tag which depends on the file
  content. If it contains a special RAML directive, it will be loaded as
  YAML, otherwise the content of the file will be included as a string.
  
  So with this plugin you are able to read RAML specifications.
  
  
  =cut
YAML_PP_SCHEMA_INCLUDE

$fatpacked{"YAML/PP/Schema/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_JSON';
  use strict;
  use warnings;
  package YAML::PP::Schema::JSON;
  
  our $VERSION = '0.018'; # VERSION
  
  use base 'Exporter';
  our @EXPORT_OK = qw/
      represent_int represent_float represent_literal represent_bool
      represent_undef
  /;
  
  use B;
  
  use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE /;
  
  my $RE_INT = qr{^(-?(?:0|[1-9][0-9]*))$};
  my $RE_FLOAT = qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};
  
  sub _to_int { 0 + $_[2]->[0] }
  
  # DaTa++ && shmem++
  sub _to_float { unpack F => pack F => $_[2]->[0] }
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:null',
          match => [ equals => null => undef ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:null',
          match => [ equals => '' => undef ],
          implicit => 0,
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => true => $schema->true ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => false => $schema->false ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT => \&_to_int ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ regex => $RE_FLOAT => \&_to_float ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:str',
          match => [ all => sub { $_[1]->{value} } ],
      );
  
      $schema->add_representer(
          undefined => \&represent_undef,
      );
  
      my $int_flags = B::SVp_IOK;
      my $float_flags = B::SVp_NOK;
      $schema->add_representer(
          flags => $int_flags,
          code => \&represent_int,
      );
      my %special = ( (0+'nan').'' => '.nan', (0+'inf').'' => '.inf', (0-'inf').'' => '-.inf' );
      $schema->add_representer(
          flags => $float_flags,
          code => \&represent_float,
      );
      $schema->add_representer(
          equals => $_,
          code => \&represent_literal,
      ) for ("", qw/ true false null /);
      $schema->add_representer(
          regex => qr{$RE_INT|$RE_FLOAT},
          code => \&represent_literal,
      );
  
      if ($schema->bool_class) {
          $schema->add_representer(
              class_equals => $schema->bool_class,
              code => \&represent_bool,
          );
      }
  
      return;
  }
  
  sub represent_undef {
      my ($rep, $node) = @_;
      $node->{style} = YAML_PLAIN_SCALAR_STYLE;
      $node->{data} = 'null';
      return 1;
  }
  
  sub represent_literal {
      my ($rep, $node) = @_;
      $node->{style} = YAML_SINGLE_QUOTED_SCALAR_STYLE;
      $node->{data} = "$node->{value}";
      return 1;
  }
  
  
  sub represent_int {
      my ($rep, $node) = @_;
      if (int($node->{value}) ne $node->{value}) {
          return 0;
      }
      $node->{style} = YAML_PLAIN_SCALAR_STYLE;
      $node->{data} = "$node->{value}";
      return 1;
  }
  
  my %special = (
      (0+'nan').'' => '.nan',
      (0+'inf').'' => '.inf',
      (0-'inf').'' => '-.inf'
  );
  sub represent_float {
      my ($rep, $node) = @_;
      if (exists $special{ $node->{value} }) {
          $node->{style} = YAML_PLAIN_SCALAR_STYLE;
          $node->{data} = $special{ $node->{value} };
          return 1;
      }
      if (0.0 + $node->{value} ne $node->{value}) {
          return 0;
      }
      if (int($node->{value}) eq $node->{value} and not $node->{value} =~ m/\./) {
          $node->{value} .= '.0';
      }
      $node->{style} = YAML_PLAIN_SCALAR_STYLE;
      $node->{data} = "$node->{value}";
      return 1;
  }
  
  sub represent_bool {
      my ($rep, $node) = @_;
      my $string = $node->{value} ? 'true' : 'false';
      $node->{style} = YAML_PLAIN_SCALAR_STYLE;
      @{ $node->{items} } = $string;
      $node->{data} = $string;
      return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::JSON - YAML 1.2 JSON Schema
  
  =head1 SYNOPSIS
  
      my $yp = YAML::PP->new( schema => ['JSON'] );
  
  =head1 DESCRIPTION
  
  With this schema, the resolution of plain values will work like in JSON.
  Everything that matches a special value will be loaded as such, other plain
  scalars will be loaded as strings.
  
  L<https://yaml.org/spec/1.2/spec.html#id2803231>
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =item represent_bool, represent_float, represent_int, represent_literal, represent_undef
  
  Functions to represent the several node types.
  
      represent_bool($representer, $node);
  
  =back
  
  =cut
YAML_PP_SCHEMA_JSON

$fatpacked{"YAML/PP/Schema/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_MERGE';
  use strict;
  use warnings;
  package YAML::PP::Schema::Merge;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Type::MergeKey;
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:merge',
          match => [ equals => '<<' => YAML::PP::Type::MergeKey->new ],
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Merge - Enabling YAML merge keys for mappings
  
  =head1 SYNOPSIS
  
      use YAML::PP;
      my $yp = YAML::PP->new( schema => [qw/ JSON Merge /] );
      my $yaml = <<'EOM';
      ---
      - &CENTER { x: 1, y: 2 }
      - &LEFT { x: 0, y: 2 }
      - &BIG { r: 10 }
      - &SMALL { r: 1 }
  
      # All the following maps are equal:
  
      - # Explicit keys
        x: 1
        y: 2
        r: 10
        label: center/big
  
      - # Merge one map
        << : *CENTER
        r: 10
        label: center/big
  
      - # Merge multiple maps
        << : [ *CENTER, *BIG ]
        label: center/big
  
      - # Override
        << : [ *BIG, *LEFT, *SMALL ]
        x: 1
        label: center/big
      EOM
      my $data = $yp->load_string($yaml);
      # $data->[4] == $data->[5] == $data->[6] == $data->[7]
  
  =head1 DESCRIPTION
  
  See L<https://yaml.org/type/merge.html> for the specification.
  
  Quote:
  
  "Specify one or more mappings to be merged with the current one.
  
  The C<< << >> merge key is used to indicate that all the keys of one or more
  specified maps should be inserted into the current map. If the value associated
  with the key is a single mapping node, each of its key/value pairs is inserted
  into the current mapping, unless the key already exists in it. If the value
  associated with the merge key is a sequence, then this sequence is expected to
  contain mapping nodes and each of these nodes is merged in turn according to its
  order in the sequence. Keys in mapping nodes earlier in the sequence override
  keys specified in later mapping nodes."
  
  The implementation of this in a generic way is not trivial, because we also
  have to handle duplicate keys, and YAML::PP allows to write your own
  handler for processing mappings.
  
  So the inner API of that is not stable at this point.
  
  Note that if you enable this schema, a plain scalar `<<` will be seen as
  special anywhere in your document, so if you want a literal `<<`, you have
  to put it in quotes.
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =back
  
  =cut
  
YAML_PP_SCHEMA_MERGE

$fatpacked{"YAML/PP/Schema/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_PERL';
  use strict;
  use warnings;
  package YAML::PP::Schema::Perl;
  
  our $VERSION = '0.018'; # VERSION
  
  use Scalar::Util qw/ blessed reftype /;
  
  my $qr_prefix;
  # workaround to avoid growing regexes when repeatedly loading and dumping
  # e.g. (?^:(?^:regex))
  {
      $qr_prefix = qr{\(\?-xism\:};
      if ($] >= 5.014) {
          $qr_prefix = qr{\(\?\^(?:[uadl])?\:};
      }
  }
  
  sub new {
      my ($class, %args) = @_;
      my $tags = $args{tags} || [];
      my $loadcode = $args{loadcode};
      $loadcode ||= 0;
      my $classes = $args{classes};
  
      my $self = bless {
          tags => $tags,
          loadcode => $loadcode,
          classes => $classes,
      }, $class;
  }
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      my $tags;
      my $loadcode = 0;
      my $classes;
      if (blessed($self)) {
          $tags = $self->{tags};
          $loadcode = $self->{loadcode};
          $classes = $self->{classes};
      }
      else {
          my $options = $args{options};
          my $tagtype = '!perl';
          for my $option (@$options) {
              if ($option =~ m/^tags?=(.+)$/) {
                  $tagtype = $1;
              }
              elsif ($option eq '+loadcode') {
                  $loadcode = 1;
              }
          }
          $tags = [split m/\+/, $tagtype];
      }
  
  
      my $perl_tag;
      my %tagtypes;
      my @perl_tags;
      for my $type (@$tags) {
          if ($type eq '!perl') {
              $perl_tag ||= $type;
              push @perl_tags, '!perl';
          }
          elsif ($type eq '!!perl') {
              $perl_tag ||= 'tag:yaml.org,2002:perl';
              push @perl_tags, 'tag:yaml.org,2002:perl';
          }
          else {
              die "Invalid tagtype '$type'";
          }
          $tagtypes{ $type } = 1;
      }
  
      my $perl_regex = '!perl';
      if ($tagtypes{'!perl'} and $tagtypes{'!!perl'}) {
          $perl_regex = '(?:tag:yaml\\.org,2002:|!)perl';
      }
      elsif ($tagtypes{'!perl'}) {
          $perl_regex = '!perl';
      }
      elsif ($tagtypes{'!!perl'}) {
          $perl_regex = 'tag:yaml\\.org,2002:perl';
      }
  
      my $class_regex = qr{.+};
      my $no_objects = 0;
      if ($classes) {
          if (@$classes) {
              $class_regex = '(' . join( '|', map "\Q$_\E", @$classes ) . ')';
          }
          else {
              $no_objects = 1;
              $class_regex = '';
          }
      }
  
      if ($loadcode) {
          my $load_code = sub {
              my ($constructor, $event) = @_;
              return $self->evaluate_code($event->{value});
          };
          my $load_code_blessed = sub {
              my ($constructor, $event) = @_;
              my $class = $event->{tag};
              $class =~ s{^$perl_regex/code:}{};
              my $sub = $self->evaluate_code($event->{value});
              return $self->object($sub, $class);
          };
          $schema->add_resolver(
              tag => "$_/code",
              match => [ all => $load_code],
              implicit => 0,
          ) for @perl_tags;
          $schema->add_resolver(
              tag => qr{^$perl_regex/code:$class_regex$},
              match => [ all => $load_code_blessed ],
              implicit => 0,
          );
          $schema->add_resolver(
              tag => qr{^$perl_regex/code:.+},
              match => [ all => $load_code ],
              implicit => 0,
          ) if $no_objects;
      }
      else {
          my $loadcode_dummy = sub { return sub {} };
          my $loadcode_blessed_dummy = sub {
              my ($constructor, $event) = @_;
              my $class = $event->{tag};
              $class =~ s{^$perl_regex/code:}{};
              return $self->object(sub {}, $class);
          };
          $schema->add_resolver(
              tag => "$_/code",
              match => [ all => $loadcode_dummy ],
              implicit => 0,
          ) for @perl_tags;
          $schema->add_resolver(
              tag => qr{^$perl_regex/code:$class_regex$},
              match => [ all => $loadcode_blessed_dummy ],
              implicit => 0,
          );
          $schema->add_resolver(
              tag => qr{^$perl_regex/code:.+},
              match => [ all => $loadcode_dummy ],
              implicit => 0,
          ) if $no_objects;
      }
  
      my $load_regex = sub {
          my ($constructor, $event) = @_;
          return $self->construct_regex($event->{value});
      };
      my $load_regex_blessed = sub {
          my ($constructor, $event) = @_;
          my $class = $event->{tag};
          $class =~ s{^$perl_regex/regexp:}{};
          my $qr = $self->construct_regex($event->{value});
          return $self->object($qr, $class);
      };
      $schema->add_resolver(
          tag => "$_/regexp",
          match => [ all => $load_regex ],
          implicit => 0,
      ) for @perl_tags;
      $schema->add_resolver(
          tag => qr{^$perl_regex/regexp:$class_regex$},
          match => [ all => $load_regex_blessed ],
          implicit => 0,
      );
      $schema->add_resolver(
          tag => qr{^$perl_regex/regexp:$class_regex$},
          match => [ all => $load_regex ],
          implicit => 0,
      ) if $no_objects;
  
      my $load_sequence = sub { return [] };
      my $load_sequence_blessed = sub {
          my ($constructor, $event) = @_;
          my $class = $event->{tag};
          $class =~ s{^$perl_regex/array:}{};
          return $self->object([], $class);
      };
      $schema->add_sequence_resolver(
          tag => "$_/array",
          on_create => $load_sequence,
      ) for @perl_tags;
      $schema->add_sequence_resolver(
          tag => qr{^$perl_regex/array:$class_regex$},
          on_create => $load_sequence_blessed,
      );
      $schema->add_sequence_resolver(
          tag => qr{^$perl_regex/array:.+$},
          on_create => $load_sequence,
      ) if $no_objects;
  
      my $load_mapping = sub { return {} };
      my $load_mapping_blessed = sub {
          my ($constructor, $event) = @_;
          my $class = $event->{tag};
          $class =~ s{^$perl_regex/hash:}{};
          return $self->object({}, $class);
      };
      $schema->add_mapping_resolver(
          tag => "$_/hash",
          on_create => $load_mapping,
      ) for @perl_tags;
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/hash:$class_regex$},
          on_create => $load_mapping_blessed,
      );
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/hash:.+$},
          on_create => $load_mapping,
      ) if $no_objects;
  
      my $load_ref = sub {
          my $value = undef;
          return \$value;
      };
      my $load_ref_blessed = sub {
          my ($constructor, $event) = @_;
          my $class = $event->{tag};
          $class =~ s{^$perl_regex/ref:}{};
          my $value = undef;
          return $self->object(\$value, $class);
      };
      $schema->add_mapping_resolver(
          tag => "$_/ref",
          on_create => $load_ref,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_ref($list);
          },
      ) for @perl_tags;
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/ref:$class_regex$},
          on_create => $load_ref_blessed,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_ref($list);
          },
      );
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/ref:.+$},
          on_create => $load_ref,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_ref($list);
          },
      ) if $no_objects;
  
      my $load_scalar_ref = sub {
          my $value = undef;
          return \$value;
      };
      my $load_scalar_ref_blessed = sub {
          my ($constructor, $event) = @_;
          my $class = $event->{tag};
          $class =~ s{^$perl_regex/scalar:}{};
          my $value = undef;
          return $self->object(\$value, $class);
      };
      $schema->add_mapping_resolver(
          tag => "$_/scalar",
          on_create => $load_scalar_ref,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_scalar($list);
          },
      ) for @perl_tags;
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/scalar:$class_regex$},
          on_create => $load_scalar_ref_blessed,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_scalar($list);
          },
      );
      $schema->add_mapping_resolver(
          tag => qr{^$perl_regex/scalar:.+$},
          on_create => $load_scalar_ref,
          on_data => sub {
              my ($constructor, $ref, $list) = @_;
              $$$ref = $self->construct_scalar($list);
          },
      ) if $no_objects;
  
      $schema->add_representer(
          scalarref => 1,
          code => sub {
              my ($rep, $node) = @_;
              $node->{tag} = $perl_tag . "/scalar";
              $node->{data} = $self->represent_scalar($node->{value});
          },
      );
      $schema->add_representer(
          refref => 1,
          code => sub {
              my ($rep, $node) = @_;
              $node->{tag} = $perl_tag . "/ref";
              $node->{data} = $self->represent_ref($node->{value});
          },
      );
      $schema->add_representer(
          coderef => 1,
          code => sub {
              my ($rep, $node) = @_;
              $node->{tag} = $perl_tag . "/code";
              $node->{data} = $self->represent_code($node->{value});
          },
      );
  
      $schema->add_representer(
          class_matches => 1,
          code => sub {
              my ($rep, $node) = @_;
              my $blessed = blessed $node->{value};
              my $tag_blessed = ":$blessed";
              if ($blessed !~ m/^$class_regex$/) {
                  $tag_blessed = '';
              }
              $node->{tag} = sprintf "$perl_tag/%s%s",
                  lc($node->{reftype}), $tag_blessed;
              if ($node->{reftype} eq 'HASH') {
                  $node->{data} = $node->{value};
              }
              elsif ($node->{reftype} eq 'ARRAY') {
                  $node->{data} = $node->{value};
              }
  
              # Fun with regexes in perl versions!
              elsif ($node->{reftype} eq 'REGEXP') {
                  if ($blessed eq 'Regexp') {
                      $node->{tag} = $perl_tag . "/regexp";
                  }
                  $node->{data} = $self->represent_regex($node->{value});
              }
              elsif ($node->{reftype} eq 'SCALAR') {
  
                  # in perl <= 5.10 regex reftype(regex) was SCALAR
                  if ($blessed eq 'Regexp') {
                      $node->{tag} = $perl_tag . '/regexp';
                      $node->{data} = $self->represent_regex($node->{value});
                  }
  
                  # In perl <= 5.10 there seemed to be no better pure perl
                  # way to detect a blessed regex?
                  elsif (
                      $] <= 5.010001
                      and not defined ${ $node->{value} }
                      and $node->{value} =~ m/^\(\?/
                  ) {
                      $node->{tag} = $perl_tag . '/regexp' . $tag_blessed;
                      $node->{data} = $self->represent_regex($node->{value});
                  }
                  else {
                      # phew, just a simple scalarref
                      $node->{data} = $self->represent_scalar($node->{value});
                  }
              }
              elsif ($node->{reftype} eq 'REF') {
                  $node->{data} = $self->represent_ref($node->{value});
              }
  
              elsif ($node->{reftype} eq 'CODE') {
                  $node->{data} = $self->represent_code($node->{value});
              }
              else {
                  die "Reftype '$node->{reftype}' not implemented";
              }
  
              return 1;
          },
      );
      return;
  }
  
  sub evaluate_code {
      my ($self, $code) = @_;
      unless ($code =~ m/^ \s* \{ .* \} \s* \z/xs) {
          die "Malformed code";
      }
      $code = "sub $code";
      my $sub = eval $code;
      if ($@) {
          die "Couldn't eval code: $@>>$code<<";
      }
      return $sub;
  }
  
  sub construct_regex {
      my ($self, $regex) = @_;
      if ($regex =~ m/^$qr_prefix(.*)\)\z/s) {
          $regex = $1;
      }
      my $qr = qr{$regex};
      return $qr;
  }
  
  sub construct_scalar {
      my ($self, $list) = @_;
      if (@$list != 2) {
          die "Unexpected data in perl/scalar construction";
      }
      my ($key, $value) = @$list;
      unless ($key eq '=') {
          die "Unexpected data in perl/scalar construction";
      }
      return $value;
  }
  
  sub construct_ref {
      &construct_scalar;
  }
  
  sub represent_scalar {
      my ($self, $value) = @_;
      return { '=' => $$value };
  }
  
  sub represent_ref {
      &represent_scalar;
  }
  
  sub represent_code {
      my ($self, $code) = @_;
      require B::Deparse;
      my $deparse = B::Deparse->new("-p", "-sC");
      return $deparse->coderef2text($code);
  }
  
  sub represent_regex {
      my ($self, $regex) = @_;
      $regex = "$regex";
      if ($regex =~ m/^$qr_prefix(.*)\)\z/s) {
          $regex = $1;
      }
      return $regex;
  }
  
  sub object {
      my ($self, $data, $class) = @_;
      return bless $data, $class;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Perl - Schema for serializing perl objects and special types
  
  =head1 SYNOPSIS
  
      use YAML::PP;
      # This can be dangerous when loading untrusted YAML!
      my $yp = YAML::PP->new( schema => [qw/ JSON Perl /] );
      # or
      my $yp = YAML::PP->new( schema => [qw/ Core Perl /] );
      my $yaml = $yp->dump_string(sub { return 23 });
  
      # loading code references
      # This is very dangerous when loading untrusted YAML!!
      my $yp = YAML::PP->new( schema => [qw/ JSON Perl +loadcode /] );
      my $code = $yp->load_string(<<'EOM');
      --- !perl/code |
          {
              use 5.010;
              my ($name) = @_;
              say "Hello $name!";
          }
      EOM
      $code->("Ingy");
  
  =head1 DESCRIPTION
  
  This schema allows you to load and dump perl objects and special types.
  
  Please note that loading objects of arbitrary classes can be dangerous
  in Perl. You have to load the modules yourself, but if an exploitable module
  is loaded and an object is created, its C<DESTROY> method will be called
  when the object falls out of scope. L<File::Temp> is an example that can
  be exploitable and might remove arbitrary files.
  
  Typeglobs are not implemented yet. Dumping code references is on by default, but
  not loading (because that is easily exploitable since it's using string
  C<eval>).
  
  =head2 Tag Styles
  
  You can define the style of tags you want to support:
  
      my $yp_perl_two_one = YAML::PP->new(
          schema => [qw/ JSON Perl tags=!!perl+!perl /],
      );
  
  =over
  
  =item C<!perl> (default)
  
  Only C<!perl/type> tags are supported.
  
  =item C<!!perl>
  
  Only C<!!perl/type> tags are supported.
  
  =item C<!perl+!!perl>
  
  Both C<!perl/type> and C<!!perl/tag> are supported when loading. When dumping,
  C<!perl/type> is used.
  
  =item C<!!perl+!perl>
  
  Both C<!perl/type> and C<!!perl/tag> are supported when loading. When dumping,
  C<!!perl/type> is used.
  
  =back
  
  L<YAML>.pm, L<YAML::Syck> and L<YAML::XS> are using C<!!perl/type> when dumping.
  
  L<YAML>.pm and L<YAML::Syck> are supporting both C<!perl/type> and
  C<!!perl/type> when loading. L<YAML::XS> currently only supports the latter.
  
  =head2 Allow only certain classes
  
  Since v0.017
  
  Blessing arbitrary objects can be dangerous.  Maybe you want to allow blessing
  only specific classes and ignore others.  For this you have to instantiate
  a Perl Schema object first and use the C<classes> option.
  
  Currently it only allows a list of strings:
  
      my $perl = YAML::PP::Schema::Perl->new(
          classes => ['Foo', 'Bar'],
      );
      my $yp = YAML::PP::Perl->new(
          schema => [qw/ JSON /, $perl],
      );
  
  Allowed classes will be loaded and dumped as usual. The others will be ignored.
  
  If you want to allow no objects at all, pass an empty array ref.
  
  
  =cut
  
  =head2 EXAMPLES
  
  This is a list of the currently supported types and how they are dumped into
  YAML:
  
  =cut
  
  ### BEGIN EXAMPLE
  
  =pod
  
  =over 4
  
  =item array
  
          # Code
          [
              qw/ one two three four /
          ]
  
  
          # YAML
          ---
          - one
          - two
          - three
          - four
  
  
  =item array_blessed
  
          # Code
          bless [
              qw/ one two three four /
          ], "Just::An::Arrayref"
  
  
          # YAML
          --- !perl/array:Just::An::Arrayref
          - one
          - two
          - three
          - four
  
  
  =item circular
  
          # Code
          my $circle = bless [ 1, 2 ], 'Circle';
          push @$circle, $circle;
          $circle;
  
  
          # YAML
          --- &1 !perl/array:Circle
          - 1
          - 2
          - *1
  
  
  =item coderef
  
          # Code
          sub {
              my (%args) = @_;
              return $args{x} + $args{y};
          }
  
  
          # YAML
          --- !perl/code |-
            {
                use warnings;
                use strict;
                (my(%args) = @_);
                (return ($args{'x'} + $args{'y'}));
            }
  
  
  =item coderef_blessed
  
          # Code
          bless sub {
              my (%args) = @_;
              return $args{x} - $args{y};
          }, "I::Am::Code"
  
  
          # YAML
          --- !perl/code:I::Am::Code |-
            {
                use warnings;
                use strict;
                (my(%args) = @_);
                (return ($args{'x'} - $args{'y'}));
            }
  
  
  =item hash
  
          # Code
          {
              U => 2,
              B => 52,
          }
  
  
          # YAML
          ---
          B: 52
          U: 2
  
  
  =item hash_blessed
  
          # Code
          bless {
              U => 2,
              B => 52,
          }, 'A::Very::Exclusive::Class'
  
  
          # YAML
          --- !perl/hash:A::Very::Exclusive::Class
          B: 52
          U: 2
  
  
  =item refref
  
          # Code
          my $ref = { a => 'hash' };
          my $refref = \$ref;
          $refref;
  
  
          # YAML
          --- !perl/ref
          =:
            a: hash
  
  
  =item refref_blessed
  
          # Code
          my $ref = { a => 'hash' };
          my $refref = bless \$ref, 'Foo';
          $refref;
  
  
          # YAML
          --- !perl/ref:Foo
          =:
            a: hash
  
  
  =item regexp
  
          # Code
          my $string = 'unblessed';
          utf8::upgrade($string);
          qr{$string}
  
  
          # YAML
          --- !perl/regexp unblessed
  
  
  =item regexp_blessed
  
          # Code
          my $string = 'blessed';
          utf8::upgrade($string);
          bless qr{$string}, "Foo"
  
  
          # YAML
          --- !perl/regexp:Foo blessed
  
  
  =item scalarref
  
          # Code
          my $scalar = "some string";
          my $scalarref = \$scalar;
          $scalarref;
  
  
          # YAML
          --- !perl/scalar
          =: some string
  
  
  =item scalarref_blessed
  
          # Code
          my $scalar = "some other string";
          my $scalarref = bless \$scalar, 'Foo';
          $scalarref;
  
  
          # YAML
          --- !perl/scalar:Foo
          =: some other string
  
  
  
  
  =back
  
  =cut
  
  ### END EXAMPLE
  
  =head2 METHODS
  
  =over
  
  =item new
  
      my $perl = YAML::PP::Schema::Perl->new(
          tags => "!perl",
          classes => ['MyClass'],
          loadcode => 1,
      );
  
  The constructor recognizes the following options:
  
  =over
  
  =item tags
  
  Default: 'C<!perl>'
  
  See L<"Tag Styles">
  
  =item classes
  
  Default: C<undef>
  
  Since: v0.017
  
  Accepts an array ref of class names
  
  =item loadcode
  
  Default: 0
  
  =back
  
  =item register
  
  A class method called by L<YAML::PP::Schema>
  
  =item construct_ref, represent_ref
  
  Perl variables of the type C<REF> are represented in yaml like this:
  
      --- !perl/ref
      =:
        a: 1
  
  C<construct_ref> returns the perl data:
  
      my $data = YAML::PP::Schema::Perl->construct_ref([ '=', { some => 'data' } );
      my $data = \{ a => 1 };
  
  C<represent_ref> turns a C<REF> variable into a YAML mapping:
  
      my $data = YAML::PP::Schema::Perl->represent_ref(\{ a => 1 });
      my $data = { '=' => { a => 1 } };
  
  =item construct_scalar, represent_scalar
  
  Perl variables of the type C<SCALAR> are represented in yaml like this:
  
      --- !perl/scalar
      =: string
  
  C<construct_scalar> returns the perl data:
  
      my $data = YAML::PP::Schema::Perl->construct_ref([ '=', 'string' );
      my $data = \'string';
  
  C<represent_scalar> turns a C<SCALAR> variable into a YAML mapping:
  
      my $data = YAML::PP::Schema::Perl->represent_scalar(\'string');
      my $data = { '=' => 'string' };
  
  =item construct_regex, represent_regex
  
  C<construct_regex> returns a C<qr{}> object from the YAML string:
  
      my $qr = YAML::PP::Schema::Perl->construct_regex('foo.*');
  
  C<represent_regex> returns a string representing the regex object:
  
      my $string = YAML::PP::Schema::Perl->represent_regex(qr{...});
  
  =item evaluate_code, represent_code
  
  C<evaluate_code> returns a code reference from a string. The string must
  start with a C<{> and end with a C<}>.
  
      my $code = YAML::PP::Schema::Perl->evaluate_code('{ return 23 }');
  
  C<represent_code> returns a string representation of the code reference
  with the help of B::Deparse:
  
      my $string = YAML::PP::Schema::Perl->represent_code(sub { return 23 });
  
  =item object
  
  Does the same as C<bless>:
  
      my $object = YAML::PP::Schema::Perl->object($data, $class);
  
  =back
  
  =cut
YAML_PP_SCHEMA_PERL

$fatpacked{"YAML/PP/Schema/Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_TIE_IXHASH';
  use strict;
  use warnings;
  package YAML::PP::Schema::Tie::IxHash;
  
  our $VERSION = '0.018'; # VERSION
  
  use base 'YAML::PP::Schema';
  
  use Scalar::Util qw/ blessed reftype /;
  my $ixhash = eval { require Tie::IxHash };
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
      unless ($ixhash) {
          die "You need to install Tie::IxHash in order to use this module";
      }
  
      $schema->add_representer(
          tied_equals => 'Tie::IxHash',
          code => sub {
              my ($rep, $node) = @_;
              $node->{items} = [ %{ $node->{data} } ];
              return 1;
          },
      );
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::Tie::IxHash - Schema for serializing ordered hashes
  
  =head1 SYNOPSIS
  
      use YAML::PP;
      use Tie::IxHash;
      my $yp = YAML::PP->new( schema => [qw/ JSON Tie::IxHash /] );
  
      tie(my %ordered, 'Tie::IxHash');
      %ordered = (
          U => 2,
          B => 52,
      );
  
      my $yaml = $yp->dump_string(\%ordered);
  
  
      # Output:
      ---
      U: 2
      B: 52
  
  =head1 DESCRIPTION
  
  This schema allows you to dump ordered hashes which are tied to
  L<Tie::IxHash>.
  
  This code is pretty new and experimental.
  
  It is not yet implemented for loading yet, so for now you have to tie
  the hashes yourself.
  
  Examples:
  
  =cut
  
  ### BEGIN EXAMPLE
  
  =pod
  
  =over 4
  
  =item order
  
          # Code
          tie(my %order, 'Tie::IxHash');
          %order = (
              U => 2,
              B => 52,
              c => 64,
              19 => 84,
              Disco => 2000,
              Year => 2525,
              days_on_earth => 20_000,
          );
          \%order;
  
  
          # YAML
          ---
          U: 2
          B: 52
          c: 64
          19: 84
          Disco: 2000
          Year: 2525
          days_on_earth: 20000
  
  
  =item order_blessed
  
          # Code
          tie(my %order, 'Tie::IxHash');
          %order = (
              U => 2,
              B => 52,
              c => 64,
              19 => 84,
              Disco => 2000,
              Year => 2525,
              days_on_earth => 20_000,
          );
          bless \%order, 'Order';
  
  
          # YAML
          --- !perl/hash:Order
          U: 2
          B: 52
          c: 64
          19: 84
          Disco: 2000
          Year: 2525
          days_on_earth: 20000
  
  
  
  
  =back
  
  =cut
  
  ### END EXAMPLE
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =back
  
  =cut
YAML_PP_SCHEMA_TIE_IXHASH

$fatpacked{"YAML/PP/Schema/YAML1_1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_YAML1_1';
  use strict;
  use warnings;
  package YAML::PP::Schema::YAML1_1;
  
  our $VERSION = '0.018'; # VERSION
  
  use YAML::PP::Schema::JSON qw/
      represent_int represent_float represent_literal represent_bool
      represent_undef
  /;
  
  use YAML::PP::Common qw/ YAML_PLAIN_SCALAR_STYLE /;
  
  #https://yaml.org/type/bool.html
  # y|Y|yes|Yes|YES|n|N|no|No|NO
  # |true|True|TRUE|false|False|FALSE
  # |on|On|ON|off|Off|OFF
  
  # https://yaml.org/type/float.html
  #  [-+]?([0-9][0-9_]*)?\.[0-9.]*([eE][-+][0-9]+)? (base 10)
  # |[-+]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]* (base 60)
  # |[-+]?\.(inf|Inf|INF) # (infinity)
  # |\.(nan|NaN|NAN) # (not a number)
  
  # https://yaml.org/type/int.html
  #  [-+]?0b[0-1_]+ # (base 2)
  # |[-+]?0[0-7_]+ # (base 8)
  # |[-+]?(0|[1-9][0-9_]*) # (base 10)
  # |[-+]?0x[0-9a-fA-F_]+ # (base 16)
  # |[-+]?[1-9][0-9_]*(:[0-5]?[0-9])+ # (base 60)
  
  # https://yaml.org/type/null.html
  #  ~ # (canonical)
  # |null|Null|NULL # (English)
  # | # (Empty)
  
  my $RE_INT_1_1 = qr{^([+-]?(?:[0-9_]+))$};
  #my $RE_FLOAT_1_1 = qr{^([+-]?([0-9][0-9_]*)?\.[0-9.]*([eE][+-][0-9]+)?)$};
  # https://yaml.org/type/float.html has a bug. The regex says \.[0-9.], but
  # probably means \.[0-9_]
  my $RE_FLOAT_1_1 = qr{^([+-]?(?:[0-9][0-9_]*)?\.[0-9_]*(?:[eE][+-][0-9]+)?)$};
  my $RE_SEXAGESIMAL = qr{^([+-]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)$};
  my $RE_SEXAGESIMAL_INT = qr{^([-+]?[1-9][0-9_]*(:[0-5]?[0-9])+)$};
  my $RE_INT_OCTAL_1_1 = qr{^([+-]?)0([0-7_]+)$};
  my $RE_INT_HEX_1_1 = qr{^([+-]?)(0x[0-9a-fA-F_]+)$};
  my $RE_INT_BIN_1_1 = qr{^([-+]?)(0b[0-1_]+)$};
  
  sub _from_oct {
      my ($constructor, $event, $matches) = @_;
      my ($sign, $oct) = @$matches;
      $oct =~ tr/_//d;
      my $result = oct $oct;
      $result = -$result if $sign eq '-';
      return $result;
  }
  sub _from_hex {
      my ($constructor, $event, $matches) = @_;
      my ($sign, $hex) = @$matches;
      my $result = hex $hex;
      $result = -$result if $sign eq '-';
      return $result;
  }
  sub _sexa_to_float {
      my ($constructor, $event, $matches) = @_;
      my ($float) = @$matches;
      my $result = 0;
      my $i = 0;
      my $sign = 1;
      $float =~ s/^-// and $sign = -1;
      for my $part (reverse split m/:/, $float) {
          $result += $part * ( 60 ** $i );
          $i++;
      }
      $result = unpack F => pack F => $result;
      return $result * $sign;
  }
  sub _to_float {
      my ($constructor, $event, $matches) = @_;
      my ($float) = @$matches;
      $float =~ tr/_//d;
      $float = unpack F => pack F => $float;
      return $float;
  }
  sub _to_int {
      my ($constructor, $event, $matches) = @_;
      my ($int) = @$matches;
      $int =~ tr/_//d;
      0 + $int;
  }
  
  sub register {
      my ($self, %args) = @_;
      my $schema = $args{schema};
  
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:null',
          match => [ equals => $_ => undef ],
      ) for (qw/ null NULL Null ~ /, '');
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => $_ => $schema->true ],
      ) for (qw/ true TRUE True y Y yes Yes YES on On ON /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:bool',
          match => [ equals => $_ => $schema->false ],
      ) for (qw/ false FALSE False n N no No NO off Off OFF /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_OCTAL_1_1 => \&_from_oct ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_1_1 => \&_to_int ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_HEX_1_1 => \&_from_hex ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ regex => $RE_FLOAT_1_1 => \&_to_float ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_INT_BIN_1_1 => \&_from_oct ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:int',
          match => [ regex => $RE_SEXAGESIMAL_INT => \&_sexa_to_float ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ regex => $RE_SEXAGESIMAL => \&_sexa_to_float ],
      );
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 + "inf" ],
      ) for (qw/ .inf .Inf .INF +.inf +.Inf +.INF /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 - "inf" ],
      ) for (qw/ -.inf -.Inf -.INF /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:float',
          match => [ equals => $_ => 0 + "nan" ],
      ) for (qw/ .nan .NaN .NAN /);
      $schema->add_resolver(
          tag => 'tag:yaml.org,2002:str',
          match => [ all => sub { $_[1]->{value} } ],
          implicit => 0,
      );
  
      my $int_flags = B::SVp_IOK;
      my $float_flags = B::SVp_NOK;
      $schema->add_representer(
          flags => $int_flags,
          code => \&represent_int,
      );
      $schema->add_representer(
          flags => $float_flags,
          code => \&represent_float,
      );
      $schema->add_representer(
          undefined => \&represent_undef,
      );
      $schema->add_representer(
          equals => $_,
          code => \&represent_literal,
      ) for ("", qw/
          true TRUE True y Y yes Yes YES on On ON
          false FALSE False n N n no No NO off Off OFF
          null NULL Null ~
          .inf .Inf .INF -.inf -.Inf -.INF +.inf +.Inf +.INF .nan .NaN .NAN
      /);
      $schema->add_representer(
          regex => qr{$RE_INT_1_1|$RE_FLOAT_1_1|$RE_INT_OCTAL_1_1|$RE_INT_HEX_1_1|$RE_INT_BIN_1_1|$RE_SEXAGESIMAL_INT|$RE_SEXAGESIMAL},
          code => \&represent_literal,
      );
  
      if ($schema->bool_class) {
          $schema->add_representer(
              class_equals => $schema->bool_class,
              code => \&represent_bool,
          );
      }
  
      return;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Schema::YAML1_1 - YAML 1.1 Schema for YAML::PP
  
  =head1 SYNOPSIS
  
      use YAML::PP;
  
      my $yp = YAML::PP->new( schema => ['YAML1_1'] );
      my $yaml = <<'EOM';
      ---
      booltrue: [ true, True, TRUE, y, Y, yes, Yes, YES, on, On, ON ]
      EOM
      my $data = $yp->load_string($yaml);
  
  =head1 DESCRIPTION
  
  This schema allows you to load the common YAML Types from YAML 1.1.
  
  =head1 METHODS
  
  =over
  
  =item register
  
  Called by YAML::PP::Schema
  
  =back
  
  =head1 SEE ALSO
  
  =over
  
  =item L<https://yaml.org/type/null.html>
  
  =item L<https://yaml.org/type/float.html>
  
  =item L<https://yaml.org/type/int.html>
  
  =item L<https://yaml.org/type/bool.html>
  
  =back
YAML_PP_SCHEMA_YAML1_1

$fatpacked{"YAML/PP/Type/MergeKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_TYPE_MERGEKEY';
  use strict;
  use warnings;
  package YAML::PP::Type::MergeKey;
  
  our $VERSION = '0.018'; # VERSION
  
  sub new {
      my ($class) = @_;
      return bless {}, $class;
  }
  
  1;
  
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Type::MergeKey - A special node type for merge keys
  
  =head1 DESCRIPTION
  
  See L<YAML::PP::Schema::Merge>
  
  =head1 METHODS
  
  =over
  
  =item new
  
  Constructor
  
  =back
  
  =cut
  
YAML_PP_TYPE_MERGEKEY

$fatpacked{"YAML/PP/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER';
  # ABSTRACT: Writer class for YAML::PP representing output data
  use strict;
  use warnings;
  package YAML::PP::Writer;
  
  our $VERSION = '0.018'; # VERSION
  
  sub output { return $_[0]->{output} }
  sub set_output { $_[0]->{output} = $_[1] }
  
  sub new {
      my ($class, %args) = @_;
      my $output = delete $args{output};
      $output = '' unless defined $output;
      return bless {
          output => $output,
      }, $class;
  }
  
  sub write {
      my ($self, $line) = @_;
      $self->{output} .= $line;
  }
  
  sub init {
      $_[0]->set_output('');
  }
  
  sub finish {
      my ($self) = @_;
      $_[0]->set_output(undef);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Writer - Write YAML output
  
  =head1 SYNOPSIS
  
      my $writer = YAML::PP::Writer->new;
  
  =head1 DESCRIPTION
  
  The L<YAML::PP::Emitter> sends its output to the writer.
  
  You can use your own writer. if you want to send the YAML output to
  somewhere else. See t/44.writer.t for an example.
  
  =head1 METHODS
  
  =over
  
  =item new
  
      my $writer = YAML::PP::Writer->new;
  
  Constructor.
  
  =item write
  
      $writer->write('- ');
  
  =item init
  
      $writer->init;
  
  Initialize
  
  =item finish
  
      $writer->finish;
  
  Gets called when the output ends.
  
  =item output, set_output
  
  Getter/setter for the YAML output
  
  =back
  
  =cut
YAML_PP_WRITER

$fatpacked{"YAML/PP/Writer/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER_FILE';
  use strict;
  use warnings;
  package YAML::PP::Writer::File;
  
  our $VERSION = '0.018'; # VERSION
  
  use Scalar::Util qw/ openhandle /;
  
  use base qw/ YAML::PP::Writer /;
  
  use Carp qw/ croak /;
  
  sub _open_handle {
      my ($self) = @_;
      if (openhandle($self->{output})) {
          $self->{filehandle} = $self->{output};
          return $self->{output};
      }
      open my $fh, '>:encoding(UTF-8)', $self->{output}
          or croak "Could not open '$self->{output}' for writing: $!";
      $self->{filehandle} = $fh;
      return $fh;
  }
  
  sub write {
      my ($self, $line) = @_;
      my $fh = $self->{filehandle};
      print $fh $line;
  }
  
  sub init {
      my ($self) = @_;
      my $fh = $self->_open_handle;
  }
  
  sub finish {
      my ($self) = @_;
      if (openhandle($self->{output})) {
          # Original argument was a file handle, so the caller needs
          # to close it
          return;
      }
      close $self->{filehandle};
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  YAML::PP::Writer::File - Write YAML output to file or file handle
  
  =head1 SYNOPSIS
  
      my $writer = YAML::PP::Writer::File->new(output => $file);
  
  =head1 DESCRIPTION
  
  The L<YAML::PP::Emitter> sends its output to the writer.
  
  You can use your own writer. if you want to send the YAML output to
  somewhere else. See t/44.writer.t for an example.
  
  =head1 METHODS
  
  =over
  
  =item new
  
      my $writer = YAML::PP::Writer::File->new(output => $file);
      my $writer = YAML::PP::Writer::File->new(output => $filehandle);
  
  Constructor.
  
  =item write
  
      $writer->write('- ');
  
  =item init
  
      $writer->init;
  
  Initialize
  
  =item finish
  
      $writer->finish;
  
  Gets called when the output ends. If The argument was a filename, the
  filehandle will be closed. If the argument was a filehandle, the caller needs to
  close it.
  
  =item output, set_output
  
  Getter/setter for the YAML output
  
  =back
  
  =cut
YAML_PP_WRITER_FILE

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use Moo::_strictures;
  use Moo::_Utils qw(_load_module);
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  oo - syntactic sugar for Moo oneliners
  
  =head1 SYNOPSIS
  
    perl -Moo=Foo -e 'has bar => ( is => q[ro], default => q[baz] ); print Foo->new->bar'
  
    # loads an existing class and re-"opens" the package definition
    perl -Moo=+My::Class -e 'print __PACKAGE__->new->bar'
  
  =head1 DESCRIPTION
  
  oo.pm is a simple source filter that adds C<package $name; use Moo;> to the
  beginning of your script, intended for use on the command line via the -M
  option.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
OO

$fatpacked{"x86_64-linux/Class/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.19';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux/Class/XSAccessor/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.19';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux/Class/XSAccessor/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.19';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX_CLASS_XSACCESSOR_HEAVY

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.50";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.50";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Ref/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_REF_UTIL_XS';
  package Ref::Util::XS;
  # ABSTRACT: XS implementation for Ref::Util
  $Ref::Util::XS::VERSION = '0.116';
  use strict;
  use warnings;
  use XSLoader;
  
  use Exporter 5.57 'import';
  
  our %EXPORT_TAGS = ( 'all' => [qw<
      is_ref
      is_scalarref
      is_arrayref
      is_hashref
      is_coderef
      is_regexpref
      is_globref
      is_formatref
      is_ioref
      is_refref
  
      is_plain_ref
      is_plain_scalarref
      is_plain_arrayref
      is_plain_hashref
      is_plain_coderef
      is_plain_globref
      is_plain_formatref
      is_plain_refref
  
      is_blessed_ref
      is_blessed_scalarref
      is_blessed_arrayref
      is_blessed_hashref
      is_blessed_coderef
      is_blessed_globref
      is_blessed_formatref
      is_blessed_refref
  >] );
  
  our @EXPORT_OK   = ( @{ $EXPORT_TAGS{'all'} } );
  
  XSLoader::load('Ref::Util::XS', $Ref::Util::XS::{VERSION} ? ${ $Ref::Util::XS::{VERSION} } : ());
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Ref::Util::XS - XS implementation for Ref::Util
  
  =head1 VERSION
  
  version 0.116
  
  =head1 SYNOPSIS
  
      use Ref::Util;
      # Don't use Ref::Util::XS directly!
  
      if (is_arrayref($something) {
          print for @$something;
      }
      elsif (is_hashref($something)) {
          print for sort values %$something;
      }
  
  =head1 DESCRIPTION
  
  Ref::Util::XS is the XS implementation of Ref::Util, which provides several
  functions to help identify references in a more convenient way than the
  usual approach of examining the return value of C<ref>.
  
  You should use Ref::Util::XS by installing Ref::Util itself: if the system
  you install it on has a C compiler available, Ref::Util::XS will be
  installed and used automatically, providing a significant speed boost to
  everything that uses Ref::Util.
  
  See L<Ref::Util> for full documentation of the available functions.
  
  =head1 THANKS
  
  The following people have been invaluable in their feedback and support.
  
  =over 4
  
  =item * Yves Orton
  
  =item * Steffen MÃ¼ller
  
  =item * Jarkko Hietaniemi
  
  =item * Mattia Barbon
  
  =item * Zefram
  
  =item * Tony Cook
  
  =item * Sergey Aleynikov
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item * Aaron Crane
  
  =item * Vikentiy Fesunov
  
  =item * Sawyer X
  
  =item * Gonzalo Diethelm
  
  =item * p5pclub
  
  =back
  
  =head1 LICENSE
  
  This software is made available under the MIT Licence as stated in the
  accompanying LICENSE file.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Sawyer X <xsawyerx@cpan.org>
  
  =item *
  
  Aaron Crane <arc@cpan.org>
  
  =item *
  
  Vikenty Fesunov <vyf@cpan.org>
  
  =item *
  
  Gonzalo Diethelm <gonzus@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2017 by Sawyer X.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
X86_64-LINUX_REF_UTIL_XS

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.50";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# ABSTRACT: Various utilities for App::Spec files
# vim:et:sts=4:sws=4:sw=4
use strict;
use warnings;
use 5.010;
use Data::Dumper;

our $VERSION = '0.000'; # VERSION

use App::Spec;
use App::AppSpec;
use App::AppSpec::Spec qw/ $SPEC /;

my $spec = App::Spec->read($SPEC);
my $run = $spec->runner;
$run->run;

